let [%assert] = func(b, s) {
  if (b) { true } else { throw s }
}

{(/*:START SYM EVAL*/0)}

// To be bound later
let [%makeGlobalEnv] = { [] }

let [%ObjectProto] = { [#proto : null,] }

// The global object (15.1)
let [%global] = { [#proto : %ObjectProto, #class: "GlobalObject"] }

let [%GetterValue] = func(o) { o['func'] }

let [%SetterValue] = func(o) { o['func'] }

rec [%protoOfField] = func(object, fld) {
  if (object == null) { object }
  else if (prim("hasOwnProperty", object, fld)) { object }
  else { %protoOfField(object[<#proto>], fld) }
}

{(/*:STOP SYM EVAL*/0)}

{(/*:START SYM EVAL*/0)}

let [%AppExpr] = func(fun, this, args) {
  fun(this, args)
}

// 13.2.2
let [%DefaultConstruct] = func(constr, args) {
  let (cproto1 = constr["prototype"])
  let (cproto = if (object? cproto1) { cproto1 } else { %ObjectProto })
  let (newobj = {[#proto: cproto]})
  let (constr_ret = %AppExpr(constr, newobj, args))
  if (object? constr_ret) { constr_ret } else { newobj }
}

let [%FunctionProtoCall] = func(obj, this, args) { undefined }

let [%FunctionProto] = {
  [#proto: %ObjectProto, #class : "Function", #code : %FunctionProtoCall, construct: %DefaultConstruct]
  "length" : {#value 0, #writable true} }

{(/*:STOP SYM EVAL*/0)}

let [%ErrorProto] = 
  { [#proto : %ObjectProto, #class : "Error",]
    "name" : {#value "Error", #writable true, #enumerable false, #configurable true},
    "message" : {#value "", #writable true, #enumerable false, #configurable true}}

let [%MakeNativeErrorProto] = func(name) {
  { [#proto : %ErrorProto, #class: "Error"] 
    "name" : {#value name, #writable true, #enumerable false, #configurable true},
    "message" : {#value "", #writable true, #enumerable false, #configurable true}}
}

let [%TypeErrorProto] = %MakeNativeErrorProto("TypeError")

let [%ReferenceErrorProto] = %MakeNativeErrorProto("ReferenceError")

let [%SyntaxErrorProto] = %MakeNativeErrorProto("SyntaxError")

let [%EvalErrorProto] = %MakeNativeErrorProto("EvalError")

let [%RangeErrorProto] = %MakeNativeErrorProto("RangeError")

let [%IsJSError] = func(thing) {
  object? thing && prim("hasOwnProperty", thing, "%js-exn")
}

let [%JSError] = func(err) {
  { [#class: "JSError", #extensible: false] "%js-exn" : {#value err, #writable false, #enumerable false, #configurable false} }
}

let [%MakeNativeError] = func(proto, msg) {
  let (exc = { [#proto: proto, #class: "Error"] }) {
    if (msg != undefined) {
      exc['message'<#value> = msg];
      exc['message'<#enumerable> = false]
    };
    exc
  }
}

let [%NativeError] = func(proto, msg) {
  throw %JSError(%MakeNativeError(proto, msg))
}

let [%ReferenceError] = func(msg) {
  %NativeError(%ReferenceErrorProto, msg)
}

let [%UnboundId] = func(id) {
  %ReferenceError(prim("string+", "Unbound identifier: ", id))
}

let [%SyntaxError] = func(msg) {
  %NativeError(%SyntaxErrorProto, msg)
}

let [%TypeError] = func(msg) {
  %NativeError(%TypeErrorProto, msg)
}

let [%RangeError] = func(msg) {
  %NativeError(%RangeErrorProto, msg)
}

let [%ThrowTypeErrorFun] = func(obj, this, args) {
  let (msg = args["0"])
  %TypeError(msg)
}

let [%ThrowTypeError] = {[
    #code: %ThrowTypeErrorFun,
    #proto: %FunctionProto,
    #extensible: false,
    #class: "Function",
  ]
  "length": {#value 0, #writable false, #enumerable false, #configurable false}
}

// Errors that may be JavaScript and may be from the interpreter are
// handled here
let [%ErrorDispatch] = func(maybe-js-error) {
  if (%IsJSError(maybe-js-error)) { throw maybe-js-error }
  else if (maybe-js-error == "unwritable-field") {
    %TypeError("Field not writable")
  }
  else if (maybe-js-error == "unconfigurable-delete") {
    %TypeError("Field not deletable")
  }
  else { throw maybe-js-error }
}

let [%functionToStringCall] = func(obj, this, args) {
  let (t = typeof this)
  if (t == "object") {
    if (this[<#class>] == "Function") {
      if (prim("hasInternal", this, "codetxt")) { this[<codetxt>] } else {"<internal function>"}
    } else { %TypeError("Function.prototype.toString got a non-function") }
  } else { %TypeError("Function.prototype.toString got a non-object") }
}

let [%functionToString] = 
  { [#code : %functionToStringCall, #proto: %FunctionProto, #class: "Function",] 
  "length" : {#value 0, #writable false, #configurable false, #enumerable false} }

{
  %FunctionProto["toString" = %functionToString];
  %FunctionProto["toString"<#enumerable> = false]
}

let [%BooleanProto] = 
  { [#proto : %ObjectProto, #class : "Boolean", primval : false,]}

let [%MakeBoolean] = func(v) {
  {[#class: "Boolean",
    #extensible: true,
    #proto: %BooleanProto,
    primval: v,
    virtual: false]}
}

let [%NumberProto] = { [#proto : %ObjectProto, #class : "Number", primval : 0,]}

let [%MakeNumber] = func(v) {
  {[#class: "Number",
    #extensible: true,
    #proto: %NumberProto,
    primval: v,
    virtual: false]}
}

let [%ToBoolean] = func(x) {
  prim("prim->bool", x)
}

// 11.4.2
let [%Void] = func(val) {
  undefined
}

// 11.4.3
let [%Typeof] = func(val) {
  let (tp = typeof val)
  if (tp == "object") {
    if (val[<#code>] == undefined) { "object" } else { "function" }
  } else if (tp == "undefined") { "undefined" } 
  else if (tp == "null") { "object" }
  else if (tp == "boolean") { "boolean" }
  else if (tp == "number") { "number" }
  else if (tp == "string") { "string" }
  else { throw "[env] invalid value in %Typeof" }
}

let [%ObjectTypeCheck] = func(o) {
  if (object? o) { 
    null 
  } else { 
    %TypeError(prim("string+", prim("prim->str", o), " is not an object")) 
  }
}

let [%IsCallable] = func(o) {
  %Typeof(o) == "function"
}

let [%ComputeLength] = func(args) {
  rec (loop = func(iter) { 
    let (strx = prim("prim->str", iter)) 
    if (prim("hasOwnProperty", args, strx)) { 
      loop(iter + 1)
    } else { 
      iter
    }
  }) { loop(0) }
}

let [%AppExprCheck] = func(fun, this, args) {
  if(%IsCallable(fun)) {
    %AppExpr(fun, this, args)
  } else {
    %TypeError("Not a function")
  } 
}

let [%devirtualize] = func(obj) {
  if (typeof obj == 'object') {
    if (prim("hasInternal", obj, "virtual")) {
      if (obj[<virtual>]) { obj[<primval>] } else { obj }
    } else { obj }
  } else {
    obj
  }
}

let [%GetterProxyFun] = func(obj, this) {
    %AppExprCheck(obj["func"<#value>], %devirtualize(this), {[]})
}

let [%SetterProxyFun] = func(obj, this, arg) {
    %AppExprCheck(obj["func"<#value>], %devirtualize(this), {[] '0': {#value arg, #writable false}})
}

let [%MakeGetter] = func(f) {
  {[#code: %GetterProxyFun, #extensible: false, #class: "GetterProxy"] 
    'func': {#value f, #writable false, #enumerable false, #configurable false}}
}

let [%MakeSetter] = func(f) {
  {[#code: %SetterProxyFun, #extensible: false, #class: "SetterProxy"] 
    'func': {#value f, #writable false, #enumerable false, #configurable false}}
}

let [%mkArgsObj] = func(args) {
  let (argsObj = {[#proto: %ObjectProto,
                   #class: "Arguments",
                   #extensible: true]
                   "callee" : {#getter %MakeGetter(%ThrowTypeError), #setter %MakeSetter(%ThrowTypeError), #configurable false},
                   "caller" : {#getter %MakeGetter(%ThrowTypeError), #setter %MakeSetter(%ThrowTypeError), #configurable false}}) {
    rec (loop = func(iter) { 
      let (strx = prim("prim->str", iter)) 
      if (prim("hasOwnProperty", args, strx)) { 
        argsObj[strx<#value> = args[strx]];
        loop(iter + 1)
      }
      else { 
        argsObj["length"<#value> = iter];
        argsObj["length"<#enumerable> = false]
      }
    }) {
      loop(0);
      argsObj
    }
  }
}

let [%runConstruct] = func(constr, args) {
  constr[<construct>](constr, args)
}

// 11.2.2
let [%PrimNew] = func(constr, args) {
  if (!object? constr) { %TypeError("not a constructor") }
  else if (!prim("hasInternal", constr, "construct")) { %TypeError("not a constructor") }
  else { %runConstruct(constr, args) }
}

let [%instanceof] = func(l, r) {
  label ret: {
    if (%Typeof(r) != "function") {
      %TypeError("Non-function given to instanceof")
    } else { null };

    if (!object? l) {
      break ret false
    } else { null };

    let (O = r["prototype"]) 
    if (!object? O) {
      %TypeError("Prototype was not function or object")
    } else { 
      rec (search = func(v) {
        let (vp = v[<#proto>])
        if (vp == null) {
          false
        } else {
          if (O == vp) {
            true
          } else {
            search(vp)
          }
        }
      })
      break ret search(l)
    }
  }
}

let [%StringIndices] = func(obj, s) {
  let (len = prim("strlen", s))
  rec (loop = func(i) {
    if (prim("<", i, len)) {
      obj[prim("prim->str", i) = prim("char-at", s, i)];
      loop(prim("+", i, 1))
    } else { undefined }
  })
  loop(0)
}

{(/*:START SYM EVAL*/0)}

let [%StringProto] = { [#proto : %ObjectProto, #class : "String", primval : "",] 
  "length" : {#value 0, #writable false}}

{(/*:STOP SYM EVAL*/0)}

let [%MakeString] = func (v) {
  let (obj = 
       {[#class: "String", 
         #extensible: true,
         #proto: %StringProto,
         primval: v,
         virtual: false]
         "length" : {#value prim("strlen", v), #writable true}}) {
     %StringIndices(obj, v); obj 
  }
}

// 9.9
let [%ToObject] = func (o) {
  let (t = typeof o) 
  if (t == "null") { 
     %TypeError("%ToObject received null")
  } else if (t == "undefined") {
    %TypeError("%ToObject received undefined")
  } else if (t == "object") {
    o
  } else if (t == "string") {
    %MakeString(o)
  } else if (t == "number") {
    %MakeNumber(o)
  } else if (t == "boolean") {
    %MakeBoolean(o)
  } else { throw "[env] Invalid type in %ToObject" }
}

// used for creating the "virtual object" of GetValue and PutValue (8.7.1, 8.7.2)
let [%ToObjectVirtual] = func (o) {
  let (obj = %ToObject(o)) {
    if (prim("hasInternal", obj, "virtual")) { obj[<virtual> = true] };
    obj
  }
}

let [%ToPrimitiveHint] = func(val, hint) {
    if (object? val) {  
        let (check = func(str, next) { func () {
          let (f = val[str])
          if (%IsCallable(f)) {
            let (res = %AppExpr(f, val, {[]}))
            if (primitive? res) {res } 
            else { next() }
          } else { next() }
        }})
        let (met1 = if (hint == "string") { "toString" } else { "valueOf" })
        let (met2 = if (hint != "string") { "toString" } else { "valueOf" })
        check(met1, check(met2, func() { %TypeError("valueOf and toString both absent in toPrimitive") }))()
    }
    else { val }
}

let [%ToPrimitive] = func(val) {
    // TODO exception for date objects
    %ToPrimitiveHint(val, "number")
}

let [%ToString] = func(val) {
    prim("prim->str", %ToPrimitiveHint(val, "string"))
}

let [%GetField] = func(v, fld) {
  %ToObjectVirtual(v)[%ToString(fld)]
}

let [%AppMethod] = func(obj, fld, args) {
  let (fun = %GetField(obj, fld)) {
    %AppExprCheck(fun, obj, args)
  }
}

let [%resolveThis] = func(strict, obj) {
  if (strict) {
    obj
  } else {
    if ((obj == null) || (obj == undefined)) {
      %global
    } else {
      %ToObject(obj)
    }
  }
}

let [%in] = func(l, r) {
  if (!object? r) {
    %TypeError(prim("string+", %ToString(r), " is not an object"))
  } else {
    prim("hasProperty", r, %ToString(l))
  }
}

let [%ToNumber] = func(x) {
  prim("prim->num", %ToPrimitiveHint(x, "number"))
}

let [%ToInteger] = func(i) {
  let (num = %ToNumber(i)) 
  if (num === NaN) { 0 }
  else if (num == 0 || num == +inf || num == -inf) { num } 
  else { prim("sign", num) * prim("floor", prim("abs", num)) }
}

let [%Delete] = func(obj, fld, strict) {
  let (obj = %ToObject(obj))
  let (fld = %ToString(fld)) {
    try { 
      obj[delete fld]; true 
    } catch { func(e) {  
      if (strict) {
        %TypeError("unconfigurable delete in strict mode")
      } else { false }
    }}
  }
}

let [%AddDataField] = func(obj, name, v, w, e, c) {
  if (prim("hasOwnProperty", obj, name)) { fail("property already exists in %AddDataField") };
  obj[name<#value> = v];
  obj[name<#writable> = w];
  obj[name<#enumerable> = e];
  obj[name<#configurable> = c];
  undefined
}

let [%AddAccessorField] = func(obj, name, g, s, e, c) {
  if (prim("hasOwnProperty", obj, name)) { fail("property already exists in %AddAccessorField") };
  obj[name<#getter> = g];
  obj[name<#setter> = s];
  obj[name<#enumerable> = e];
  obj[name<#configurable> = c];
  undefined
}

let [%AddJsAccessorField] = func(obj, name, g, s, e, c) {
  %AddAccessorField(obj, name, %MakeGetter(g), %MakeSetter(s), e, c)
}

let [%DefaultCall] = func(obj, this, args) {
  obj[<usercode>](obj, this, args)
}

// 13.2
let [%MakeFunctionObject] = func(body, len, codetxt, strict) {
  let (fobj = {[#class: "Function", #proto: %FunctionProto, #code: %DefaultCall, #extensible: true, construct: %DefaultConstruct, usercode: body, codetxt: codetxt]
               "length": {#value len, #writable false, #enumerable false, #configurable false}})
  let (proto = {[#class: "Object", #proto: %ObjectProto]
                "constructor": {#value fobj, #writable true, #enumerable false, #configurable true}}) {
    %AddDataField(fobj, "prototype", proto, true, false, false);
    if (strict) {
      %AddJsAccessorField(fobj, "caller", %ThrowTypeError, %ThrowTypeError, false, false);
      %AddJsAccessorField(fobj, "arguments", %ThrowTypeError, %ThrowTypeError, false, false)
    };
    fobj
  }
}

let [%StxEq] = func(x1, x2) {
    prim("stx=", x1, x2)
}

// 11.9.3
rec [%EqEq] = func(x1, x2) {
    let (t1 = prim("typeof", x1))
    let (t2 = prim("typeof", x2))
    if(t1 == t2) {
        x1 == x2
    } else if((t1 == "undefined" && t2 == "null") ||
              (t1 == "null" && t2 == "undefined")) {
        true 
    } else if(t1 == "number" && t2 == "string") {
        x1 == prim("prim->num", x2) 
    } else if(t1 == "string" && t2 == "number") {
        prim("prim->num", x1) == x2 
    } else if(t1 == "boolean") {
        %EqEq(prim("prim->num", x1), x2) 
    } else if (t2 == "boolean") {
        %EqEq(x1, prim("prim->num", x2)) 
    } else if((t1 == "string" || t1 == "number") && (t2 == "object")) {
        %EqEq(x1, %ToPrimitive(x2)) 
    } else if((t2 == "string" || t2 == "number") && (t1 == "object")) {
        %EqEq(%ToPrimitive(x1), x2) 
    } else {
        false 
    }
}

let [%printCall] = func(obj, o, s) {
    prim("print", %ToString(s["0"]))
}

let [%print] = { [#code : %printCall, #proto: %FunctionProto, #class: "Function"] }

let [%len] = func(list) {
    rec (inner_len = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                prim("+", 1, inner_len(prim("+", 1, iter)))
            }
            else { iter }
        })
    inner_len(0)
}

let [%slice_internal] = func(list, min, max) {
    let (retObj = {[#extensible: true,]}) {
        rec (inner_slice = func(iter, ix) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                retObj[prim("prim->str", ix) = list[prim("prim->str", iter)] ];
                if(prim(">", iter, max)) { undefined }
                else { inner_slice(prim("+", iter, 1), prim("+", ix, 1)) }
            }
            else { retObj["length" = ix] }
        })
        inner_slice(min, 0);
        retObj
    }
}

let [isDataField] = func(obj, field) {
    ((obj[field<#value>] != undefined) ||
     (obj[field<#writable>] != undefined))
}

let [isAccessorField] = func(obj, field) {
    ((obj[field<#setter>] != undefined) ||
     (obj[field<#getter>] != undefined))
}

let [isGenericField] = func(obj, field) {
    (isDataField(obj, field) == false &&
     isAccessorField(obj, field) == false)
}

let [isDataDescriptor] = func(attr-obj) {
    (typeof (attr-obj["value"]) != "undefined" ||
     typeof (attr-obj["writable"]) != "undefined")
}

let [isAccessorDescriptor] = func(attr-obj) {
    (typeof (attr-obj["set"]) != "undefined" ||
     typeof (attr-obj["get"]) != "undefined")
}

let [isGenericDescriptor] = func(attr-obj) {
    (isAccessorDescriptor(attr-obj) == false &&
     isDataDescriptor(attr-obj) == false)
}

let [copy-when-defined] = func(obj1, obj2, s) {
    if(obj2[s] != undefined) {
        obj1[s = obj2[s] ]
    }
    else { undefined }
}

let [copy-data-desc] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "writable");
    copy-when-defined(obj1, obj2, "value");
    obj1[delete "get"];
    obj1[delete "set"]

}

let [copy-access-desc] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "set");
    copy-when-defined(obj1, obj2, "get");
    obj1[delete "value"];
    obj1[delete "writable"]
}

// 8.12.9
let [%defineOwnProperty] = func(obj, field, attr-obj) {
  if (!object? obj) { throw "defineOwnProperty didn't get object" }
  else { undefined };
  let (fstr = %ToString(field))
  if (prim("hasOwnProperty", obj, fstr) == false) {
    if (obj[<#extensible>]) {
      // Do this to open it up for the other properties (will set these last)
      obj[fstr<#configurable> = true];
      obj[fstr<#writable> = true];

                {if(isDataDescriptor(attr-obj)) {
          obj[fstr<#value> = attr-obj["value"] ];
          obj[fstr<#writable> = %ToBoolean(attr-obj["writable"]) ]
      }
      else if(isAccessorDescriptor(attr-obj)) {
          obj[fstr<#getter> = %MakeGetter(attr-obj["get"]) ];
          obj[fstr<#setter> = %MakeSetter(attr-obj["set"]) ]
                }
                else { undefined }};

      obj[fstr<#enumerable> = %ToBoolean(attr-obj["enumerable"]) ];
      obj[fstr<#configurable> = %ToBoolean(attr-obj["configurable"]) ];
      true
    }
    else { %TypeError("(defineOwnProperty) Attempt to add a property to a non-extensible object.") }
  }
        else { /* it definitely has the property */
    let(current-prop = {[#extensible: true,]
      configurable: {#value obj[fstr<#configurable>], #writable true},
      enumerable: {#value obj[fstr<#enumerable>], #writable true}
    }) {
    if (prim("isAccessor", obj, fstr)) {
      current-prop["get" = obj[fstr<#getter>]];
      current-prop["set" = obj[fstr<#setter>]]
    }
    else {
      current-prop["writable" = obj[fstr<#writable>]];
      current-prop["value" = obj[fstr<#value>]]
    };
          if (obj[fstr<#configurable>] == false) {
      if (attr-obj["configurable"] == true) {
                    %TypeError("escalating configurable from false to true")
      }
      else {
        if(attr-obj["enumerable"] == (obj[fstr<#enumerable>] == false)) {
          %TypeError("(defineOwnPoperty) Can't change enumerable of a non-configurable property")
        }
      };
      if ((isDataDescriptor(current-prop)) != (isDataDescriptor(attr-obj))) {
        if (obj[fstr<#configurable>] == false) {
          %TypeError("(defineOwnProperty) Non-configurable property")
        }
        else {
          if (isDataDescriptor(current-prop)) {
            copy-data-desc(current-prop, attr-obj)
          }
          else {
            copy-access-desc(current-prop, attr-obj)
          }
        }
      }
    };
                // current-prop is what?
                if ((isDataDescriptor(current-prop)) && 
                         (isDataDescriptor(attr-obj))) {
                    if (current-prop["configurable"] == false) {
                        if (current-prop["writable"] == false) {
                            if (attr-obj["writable"] == true) {
                                %TypeError("(defineOwnProperty) Cannot escalate writable from false to true.")
                            }
                            else {
                                    if (prim("sameValue", attr-obj["value"], current-prop["value"]) == false) {
                                    %TypeError("(defineOwnProperty) Cannot change a non-configurable value")
                                }
                                else { copy-data-desc(current-prop, attr-obj) }
                            }
                        }
                        else { copy-data-desc(current-prop, attr-obj) }
                    }
                    else { copy-data-desc(current-prop, attr-obj) }
                }
                else {
                    if (current-prop["configurable"] == false) {
                            if (prim("sameValue", current-prop["set"], attr-obj["set"]) == false ||
                                prim("sameValue", current-prop["get"], attr-obj["get"]) == false) {
      %TypeError(prim("string+", "(defineOwnProperty) Cannot change setter or getter of non-configurable property ", fstr))
                        }
                        else { copy-access-desc(current-prop, attr-obj) }
                    }
                    else { copy-access-desc(current-prop, attr-obj) }
                };

                if(isDataDescriptor(current-prop)) {
      if (prim("sameValue", obj[fstr<#value>], current-prop["value"]) == false) {
                    obj[fstr<#value> = current-prop["value"]]
      };
      if(obj[fstr<#writable>] != current-prop["writable"]) {
                  obj[fstr<#writable> = current-prop["writable"]]
      }
                }
                else if(isAccessorDescriptor(current-prop)) {
                    obj[fstr<#getter> = current-prop["get"]];
                    obj[fstr<#setter> = current-prop["set"]]
                }
                else { undefined };
                
    if(obj[fstr<#enumerable>] != current-prop["enumerable"]) {
                obj[fstr<#enumerable> = current-prop["enumerable"]]
    };
    if(obj[fstr<#configurable>] != current-prop["configurable"]) {
                obj[fstr<#configurable> = current-prop["configurable"]]
                };
                true
    }
        }
}

// Defines a property on an object from section 15.
// If given attributes, uses them, otherwise, uses the defaults
// as specified at the end of the intro to 15:
//    In every case, the length property of a built-in Function object
//    described in this clause has the attributes { [[Writable]]: false,
//    [[Enumerable]]: false, [[Configurable]]: false }. Every other property
//    described in this clause has the attributes { [[Writable]]: true,
//    [[Enumerable]]: false, [[Configurable]]: true } unless otherwise
//    specified.
let [%define15Property] = func(obj, field, prop) {
  let (%mkPropObj = func(value, writable, enumerable, configurable) {
    if (value != null) {
      {[] "value": {#value value, #writable true},
                "writable" : {#value writable, #writable true},
          "enumerable" : {#value enumerable, #writable true},
          "configurable" : {#value configurable, #writable true}}
    } else {
      {[] "writable" : {#value writable, #writable true},
          "enumerable" : {#value enumerable, #writable true},
          "configurable" : {#value configurable, #writable true}}
    }
  })
  if (%Typeof(obj) == "function" && field == "length") {
    %defineOwnProperty(obj, field, %mkPropObj(prop, false, false, false))
  }
  else {
    %defineOwnProperty(obj, field, %mkPropObj(prop, true, false, true))
  }
}

// TODO still needs to be changed: HasProperty instead of checking for undefined
let [%ToPropertyDescriptor] = func(propobj) {
    %ObjectTypeCheck(propobj);
    let (attrobj = {[#extensible: true,]}) {
        let (enumerable = %GetField(propobj, "enumerable")) {
            if ((typeof enumerable) != "undefined") {
                attrobj["enumerable" = %ToBoolean(enumerable)]
            }
        };
            
        let (configurable = %GetField(propobj, "configurable")) {
            if ((typeof configurable) != "undefined") {
                attrobj["configurable" = %ToBoolean(configurable)]
            }
        };
        
        let (writable = %GetField(propobj, "writable")) {
            if ((typeof writable) != "undefined") {
                attrobj["writable" = %ToBoolean(writable)]
            }
        };
            
        let (value = %GetField(propobj, "value")) {
            if ((typeof value) != "undefined") {
                attrobj["value" = value]
            }
        };
        
        let (get = %GetField(propobj, "get")) {
            if ((typeof get) != "undefined" && 
                (%Typeof(get) != "function")) {
                %TypeError("defineProperty given a non-function getter")
            }
            else {
                attrobj["get" = get]
            }
        };
        
        let (set = %GetField(propobj, "set")) {
            if (typeof set != "undefined" && 
                (%Typeof(set) != "function")) {
                %TypeError("defineProperty given a non-function setter")
            }
            else {
                attrobj["set" = set]
            }
        };

        // 8.10.5, step 9
        if ((isDataDescriptor(attrobj)) && 
            (isAccessorDescriptor(attrobj))) {
                        %TypeError("The attributes given to defineProperty were inconsistent")
        };
        
        attrobj
    }
}

let [%definePropertyCall] = func(this, args) {
    let (obj = args["0"])
    let (field = args["1"])
    let (propobj = args["2"]) {
        %ObjectTypeCheck(obj);
        %defineOwnProperty(obj, %ToString(field), %ToPropertyDescriptor(propobj))
    }
}

let [%defineProperty] = { [#code : %definePropertyCall, #proto: %FunctionProto, #class: "Function"] }

let [%oneArgObj] = func(arg) {
  %mkArgsObj({[] "0": {#value arg, #writable false}})
}

let [%twoArgObj] = func(arg1, arg2) {
  %mkArgsObj({[] "0": {#value arg1, #writable false},
                 "1": {#value arg2, #writable false}})
}

let [%callCall] = func(this, args) {
  let (callArgs = %slice_internal(args, 1, %len(args))) {
    this(args["0"], callArgs)
  }
}

// http://es5.github.com/#x15.3.4.3
// 15.3.4.3 Function.prototype.apply (thisArg, argArray)
let [%applyCall] = func(this, args) {
  let (applyArgs1 = args["1"]) 
  let (applyArgs =
    if ((prim("typeof", applyArgs1) == 'undefined') || 
        applyArgs1 == null) {
      {[]}
    } else { applyArgs1 }) {
    %ObjectTypeCheck(applyArgs);
    this(args["0"], %mkArgsObj(applyArgs))
  }
}


let [%call] = { [#code : %callCall, #proto : %FunctionProto, #class: "Function"] }
let [%apply] = { [#code : %applyCall, #proto : %FunctionProto, #class: "Function"] }

{%defineOwnProperty(%FunctionProto,
  "call",
  {[] "value" : {#value %call, #writable true},
      "configurable": {#value true, #writable true},
      "writable": {#value true, #writable true}}) }

{%defineOwnProperty(%FunctionProto,
  "apply",
  {[] "value" : {#value %apply, #writable true},
      "configurable": {#value true, #writable true},
      "writable": {#value true, #writable true}}) }

let [%UnwritableDispatch] = func(id) {
  func(e) {
    if(e == 'unwritable-field') {
      %TypeError(prim("string+", id, " not writable"))
    }
    else { %ErrorDispatch(e) }
  }
}

let [%primEach] = func(arr, fn) {
  rec (loop = func(i) {
    let (istr = %ToString(i))
    if(prim("hasOwnProperty", arr, istr)) {
      fn(arr[istr]);
      loop(prim("+", i , 1))
    } else {
      undefined
    }
  })
  loop(0)
}

// TODO: implement ForIn right
//let [%PropItr] = func(obj) {
//  let (index = 0)
//  func() { 
//    if (prim("hasOwnProperty", obj, prim("prim->str", index))) {
//      let (rval = obj[prim("prim->str", index)]) {
//        index := prim("+", index, 1);
//        rval
//      }
//    } else {
//      undefined
//    }
//  }
//}

let [%isNaNCall] = func(obj, this, args) {
    %ToNumber(args["0"]) === NaN
}

let [%isNaN] = { [#code : %isNaNCall, #proto : %FunctionProto, #class: "Function"] }

let [%etsCall] = func(obj, this, args) {
  if (!object? this) {
    %TypeError("This not object in Error.prototype.toString")
  } else {
    let (name = if (this["name"] == undefined) { "Error" } else {
      %ToString(this["name"]) })
    let (msg = if (this["message"] == undefined) { "" } else {
      %ToString(this["message"]) })
    let (c1 = name == "")
    let (c2 = msg == "")
      label ret: {
          if (c1 && c2) {
              break ret "Error"
          } else { null };
          if (c1) {
              break ret msg
          } else { null };
          if (c2) {
              break ret name
          } else { null };
          
          let (prefix = prim("string+", name, ": "))
          break ret prim("string+", prefix, msg)
      }
  }
}

let [%ets] = {[#code : %etsCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%ErrorProto,
  "toString",
  {[] "value" : {#value %ets, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%NumberCall] = func(obj, this, args) {
  if (%ComputeLength(args) == 0) { 0 } else { %ToNumber(args["0"]) }
}

let [%NumberConstructor] = func(constr, args) {
  %MakeNumber(if (%ComputeLength(args) == 0) { 0 } else { %ToNumber(args["0"]) })
}

let [%NumberGlobalFuncObj] = 
  { [#code : %NumberCall, #proto : %FunctionProto, #class: "Function", construct: %NumberConstructor]
    "prototype" : {#value %NumberProto, #writable false},
    "MAX_VALUE" : {#value 1.79769313486231571e+308, #writable false},
    "MIN_VALUE" : {#value 5.0e-324, #writable false},
    "NaN" : {#value NaN, #writable false},
    "NEGATIVE_INFINITY" : {#value -inf, #writable false},
    "POSITIVE_INFINITY" : {#value +inf, #writable false},
    "length" : {#value 1, #writable false}}

{%NumberProto["constructor" = %NumberGlobalFuncObj]}

let [%stringToStringCall] = func(obj, this, args) {
  let (t = typeof this)
  if (t == "string") { this } 
  else if (t == "object") {
    if (this[<#class>] == "String") { this[<primval>] } 
    else { %TypeError("String.prototype.toString got a non-string object") }
  } else { %TypeError("String.prototype.toString got a non-string value") }
}

let [%stringToString] = 
  { [#code : %stringToStringCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false} }

{%defineOwnProperty(%StringProto,
  "toString",
  {[] "value" : {#value %stringToString, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%StringCall] = func(obj, this, args) {
  let (argCount = %ComputeLength(args))
  if (argCount == 0) { "" } else { %ToString(args["0"]) }
}

let [%StringConstructor] = func(constr, args) {
  %MakeString(%StringCall(undefined, undefined, args))
}

let [%StringGlobalFuncObj] = 
  { [#code : %StringCall, #proto : %FunctionProto, #class: "Function", construct: %StringConstructor]
    "length" : {#value 1, #writable false} }

let [%BooleanCall] = func(obj, this, args) {
  %ToBoolean(args["0"])
}

let [%BooleanConstructor] = func(constr, args) {
  %MakeBoolean(%ToBoolean(args["0"]))
}

let [%booleanToStringCall] = func(obj, this, args) {
  let (t = prim("typeof", this))
  let (b = if (t == "boolean") { this } else {
    if (t == "object") {
      if (this[<#class>] == "Boolean") {
        this[<primval>]
      } else { %TypeError("Boolean.prototype.toString got non-boolean object")}
    } else { %TypeError(prim("string+", "Boolean.prototype.toString got ", t)) }
  })
  if (b) { "true" } else { "false" }
}

let [%booleanToString] = 
  { [#code : %booleanToStringCall, #proto: %FunctionProto, #class: "Function",] }

{%define15Property(%booleanToString, "length", 0)}

{%define15Property(%BooleanProto, "toString", %booleanToString)}

let [%BooleanGlobalFuncObj] = { [#code : %BooleanCall, #proto : %FunctionProto, #class: "Function", construct: %BooleanConstructor] } 

{
        %BooleanProto["constructor" = %BooleanGlobalFuncObj];
        %BooleanGlobalFuncObj["length" = 1]
}

{%defineOwnProperty(%BooleanGlobalFuncObj,
  "prototype",
  {[] "value" : {#value %BooleanProto, #writable true},
      "configurable" : {#value false, #writable true}}) }

{%StringProto["constructor" = %StringGlobalFuncObj];
 %StringGlobalFuncObj["prototype" = %StringProto];
 %StringGlobalFuncObj["prototype"<#enumerable> = false];
 %StringGlobalFuncObj["prototype"<#writable> = false];
 %StringGlobalFuncObj["prototype"<#configurable> = false] }

let [%MakeObject] = func() {
  {[#proto: %ObjectProto]}
}

let [%ObjectCall] = func(obj, this, args) {
  if (%ComputeLength(args) == 0 || args["0"] == null || args["0"] == undefined)
  { %MakeObject() } else { %ToObject(args["0"]) }
}

let [%ObjectConstructor] = func(constr, args) {
  %ObjectCall(constr, undefined, args)
}

 let [%ObjectGlobalFuncObj] = 
  { [#code : %ObjectCall, #proto : %FunctionProto, #class: "Function", construct: %ObjectConstructor] 
    "prototype" : {#value %ObjectProto, #writable false},
    "length" : {#value 1, #writable false},
  } {
          %ObjectProto["constructor" = %ObjectGlobalFuncObj];
          %ObjectProto["constructor"<#enumerable> = false]
  }

let [%gpoCall] = func(obj, this, args) {
  let (O = args["0"]) {
     %ObjectTypeCheck(O);
     O[<#proto>]
  }
}

let [%gpo] = {[#code : %gpoCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "getPrototypeOf",
  {[] "value" : {#value %gpo, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%gopdCall] = func(obj, this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);
      let (name = %ToString(args["1"]))

      label ret: {
          if (prim("!", prim("hasOwnProperty", O, name))) {
              break ret undefined
          } else { null };
          
          let (obj = {[#proto : %ObjectProto,]}) {
              %defineOwnProperty(obj,
                                 "enumerable",
                                 {[] "value" : {#value O[name<#enumerable>], #writable true},
                                  "writable" : {#value true, #writable true},
                                  "enumerable" : {#value true, #writable true},
                                  "configurable" : {#value true, #writable true}});
              %defineOwnProperty(obj,
                                 "configurable",
                                 {[] "value" : {#value O[name<#configurable>], #writable true},
                                  "writable" : {#value true, #writable true},
                                  "enumerable" : {#value true, #writable true},
                                  "configurable" : {#value true, #writable true}});
          
              if (prim("!", prim("isAccessor", O, name))) {
                      %defineOwnProperty(obj,
                                         "value",
                                         {[] "value" : {#value O[name], #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}});
                      %defineOwnProperty(obj,
                                         "writable",
                                         {[] "value" : {#value O[name<#writable>], #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}});
                  break ret obj
              } else {
                      %defineOwnProperty(obj,
                                         "get",
                                         {[] "value" : {#value O[name<#getter>], #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}});
                      %defineOwnProperty(obj,
                                         "set",
                                         {[] "value" : {#value O[name<#setter>], #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}});
                  break ret obj
              }
          }
      }
  }
}

let [%gopd] = {[#code : %gopdCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "getOwnPropertyDescriptor",
  {[] "value" : {#value %gopd, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%objectToStringCall] = func(obj, this, args) {
    label ret: {
        if (this == undefined) {
            break ret "[object Undefined]"
        } else { undefined };
        
        if (this == null) {
            break ret "[object Null]"
        } else { undefined };
        
        let (O = %ToObject(this))
        let (class = O[<#class>])
        break ret prim("string+", "[object ", prim("string+", class, "]"))
    }
}

let [%objectToString] = 
  { [#code : %objectToStringCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false} }

let [%propEnumCall] = func(obj, this, args) {
  let (getOwnProperty = func(o, f) {
    if (prim("hasOwnProperty", o, f)) { o[f] } else { undefined }})
  if (args["0"] == undefined) { false } else {
  let (P = %ToString(args["0"]))
  let (O = %ToObject(this))
  let (desc = getOwnProperty(O, P))
  if (desc == undefined) {
    false
  } else { 
    O[P<#enumerable>] 
  }}
}

let [%propertyIsEnumerable] = 
  {[#code : %propEnumCall, #proto : %FunctionProto, #class: "Function"]
    "length" : {#value 1, #writable false} }

let [%toLocaleStringCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (toString = O["toString"])
  if (toString[<#code>] == null) {
    %TypeError("toLocaleString")
  } else {
    toString(O, {[]})
  }
}

let [%toLocaleString] = 
  { [#code : %toLocaleStringCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false} }

let [%valueOfCall] = func(obj, this, args) {
  %ToObject(this)
}

let [%valueOf] = 
  { [#code : %valueOfCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false}
  }


let [%hasOwnPropertyCall] = func(obj, this, args) {
   prim("hasOwnProperty", %ToObject(this), %ToString(args["0"]))
}

let [%hasOwnProperty] = 
  { [#code : %hasOwnPropertyCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 1, #writable false}
  }


let [%isPrototypeOfCall] = func(obj, this, args) {
    rec (searchChain = func(o, v) {
      let (vproto = v[<#proto>])
      if (vproto == null) {
        false
      } else {
        if (o == vproto) {
          true
        } else {
          searchChain(o, vproto) 
        }
      }
    })
    if (!object? (args["0"])) {
      false
    } else {
      let (O = %ToObject(this))
      searchChain(O, args["0"])
    }
}

let [%isPrototypeOf] = 
  { [#code : %isPrototypeOfCall, #proto : %FunctionProto, #class: "Function"]
    "length" : {#value 1, #writable false}
  } { 
  %ObjectProto["toString" = %objectToString];
  %ObjectProto["toString"<#writable> = true];
  %ObjectProto["toString"<#enumerable> = false];

  %ObjectProto["toLocaleString" = %toLocaleString];
  %ObjectProto["toLocaleString"<#writable> = false];
  %ObjectProto["toLocaleString"<#enumerable> = false];

  %ObjectProto["valueOf" = %valueOf];
  %ObjectProto["valueOf"<#writable> = true];
  %ObjectProto["valueOf"<#enumerable> = false];

  %ObjectProto["hasOwnProperty" = %hasOwnProperty];
  %ObjectProto["hasOwnProperty"<#writable> = false];
  %ObjectProto["hasOwnProperty"<#enumerable> = false];

  %ObjectProto["isPrototypeOf" = %isPrototypeOf];
  %ObjectProto["isPrototypeOf"<#writable> = false];
  %ObjectProto["isPrototypeOf"<#enumerable> = false]
}

let [%RunSelfConstructorCall] = func(obj, this, args) {
  obj[<construct>](this, args)
}

let [%NativeErrorConstructor] = func(proto) {
  func(this, args) {
    let (msg = if (prim("hasOwnProperty", args, "0")) { %ToString(args["0"]) } else { undefined })
    %MakeNativeError(proto, msg)
  }
}

let [%ErrorConstructor] = %NativeErrorConstructor(%ErrorProto)

let [%ErrorGlobalFuncObj] = 
  {[#code : %RunSelfConstructorCall, #proto : %FunctionProto, #class: "Function", construct: %ErrorConstructor]
   "prototype" : {#value %ErrorProto, #writable false}}

{%ErrorProto["constructor" = %ErrorGlobalFuncObj]}

let [%SyntaxErrorConstructor] = %NativeErrorConstructor(%SyntaxErrorProto)

let [%SyntaxErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %SyntaxErrorProto, #class: "Function", construct: %SyntaxErrorConstructor] 
    "prototype" : {#value %SyntaxErrorProto, #writable false} }

{%SyntaxErrorProto["constructor" = %SyntaxErrorGlobalFuncObj]}

let [%EvalErrorConstructor] = %NativeErrorConstructor(%EvalErrorProto)

let [%EvalErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %FunctionProto, #class: "Function", construct: %EvalErrorConstructor]
    "prototype" : {#value %EvalErrorProto, #writable false} }

{%EvalErrorProto["constructor" = %EvalErrorGlobalFuncObj]}

let [%RangeErrorConstructor] = %NativeErrorConstructor(%RangeErrorProto)

let [%RangeErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %RangeErrorProto, #class: "Function", construct: %RangeErrorConstructor] 
    "prototype" : {#value %RangeErrorProto, #writable false} }

{%RangeErrorProto["constructor" = %RangeErrorGlobalFuncObj]}

let [%ReferenceErrorConstructor] = %NativeErrorConstructor(%ReferenceErrorProto)

let [%ReferenceErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %ReferenceErrorProto, #class: "Function", construct: %ReferenceErrorConstructor] 
    "prototype" : {#value %ReferenceErrorProto, #writable false} }

{%ReferenceErrorProto["constructor" = %ReferenceErrorGlobalFuncObj]}

let [%TypeErrorConstructor] = %NativeErrorConstructor(%TypeErrorProto)

let [%TypeErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %TypeErrorProto, #class: "Function", construct: %TypeErrorConstructor] 
    "prototype" : {#value %TypeErrorProto, #writable false} }

{%TypeErrorProto["constructor" = %TypeErrorGlobalFuncObj]}

{(/*:START SYM EVAL*/0)}

let [%URIErrorProto] = 
  { [#proto : %ErrorProto,]
    "name" : {#value "URIError", #writable false}}

{(/*:STOP SYM EVAL*/0)}

let [%URIErrorConstructor] = %NativeErrorConstructor(%URIErrorProto)

let [%URIErrorGlobalFuncObj] = 
  { [#code : %URIErrorConstructor, #proto : %FunctionProto, #class: "Function", construct: %URIErrorConstructor]
    "prototype" : {#value %URIErrorProto, #writable false} }

{%URIErrorProto["constructor" = %URIErrorGlobalFuncObj]}

{(/*:START SYM EVAL*/0)}

let [%ArrayProto] = { [#proto : %ObjectProto, #class : "Array",]
  "length" : {#value 0, #writable true} }

{(/*:STOP SYM EVAL*/0)}

let [%MakeArray] = func(len) {
  {[#proto: %ArrayProto, #class: "Array",] "length": {#value len, #writable true}}
}

let [%gopnCall] = func(obj, this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);
      let (props = get-own-field-names(O))
      let (len = props["length"])
      let (A = %MakeArray(len))
      rec (loop = func(i) {
          if (prim("<", i, len)) {
              let (to = prim("prim->str", i))
              let (from = prim("prim->str", prim("-", len, prim("+", i, 1))))
              A[to<#value> = props[from]];
              loop(prim("+", i, 1))
          } 
      }) {
          loop(0);
          A
      }
  }
}

let [%gopn] = {[#code : %gopnCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "getOwnPropertyNames", %gopn)}

{%define15Property(%ObjectGlobalFuncObj, "defineProperty", %defineProperty)}

let [%definePropertiesCall] = func(obj, this, args) {
  let (O = args["0"]) {
          %ObjectTypeCheck(O);
      let (props = %ToObject(args["1"]))
      let (names = get-own-field-names(props))
      let (len = names["length"])
      rec (loop = func(i) {
          label ret: {
              if (prim("<", i, len)) {
                  let (indx = prim("prim->str", i))
                  let (name = names[indx])
                  if (props[name<#enumerable>]) {
                      let (argsObj = {[]}) {
                          argsObj["0" = O];
                          argsObj["1" = name];
                          argsObj["2" = props[name] ];
                          argsObj["length" = 3];
                              %defineProperty(null, argsObj);
                          break ret loop(prim("+", i, 1))
                      }
                  } else {
                      break ret loop(prim("+", i, 1))
                  }
              } else { break ret undefined }
          }})
      loop(0);
      O
  }
}

let [%defineProperties] = 
  {[#code : %definePropertiesCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "defineProperties",
  {[] "value" : {#value %defineProperties, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%createCall] = func(obj, this, args) {
  let (O = args["0"])
  let (t = prim("typeof", O))
  if (t != "object" && t != "null") {
    %TypeError("Object.create failed")
  } else {
        let (obj = {[#proto : O,]}) {
            if (prim(">=", args["length"], 2) && args["1"] != undefined) {
                let (Properties = %ToObject(args["1"]))
                let (argsObj = {[]}) {
                    argsObj["0" = obj];
                    argsObj["1" = Properties];
                    argsObj["length" = 2];
                    %defineProperties(null, argsObj);
                    obj
                }
            } else {
                obj
            }
        }
  }
}

let [%create] = {[#code : %createCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "create",
  {[] "value" : {#value %create, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%sealCall] = func(obj, this, args) {
    let (O = args["0"]) {
            %ObjectTypeCheck(O);
        
        let (names = get-own-field-names(O))
        let (len = names["length"])
        rec (loop = func(i) {
            if (prim("<", i, len)) {
                let (name = names[prim("prim->str", i)])
                O[name<#configurable> = false];
                loop(prim("+", i, 1))
            } else { null }
        })
        loop(0);
        O[<#extensible>=false];
        O
    }
}

let [%seal] = {[#code : %sealCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "seal", %seal)}

let [%freezeCall] = func(obj, this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);

      let (names = get-own-field-names(O))
      let (len = names["length"])
      rec (loop = func(i) {
          if (prim("<", i, len)) {
              let (name = names[prim("prim->str", i)]) {
                  if (prim("!", prim("isAccessor", O, name))) {
                      if (O[name<#writable>]) {
                          O[name<#writable> = false]
                      }
                  };
                  
                  O[name<#configurable> = false];
                  loop(prim("+", i, 1))
              }
          } else { null }
      }) {
          loop(0);
          O[<#extensible> = false];
          O
      }
  }
}

let [%freeze] = {[#code : %freezeCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "freeze", %freeze)}

let [%preventExtensionsCall] = func(obj, this, args) {
    let (O = args["0"]) {
            %ObjectTypeCheck(O);
        O[<#extensible> = false];
        O
    }
}

let [%preventExtensions] = 
  {[#code : %preventExtensionsCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "preventExtensions", %preventExtensions)}

let [%isFrozenCall] = func(obj, this, args) {
    let (O = args["0"]) {
            %ObjectTypeCheck(O);
        let (names = get-own-field-names(O))
        let (len = names["length"])
        rec (loop = func(i) {
            label ret: {
                if (prim("<", i, len)) {
                    let (name = names[prim("prim->str", i)])
                    let (isData = prim("!", prim("isAccessor", O, name))) {
                    
                    if (isData && O[name<#writable>]) {
                        break ret false
                    } else { null };
                    
                    if (O[name<#configurable>]) {
                        break ret false
                    } else { null };
                    
                    break ret loop(prim("+", i, 1))
      }
                } else { break ret prim("!", O[<#extensible>]) }
            }})
        loop(0)
    }
}

let [%isFrozen] = {[#code : %isFrozenCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "isFrozen", %isFrozen)}

let [%isSealedCall] = func(obj, this, args) {
    let (O = args["0"]) {
            %ObjectTypeCheck(O);
        let (names = get-own-field-names(O))
        let (len = names["length"])
        rec (loop = func(i) {
            label ret: {
                if (prim("<", i, len)) {
                    let (name = names[prim("prim->str", i)])
                    if (O[name<#configurable>]) {
                        break ret false
                    } else { null };
                    break ret loop(prim("+", i, 1))
                } else { break ret prim("!", O[<#extensible>]) }
            }})
        loop(0)
    }
}

let [%isSealed] = {[#code : %isSealedCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "isSealed", %isSealed)}

let [%isExtensibleCall] = func(obj, this, args) {
    let (O = args["0"]) {
            %ObjectTypeCheck(O);
        O[<#extensible>]
    }
}

let [%isExtensible] = {[#code : %isExtensibleCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "isExtensible", %isExtensible)}

let [%propertyNames] = func(obj, get-non-enumerable) {
  let (aux = {[#extensible : true,]})
  rec (helper = func(obj) {
    if (obj == null) {
      undefined
    } else {
      let (cur = get-own-field-names(obj))
      let (length = cur["length"])
      rec (loop = func(i) {
        if (prim("<", i, length)) { 
          let (istr = prim("prim->str",i)) {
            if (obj[cur[istr]<#enumerable>] || get-non-enumerable) {
              aux[cur[istr] = true]
            } else {undefined };
            loop(prim("+",i,1)) 
          }
        }
        else { undefined }
      })
      loop(0);
      helper(obj[<#proto>])
    }
  }) {
    helper(obj);
    get-own-field-names(aux)
  }
}

let [%keysCall] = func(obj, this, args) {
    let (O = args["0"]) {
            %ObjectTypeCheck(O);

        let (names = get-own-field-names(O))
        let (len = names["length"])
        let (A = %MakeArray(0))
        
        rec (loop = func(i, enumCount) {
            if (prim("<", i, len)) {
                let (indx = prim("prim->str", i))
                let (name = names[indx])
                if (O[name<#enumerable>]) {
                    let (pd = {[] "value" : {#value name, #writable true},
                               "writable" : {#value true, #writable true},
                               "enumerable" : {#value true, #writable true},
                               "configurable" : {#value true, #writable true}})
                        %defineOwnProperty(A, prim("prim->str", enumCount), pd);
                    loop(prim("+", i, 1), prim("+", enumCount, 1))
                } else {
                    loop(prim("+", i, 1), enumCount)  
                }
            } else { A["length" = enumCount] }
        }) {
            loop(0, 0);
            A
        }
    }
}

let [%keys] = {[#code : %keysCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "keys",
  {[] "value" : {#value %keys, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%ToUint] = func(n, limit) {
  let (number = %ToNumber(n))
  if (number != number || number == 0 || number == +inf || number == -inf) { 
    0 
  } else {
    let (sign = prim("sign", number))
    let (posInt = prim("*", sign, prim("floor", prim("abs", number))))
    if (prim("<", sign, 0)) {
      let (close = prim("%", posInt, limit))
      prim("+", close, limit)
    } else { 
      prim("%", posInt, limit)
    }
  }
}

let [%ToUint32] = func(n) {
  %ToUint(n, 4294967296.0)
}

let [%ToInt32] = func(n) {
  let (int32bit = %ToUint32(n))
  if (prim(">=", int32bit, 2147483648.0)) {
    prim("-", int32bit, 4294967296.0)
  } else {
    int32bit
  }
}

let [%ToUint16] = func(n) {
  %ToUint(n, 65536.0)
}

let [%fromccCall] = func(obj, this, args) {
  if (args["length"] == 0) {
    ""
  } else {
    let (end = args["length"])
    rec (loop = func(i, soFar) {
      if (prim("<", i, end)) {
        let (char = prim("ascii_ntoc", %ToUint16(args[prim("prim->str", i)])))
        let (next = prim("string+", soFar, char))
        loop(prim("+", i, 1), next)
      } else { soFar }
    })
    loop(0, "")
  }
}

let [%fromCharCode] = 
  {[#code : %fromccCall, #proto : %FunctionProto, #class: "Function"]
    "length" : {#value 1, #writable false}}

{%defineOwnProperty(%StringGlobalFuncObj,
  "fromCharCode",
  {[] "value" : {#value %fromCharCode, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

let [%joinCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (sep = if (args["0"] == undefined) { "," } 
    else { %ToString(args["0"]) })
    label ret: {
        if (len == 0) {
            break ret ""
        } else { null };
        rec (loop = func(k, R) {
            if (prim(">=", k, len)) {
                R
            } else {
                let (S = prim("string+", R, sep))
                let (element = O[%ToString(k)])
                let (next =
                     if (element == null || element == undefined) { "" }
                     else { %ToString(element) })
                loop(prim("+", k, 1), prim("string+", S, next)) 
            }
        })
        let (start = if (O["0"] == undefined || O["0"] == null) { "" }
             else { %ToString(O["0"]) })
        break ret loop(1, start)
    }
}

let [%join] = { [#code : %joinCall, #proto : %FunctionProto, #class: "Function"] }

{%defineOwnProperty(%join, 
    "length", 
    {[] "value" : {#value 1, #writable true}, 
        "configurable" : {#value false, #writable true},
        "enumerable" : {#value false, #writable true}})}

let [%popCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len == 0) {
    O["length" = 0];
    undefined
  } else {
    let (indx = %ToString(prim("-", len, 1)))
      let (element = O[indx]) {
          O[delete indx];
          O["length" = %ToNumber(indx)];
          element
      }
  }
}

let [%pop] = { [#code : %popCall, #proto : %FunctionProto, #class: "Function"] }

{%defineOwnProperty(%pop,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}})}

{%defineOwnProperty(%ArrayProto,
  "pop",
  {[] "value" : {#value %pop, #writable true},
      "configurable" : {#value true, #writable true}})}

let [%ArrayLengthChange] = func(arr, newlen) {
  let (oldlen = %ToUint32(arr["length"]))
  rec (fix = func(i) {
    if (prim("<", i, oldlen)) {
      arr[delete prim("prim->str", i)];
      fix(prim("+", i, 1))
    }
  })
  fix(newlen)
}

// 15.4: A property name P (in the form of a String value) is an array index if and
// only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to
// 2^32-1
let [%set-property] = func(obj, fld, val) {
  let (obj = %ToObject(obj))
  let (fld = %ToString(fld))

  let (check = func(flag) {
    if (flag) {
      %TypeError("set-property failed")
    } else { null }
  })

  let (e = prim("!", obj[<#extensible>])) {
  check(e);

  let (isArrayIndex = func() {
    let (uint = %ToUint32(fld))
      if (%ToString(uint) == fld) {
        uint != 4294967295.0
      }
      else {
        false
      }
  })
  let (setArrayField = func() {
    let (lenCheck = func() {
      if (fld == "length") {
        let (newLen = %ToUint32(val))
        let (toCompare = %ToNumber(val))
        if (newLen != toCompare) {
          throw %JSError({[#proto : %RangeErrorProto,]})
        } else {
          if (prim("<", newLen, obj["length"])) {
            %ArrayLengthChange(obj, newLen)
          } else { undefined }
        }
      } else { undefined }
    }) {
    lenCheck();

    obj[fld = if (fld == "length") { %ToUint32(val) } else { val }];

    if (isArrayIndex()) {
      let (uint = %ToUint32(fld))
      let (len = obj["length"])
      if (prim("<", len, prim("+", uint, 1))) {
        obj["length" = prim("+", uint, 1)]
      } else { undefined }
    }
    else { undefined }
    }})
  if (obj[<#class>] == "Array") {
    setArrayField()
  }
  else {
    obj[fld = val]
  }
  }
}

let [%pushCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  rec (loop = func(i, n) {
    if (prim("<", i, args["length"])) {
      let (ii = prim("prim->str", i))
      %set-property(O, %ToString(n), args[ii]);
      //O[%ToString(n) = args[ii] ];
      loop(prim("+", i, 1), prim("+", n, 1))
    } else { n }
  })
  loop(0, len)
}

let [%push] = {[#code : %pushCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%push,
  "length",
  {[] "value" : {#value 1, #writable true},
      "configurable" : {#value false, #writable true}})}

{%defineOwnProperty(%ArrayProto,
  "push",
  {[] "value" : {#value %push, #writable true},
      "configurable" : {#value true, #writable true}})}

let [%reverseCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (middle = prim("floor", prim("/", len, 2)))
  rec (loop = func(lower) {
    if (lower != middle) {
        label ret: {        
          let (upper = prim("-", prim("-", len, lower), 1))
          let (upperP = %ToString(upper))
          let (lowerP = %ToString(lower))
          let (lowerValue = O[lowerP])
          let (upperValue = O[upperP])
          let (lowerExists = prim("hasProperty", O, lowerP))
          let (upperExists = prim("hasProperty", O, upperP)) {
            
            if (lowerExists && upperExists) {
                O[lowerP = upperValue];
                O[upperP = lowerValue];
                break ret loop(prim("+", lower, 1))
            } else { null };
            
            if (upperExists) {
                O[lowerP = upperValue];
                O[delete upperP];
                break ret loop(prim("+", lower, 1))
            } else { null };
            
            if (lowerExists) {
                O[delete lowerP];
                O[upperP = lowerValue];
                break ret loop(prim("+", lower, 1))
            } else { null };
            
            break ret loop(prim("+", lower, 1))
        }
      }
    }
  }) {
      loop(0);
      O
  }
}

let [%reverse] = {[#code : %reverseCall, #proto : %FunctionProto, #class: "Function"]}

{ %defineOwnProperty(%reverse,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
  "reverse",
  {[] "value" : {#value %reverse, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%shiftCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len == 0) {
    O["length" = 0];
    undefined
  } else { 
    let (first = O["0"]) {
    rec (loop = func(k) {
        label ret: {
            if (prim(">=", k, len)) {
                break ret undefined
            } else { null };
            
            let (from = %ToString(k))
            let (to = %ToString(prim("-", k, 1)))
            let (fromPresent = prim("hasProperty", O, from))
            if (fromPresent) {
                let (fromVal = O[from])
                O[to = fromVal];
                break ret loop(prim("+", k, 1))
            } else {
                O[delete to];
                break ret loop(prim("+", k, 1))
            }
        }})
    loop(1);
    let (newLen = prim("-", len, 1)) {
      O[delete %ToString(newLen)];
      O["length" = newLen];
      first
    }
  }
  }
}

let [%shift] = {[#code : %shiftCall, #proto : %FunctionProto, #class: "Function"]}

{ %defineOwnProperty(%shift,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
  "shift",
  {[] "value" : {#value %shift, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%arrayToStringCall] = func(obj, this, args) {
  let (array = %ToObject(this))
  let (thefunc = array["join"])
  let (ffunc = 
  if (!object? thefunc) {
    %objectToStringCall
  } else {
    if (thefunc[<#code>] == null) {
      %objectToStringCall
    } else { thefunc }
  })
  ffunc(array, {[]})
}

let [%arrayToString] = 
  { [#code : %arrayToStringCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false} }

{ %defineOwnProperty(%ArrayProto, 
    "toString", 
    {[] "value" : {#value %arrayToString, #writable true}, 
        "writable" : {#value true, #writable true},
        "configurable" : {#value true, #writable true}});
  %defineOwnProperty(%ArrayProto,
    "join",
    {[] "value" : {#value %join, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [%arrayTLSCall] = func(obj, this, args) {
  let (isCallable = func(o) {
      label ret: {
          if (!object? o) {
              break ret false 
          } else { null };
          if (o[<#code>] == null) {
              break ret false
          } else { null };
          break ret true
      }})
  let (array = %ToObject(this))
  let (arrayLen = array["length"])
  let (len = %ToUint32(arrayLen))
  let (separator = " ")
    label ret: {
        if (len == 0) {
            break ret ""
        } else { null };
        let (firstElement = array["0"])
        let (R = if (firstElement == null || firstElement == undefined) { "" } else {
            let (elementObj = %ToObject(firstElement))
            let (funcc = elementObj["toLocaleString"]) { 
              if (prim("!", isCallable(funcc))) {
                %TypeError("Not callable in ArrayTLS")
            }
            else { null };
            funcc(elementObj, {[]}) }})
        rec (inner = func(k, r) {
            if (prim(">=", k, len)) {
                r
            } else {
                let (S = prim("string+", prim("prim->str", r), separator))
                let (nextElement = array[prim("prim->str", k)])
                let (toAppend = if (nextElement == null ||
                                    nextElement == undefined) { "" } else {
                                        let (elementObj = %ToObject(nextElement))
                                        let (funcc = elementObj["toLocaleString"]) {
                                            if (prim("!", isCallable(funcc))) {
                                                throw %JSError({[#proto : %TypeErrorProto,]})
                                            } else { null };
                                            funcc(elementObj, {[]}) }})
                inner(prim("+", k, 1), 
                      prim("string+", prim("prim->str", r),
                           prim("prim->str", toAppend)))
            }
        })
        break ret inner(1, R)
    }
}

let [%arrayToLocaleString] = 
  { [#code : %arrayTLSCall, #proto : %FunctionProto, #class: "Function"]
    "length" : {#value 0, #writable false} }

{ %defineOwnProperty(%ArrayProto, 
    "toLocaleString", 
    {[] "value" : {#value %arrayToLocaleString, #writable true}, 
        "configurable" : {#value true, #writable true}}) }

let [%ArrayConstructor] = func(this, args) {
  let (argCount = %ComputeLength(args))
    label ret: {
        if (prim(">=", argCount, 2)) {
            let (rtnobj = %MakeArray(0))
            rec (init = func(n) {
                rtnobj[ prim("prim->str", n) = args[prim("prim->str", n)] ];
                if (prim(">", n, 0)) {
                    init(prim("-", n, 1))
                }
            }) {
                init(argCount);
                rtnobj["length" = argCount ];
                break ret rtnobj
            }
        } else { null };
        let (c1 = prim("typeof", args["0"]) == "number")
        let (c2 = if (c1) { %ToUint32(args["0"]) != args["0"] } else { false })
        if (c2) {
            throw %JSError({[#proto : %RangeErrorProto,]})
        } else {
            if (c1) {
                break ret %MakeArray(%ToUint32(args["0"]))
            } else {
                let (rtn = %MakeArray(argCount)) {
                    %defineOwnProperty(rtn,
                                       "0",
                                       {[] "value" : {#value args["0"], #writable true},
                                        "writable" : {#value true, #writable true},
                                        "enumerable" : {#value true, #writable true},
                                        "configurable" : {#value true, #writable true}});
                    break ret rtn
                }
            }
        }
    }
}

let [%concatCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = %ArrayConstructor(emptyobj, emptyobj))
  rec (procElt = func(obj, elt, n) {
    let (procNormalElt = func(nelt, k) {
      obj[prim("prim->str", k) = nelt];
      prim("+", k, 1)
    })
    rec (procArrayElt = func(arr, fromIndex, toIndex) {
      if (arr[prim("prim->str", fromIndex)] == undefined) {
        toIndex
      } else {
        obj[prim("prim->str", toIndex) = arr[prim("prim->str", fromIndex)] ];
        procArrayElt(arr, prim("+", fromIndex, 1), prim("+", toIndex, 1))
      }
    })
    if (object? elt) {
      if (elt[<#class>] == "Array") {
        procArrayElt(elt, 0, n)
      } else {
        procNormalElt(elt, n)
      }
    } else {
      procNormalElt(elt, n)
    }
  })
  rec (procAllElts = func(from, fromIndex, toIndex) {
    if (from[prim("prim->str", fromIndex)] != undefined) {
      let (nextI = procElt(A, from[prim("prim->str", fromIndex)], toIndex))
      procAllElts(from, prim("+", fromIndex, 1), nextI)
    } else { toIndex }
  })
  let (halftime = if (O[<#class>] == "Array") {
    procAllElts(O, 0, 0) } else { A["0" = O]; 1 })
    let (end = procAllElts(args, 0, halftime)) {
        A["length" = end];
        A
    }
}

let [%concat] = 
  { [#code : %concatCall, #proto : %FunctionProto, #class: "Function"] }

{ %defineOwnProperty(%concat,
    "length",
    {[] "value" : {#value 1, #writable true},
        "enumerable" : {#value false, #writable true}})}

{ %defineOwnProperty(%ArrayProto,
    "concat",
    {[] "value" : {#value %concat, #writable true}})}

let [%sortCall] = func(obj, this, args) {
  let (obj = %ToObject(this))
  let (sortCompare = func(j, k) {
    let (jString = %ToString(j))
    let (kString = %ToString(k))

    let (hasj = prim("hasProperty", obj, jString))
    let (hask = prim("hasProperty", obj, kString))
      label ret: {
          if (hasj == false && hask == false) {
              break ret 0
          } else { null };
          
          if (hasj == false) {
              break ret 1
          } else { null };
          
          if (hask == false) {
              break ret -1
          } else { null };
          
          let (x = obj[jString])
          let (y = obj[kString]) {
              if (x == undefined && y == undefined) {
                  break ret 0
              } else { null };
              
              if (x == undefined) {
                  break ret 1
              } else { null };
          
              if (y == undefined) {
                  break ret -1
              } else { null };
          
              if (args["0"] != undefined) {
                  if (prim('!', %IsCallable(args["0"]))) {
                      throw %JSError({[#proto : %TypeErrorProto,]})
                  } else { null };
                  
                  break ret args["0"](undefined, 
                                      {[] "0" : {#value x, #writable true},
                                       "1" : {#value y, #writable true}})
              } else { null };
              
              let (xString = %ToString(x))
              let (yString = %ToString(y)) {
              
                  if (prim("string<", xString, yString)) {
                      break ret -1
                  } else { null };
                  
                  if (prim("string<", yString, xString)) {
                      break ret 1
                  } else { null };
                  break ret 0
              }
          }
      }})

  let (insert = func(elt, before) {
    rec (insertAndShift = func(prior, i) {
      let (indx = prim("prim->str", i))
        let (next = obj[indx]) {
            obj[indx = prior];
            if (prim("<", i, before)) {
                insertAndShift(next, prim("+", i, 1))
            } else { undefined }
        }
    })

    rec (loop = func(currIndex) {
      if (currIndex == before) {
        // elt can stay where it was
        undefined
      } else {
        let (indx = prim("prim->str", currIndex))
        let (result = sortCompare(currIndex, before))
        if (result == 1) {
          let (old = obj[indx]) {
            obj[indx = elt];
            insertAndShift(old, prim("+", currIndex, 1))
          }
        } else {
          loop(prim("+", currIndex, 1))
        }
      }
    })

    loop(0)
  }) 
  let (len = obj["length"])
  rec (isort = func(i) {
    if (prim("<", i, len)) {
      insert(obj[prim("prim->str", i)], i);
      isort(prim("+", i, 1))
    } else { obj }
  })

  isort(1)
}

let [%sort] = { [#code : %sortCall, #proto : %FunctionProto, #class: "Function"] }

{%defineOwnProperty(%sort,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%define15Property(%ArrayProto, "sort", %sort)}

let [%ArrayCall] = func(obj, this, args) { %ArrayConstructor(obj, args) }

let [%ArrayGlobalFuncObj] = 
  { [#code : %ArrayCall, #proto : %FunctionProto, #class : "Function", construct: %ArrayConstructor] 
    "prototype" : {#value %ArrayProto, #writable false} }

{ %ArrayGlobalFuncObj["length" = 1];
  %ArrayGlobalFuncObj["length"<#enumerable> = false];
  %ArrayGlobalFuncObj["length"<#configurable> = false];
  %ArrayGlobalFuncObj["notinspec" = %freeze]; // Not in spec! Will ses delete this?
  %defineOwnProperty(%ArrayProto,
      "constructor",
      {[] "value" : {#value %ArrayGlobalFuncObj, #writable true},
          "configurable" : {#value true, #writable true},
          "enumerable" : {#value false, #writable true}}) }

let [%getCurrentUTC] = func() { prim("current-utc-millis", undefined) }

let [%parse] = func(v) { 0 } // TODO: implement

let [%CheckObjectCoercible] = func(o) {
  if (o == undefined || o == null) {
    %TypeError("Not object coercible")
  } else { undefined }
}

let [%charAtCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    ""
  } else { 
    prim("char-at", S, position)
  }
}

let [%charAt] = {[#code : %charAtCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%charAt,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "charAt",
  {[] "value" : {#value %charAt, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%charCodeAtCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    NaN
  } else { 
    prim("ascii_cton", prim("char-at", S, position))
  }
}

let [%charCodeAt] = {[#code : %charCodeAtCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%charCodeAt,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "charCodeAt",
  {[] "value" : {#value %charCodeAt, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%stringConcatCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (end = args["length"])
  rec (loop = func(i, soFar) {
    if (prim("<", i, end)) {
      let (next = %ToString(args[prim("prim->str", i)]))
      loop(prim("+", i, 1), prim("string+", soFar, next))
    } else { soFar }
  })
  loop(0, S)
}

let [%stringConcat] = {[#code : %stringConcatCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%stringConcat,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "concat",
  {[] "value" : {#value %stringConcat, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%min] = func(a, b) {
  if (prim("<=", a, b)) { a } else { b }
}
let [%max] = func(a, b) {
  if (prim("<=", a, b)) { b } else { a }
}

let [%substringCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"]))
  let (intEnd =
    let (end = args["1"])
    if (end == undefined) { len } else { %ToInteger(end) })
  let (finalStart = %min(%max(intStart, 0), len))
  let (finalEnd = %min(%max(intEnd, 0), len))
  let (from = %min(finalStart, finalEnd))
  let (to = %max(finalStart, finalEnd))
  rec (loop = func(i, soFar) {
    if (prim("<", i, to)) {
      loop(prim("+", i, 1), prim("string+", soFar, prim("char-at", S, i)))
    } else { soFar }
  })
  loop(from, "")
}

let [%substring] = {[#code : %substringCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%substring,
  "length",
  {[] "value" : {#value 2, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "substring",
  {[] "value" : {#value %substring, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%spliceCall] = func(obj, this, args) {
  let (start = args["0"])
  let (deleteCount = args["1"])

  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = %MakeArray(0))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(start))
  let (actualStart = 
    if (prim("<", relativeStart, 0)) {
      %max(prim("+", len, relativeStart), 0)
    } else {
      %min(relativeStart, len)
    })
  let (actualDeleteCount =
       %min(%max(%ToInteger(deleteCount), 0), prim("-", len, actualStart))) {

      rec (writeToALoop = func(k) {
          if (prim("<", k, actualDeleteCount)) {
              let (from = %ToString(prim("+", actualStart, k)))
              if (prim("hasProperty", O, from)) {
                  let (fromValue = O[from])
                      %defineOwnProperty(A,
                                         %ToString(k),
                                         {[] "value" : {#value fromValue, #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}});
                  A["length" = prim("+", A["length"], 1)];
                  writeToALoop(prim("+", k, 1))
              } else {
                  writeToALoop(prim("+", k, 1))
              }
          } else { undefined }
      })
      writeToALoop(0);
      
      let (itemCount = prim("-", args["length"], 2)) {
          let (step1 = func() {
              if (prim("<", itemCount, actualDeleteCount)) {
                  let (end = prim("-", len, actualDeleteCount))
                  rec (writeToOLoop = func(k) {
                      if (prim("<", k, end)) {
                          let (from = %ToString(prim("+", k, actualDeleteCount)))
                          let (to = %ToString(prim("+", k, itemCount)))
                          if (prim("hasProperty", O, from)) {
                              O[to = O[from] ];
                              writeToOLoop(prim("+", k, 1))
                          } else { 
                              O[delete to];
                              writeToOLoop(prim("+", k, 1))
                          }
                      } else { undefined }
                  })
                  writeToOLoop(actualStart);
                  
                  let (delLimit = prim("+", prim("-", len, actualDeleteCount), itemCount))
                  rec (deleteloop = func(k) {
                      if (prim(">", k, delLimit)) {
                          let (next = prim("-", k, 1)) {
                              O[delete %ToString(next)];
                              deleteloop(next)
                          }
                      } else { undefined }
                  })
                  deleteloop(len)
              } else { null }
          })
          step1();
          
          let (step2 = func() {
              if (prim(">", itemCount, actualDeleteCount)) {
                  rec (writeToOLoop = func(k) {
                      if (prim(">", k, actualStart)) {
                          let (from = %ToString(prim("+", k, prim("-", actualDeleteCount, 1))))
                          let (to = %ToString(prim("+", k, prim("-", itemCount, 1))))
                          if (prim("hasProperty", O, from)) {
                              O[to = O[from] ];
                          writeToOLoop(prim("-", k, 1))
                          } else { 
                              O[delete to];
                              writeToOLoop(prim("-", k, 1))
                          }
                      } else { undefined }
                  })
                  
                  writeToOLoop(prim("-", len, actualDeleteCount))
              } else {
                  undefined
              }
          })
          step2();
          
          let (outerEnd = args["length"])
          rec(outerloop = func(k, argsIndex) {
              if (prim("<", argsIndex, outerEnd)) {
                  O[%ToString(k) = args[prim("prim->str", argsIndex)] ];
                  outerloop(prim("+", k, 1), prim("+", argsIndex, 1))
              } else { undefined }
          })
          outerloop(actualStart, 2);
          O["length" = prim("+", prim("-", len, actualDeleteCount), itemCount)];
          A
      }
  }
}

let [%splice] = {[#code : %spliceCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%splice,
  "length",
  {[] "value" : {#value 2, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "splice",
  {[] "value" : {#value %splice, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%unshiftCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (argCount = %ComputeLength(args)) {

      rec (Oloop = func(k) {
          if (prim(">", k, 0)) {
              let (from = %ToString(prim("-", k, 1)))
              let (to = %ToString(prim("+", k, prim("-", argCount, 1))))
              if (prim("hasProperty", O, from)) {
                  O[to = O[from] ];
                  Oloop(prim("-", k, 1))
              } else { 
                  O[delete to];
                  Oloop(prim("-", k, 1))
              }
          } else { undefined }
      })
      Oloop(len);

      let (end = %ComputeLength(args))
      rec (argsLoop = func(argsIndex, j) {
          if (prim("<", argsIndex, end)) {
              O[%ToString(j) = args[prim("prim->str", argsIndex)] ];
              argsLoop(prim("+", argsIndex, 1), prim("+", j, 1))
          } else { undefined }
      })
      argsLoop(0, 0);
      
      let (finalLen = prim("+", len, argCount)) {
          O["length" = finalLen];
          finalLen
      }
    }
}

let [%unshift] = {[#code : %unshiftCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%unshift,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "unshift",
  {[] "value" : {#value %unshift, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%arrayIndexOfCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))

    label ret: {
        if (len == 0) {
            break ret -1
        } else { undefined };
        
        let (n = if (args["1"] == undefined) { 0 } else { %ToInteger(args["1"]) }) {
            if (prim(">=", n, len)) {
                break ret -1
            } else { undefined };
            
            rec (loop = func(k) {
                if (prim("<", k, len)) {
                    let (kStr = %ToString(k))
                    if (prim("hasProperty", O, kStr)) {
                        let (elementK = O[kStr])
                        if (args["0"] == elementK) {
                            break ret k
                        } else { undefined };
                        loop(prim("+", k, 1))
                    } else { 
                        loop(prim("+", k, 1))
                    }
            } else { undefined }
            })
            let (start = if (prim(">=", n, 0)) { n } else {
                    %max(prim("-", len, prim("abs", n)), 0)
            }) {
                loop(start);
                break ret -1
            }
        }
    }
}

let [%arrayIndexOf] = {[#code : %arrayIndexOfCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%arrayIndexOf,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "indexOf",
  {[] "value" : {#value %arrayIndexOf, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%arrayLastIndexOfCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))

    label ret: {
        if (len == 0) {
            break ret -1
        } else { undefined };
        
        let (n = if (args["1"] == undefined) { prim("-", len, 1) } 
             else { %ToInteger(args["1"]) })
        rec (loop = func(k) {
            if (prim(">=", k, 0)) {
                let (kstr = %ToString(k))
                if (prim("hasProperty", O, kstr)) {
                    if (O[kstr] == args["0"]) {
                        break ret k
                    } else { loop(prim("-", k, 1)) }
                } else { loop(prim("-", k, 1)) } 
            } else { undefined }
        })
        
        let (start = if (prim(">=", n, 0)) { %min(n, prim("-", len, 1)) }
             else { prim("-", len, prim("abs", n)) })
        loop(start);
        break ret -1
    }
}

let [%arrayLastIndexOf] = {[#code : %arrayLastIndexOfCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%arrayLastIndexOf,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "lastIndexOf",
  {[] "value" : {#value %arrayLastIndexOf, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%foreachCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (callbackfn = args["0"])
  
  label ret: {

      if (prim('!', %IsCallable(callbackfn))) {
          %TypeError("Callback not a function in forEach")
      } else { undefined };
      
      let (T = args["1"])
      rec (loop = func(k) {
          if (prim("<", k, len)) {
              let (Pk = %ToString(k))
              if (prim("hasProperty", O, Pk)) {
                  let (kValue = O[Pk])
                  let (argslist = 
                       {[] "0" : {#value kValue, #writable true},
                        "1" : {#value k, #writable true},
                        "2" : {#value O, #writable true}})
                  callbackfn(T, argslist);
                  loop(prim("+", k, 1))
              } else {
                  loop(prim("+", k, 1))
              }
          } else { undefined }
      })
      loop(0);
      undefined
  }
}

let [%foreach] = {[#code : %foreachCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%foreach,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%define15Property(%ArrayProto, "forEach", %foreach)}

let [%mapCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])
  
    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
      %TypeError("Callback not a function in map")
        } else { null };
        
        let (T = args["1"])
        let (A = %MakeArray(0))
        
        rec (loop = func(k) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                if (prim("hasProperty", O, Pk)) {
                    let (kValue = O[Pk])
                    let (argsObj = {[]}) {
                        argsObj["0" = kValue];
                        argsObj["1" = k];
                        argsObj["2" = O];
                        argsObj["length" = 3];
                        let (mappedValue = callbackfn(T, argsObj))
                            %defineOwnProperty(A,
                                               Pk,
                                               {[] "value" : {#value mappedValue, #writable true},
                                                "writable" : {#value true, #writable true},
                                                "enumerable" : {#value true, #writable true},
                                                "configurable" : {#value true, #writable true}});
                        loop(prim("+", k, 1))
                    }
                } else {
                    loop(prim("+", k, 1))  
                }
            } else { A["length" = k] }
        }) {
        
            loop(0);
            break ret A
        }
    }
}

let [%map] = {[#code : %mapCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%map,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "map",
  {[] "value" : {#value %map, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%filterCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
      %TypeError("Callback not a function in filter")
        } else { null };
        
        let (T = args["1"])
  let (A = %MakeArray(0))
        
        rec (loop = func(k, to) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                if (prim("hasProperty", O, Pk)) {
                    let (kValue = O[Pk])
                    let (argsObj = {[]}) {
                        argsObj["0" = kValue];
                        argsObj["1" = k];
                        argsObj["2" = O];
                        argsObj["length" = 3];
                        let (selected  = callbackfn(T, argsObj))
                        if (%ToBoolean(selected)) {
                                %defineOwnProperty(A, %ToString(to),
                                                   {[] "value" : {#value kValue, #writable true},
                                                    "writable" : {#value true, #writable true},
                                                    "enumerable" : {#value true, #writable true},
                                                    "configurable" : {#value true, #writable true}});
                            loop(prim("+", k, 1), prim("+", to, 1))
                        } else {
                            loop(prim("+", k, 1), to)
                        }
                    }
                } else {
                    loop(prim("+", k, 1), to)
                }
            } else { 
                A["length" = to]
            }
        }) {
            loop(0, 0);
            break ret A
        }
    }
}

let [%filter] = {[#code : %filterCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%ArrayProto,
  "filter",
  {[] "value" : {#value %filter, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%reduceCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])
  let (has_initial = prim(">=", args["length"], 2))

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
            %TypeError("Callback not a function in reduce")
        } else { null };

        if (len == 0 && prim("!", has_initial)) {
            %TypeError("Reducing an empty list with not enough arguments.")
        } else { null };

        let (origK = if (has_initial) { -1 } else {
            rec (accumLoop = func(k) {
                if (prim("<", k, len)) {
                    let (Pk = %ToString(k))
                    let (kPresent = prim("hasProperty", O, Pk))
                    if (kPresent) {
                        k
                    } else {
                        accumLoop(prim("+", k, 1))
                    }
                } else { %TypeError("In Array reduce") }
            })
            accumLoop(0)
        })
        let (accumulator = if (has_initial) { args["1"] } else { O[%ToString(origK)] }) 
        
        rec (outerLoop = func(k, accumulator) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                let (kPresent = prim("hasProperty", O, Pk))
                if (kPresent) {
                    let (kValue = O[Pk])
                    let (argsObj = {[]}) {
                        argsObj["0" = accumulator];
                        argsObj["1" = kValue];
                        argsObj["2" = k];
                        argsObj["3" = O];
                        argsObj["length" = 4];
                        let (next = callbackfn(undefined, argsObj))
                        outerLoop(prim("+", k, 1), next)
                    }
                } else {
                    outerLoop(prim("+", k, 1), accumulator)
                }
            } else { accumulator }
        })

        break ret outerLoop(prim("+", origK, 1), accumulator)
    }
}

let [%reduce] = {[#code : %reduceCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%reduce,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }
  
{%defineOwnProperty(%ArrayProto,
  "reduce",
  {[] "value" : {#value %reduce, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%everyCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
      %TypeError("Callback not function in every")
        } else { null };

        let (T = args["1"])
        rec (loop = func(k) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                let (kPresent = prim("hasProperty", O, Pk))
                if (kPresent) {
                    let (kValue = O[Pk])
                    let (argsObj = {[]}) {
                        argsObj["0" = kValue];
                        argsObj["1" = k];
                        argsObj["2" = O];
                        argsObj["length" = 3];
                        let (testResult = callbackfn(T, argsObj))
                        if (%ToBoolean(testResult) == false) {
                            false
                        } else {
                            loop(prim("+", k, 1))
                        }
                    }
                } else {
                    loop(prim("+", k, 1))
                }
            } else { true }
        })

        break ret loop(0)
    }
}

let [%every] = {[#code : %everyCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%every,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }
  
{%defineOwnProperty(%ArrayProto,
  "every",
  {[] "value" : {#value %every, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%someCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
    %TypeError("Callback not function in some")
        } else { null };

        let (T = args["1"])
        rec (loop = func(k) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                let (kPresent = prim("hasProperty", O, Pk))
                if (kPresent) {
                    let (kValue = O[Pk])
                    let (argsObj = {[]}) {
                        argsObj["0" = kValue];
                        argsObj["1" = k];
                        argsObj["2" = O];
                        argsObj["length" = 3];
                        let (testResult = callbackfn(T, argsObj))
                        if (%ToBoolean(testResult) == true) {
                            true
                        } else {
                            loop(prim("+", k, 1))
                        }
                    }
                } else {
                    loop(prim("+", k, 1))
                }
            } else { false }
        })

        break ret loop(0)
    }
}

let [%some] = {[#code : %someCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%some,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }
  
{%defineOwnProperty(%ArrayProto,
  "some",
  {[] "value" : {#value %some, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%reduceRightCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])
  let (has_initial = prim(">=", args["length"], 2))

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
            %TypeError("Callback not function in reduceRight")
        } else { null };
        
        if (len == 0 && prim("!", has_initial)) {
            %TypeError("Zero-length array in reduceRight")
        } else { null };
        
        let (origK = if (has_initial) { len } else {
            rec (accumLoop = func(k) {
                if (prim(">=", k, 0)) {
                    let (Pk = %ToString(k))
                    let (kPresent = prim("hasProperty", O, Pk))
                    if (kPresent) {
                        k
                    } else {
                        accumLoop(prim("-", k, 1))
                    }
                } else { %TypeError("reduceRight") }
            })
            accumLoop(prim("-", len, 1))
        })
        let (accumulator = if (has_initial) { args["1"] } else { O[%ToString(origK)] }) 
        
        rec (outerLoop = func(k, accumulator) {
            if (prim(">=", k, 0)) {
                let (Pk = %ToString(k))
                let (kPresent = prim("hasProperty", O, Pk))
                if (kPresent) {
                    let (kValue = O[Pk])
                    let (argsObj = {[]}) {
                        argsObj["0" = accumulator];
                        argsObj["1" = kValue];
                        argsObj["2" = k];
                        argsObj["3" = O];
                        argsObj["length" = 4];
                        let (next = callbackfn(undefined, argsObj))
                        outerLoop(prim("-", k, 1), next)
                    }
                } else {
                    outerLoop(prim("-", k, 1), accumulator)
                }
            } else { accumulator }
        })
        
        break ret outerLoop(prim("-", origK, 1), accumulator)
    }
}

let [%reduceRight] = {[#code : %reduceRightCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%reduceRight,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }
  
{%defineOwnProperty(%ArrayProto,
  "reduceRight",
  {[] "value" : {#value %reduceRight, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%sliceCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (A = %MakeArray(0))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(args["0"]))

  let (initk = if (prim("<", relativeStart, 0)) {
    let (added = prim("+", len, relativeStart))
    if (prim(">", added, 0)) { added } else { 0 }
    } else {
      if (prim("<", relativeStart, len)) { relativeStart } else { len }
    })

  let (relativeEnd = if (args["1"] == undefined) { len } 
    else { %ToInteger(args["1"]) })

  let (final = if (prim("<", relativeEnd, 0)) {
    let (added = prim("+", len, relativeEnd))
    if (prim(">", added, 0)) { added } else { 0 }
  } else {
    if (prim("<", relativeEnd, len)) { relativeEnd } else { len }
  })

    rec (loop = func(n, k, finalLen) {
        label ret: {
            if (prim(">=", k, final)) {
                break ret finalLen
            } else { null };

            let (Pk = %ToString(k))
            let (kPresent = prim("hasProperty", O, Pk))
            if (kPresent) {
                let (kValue = O[Pk])
                    %defineOwnProperty(A,
                                       %ToString(n),
                                       {[] "value" : {#value kValue, #writable true},
                                        "writable" : {#value true, #writable true},
                                        "configurable" : {#value true, #writable true},
                                        "enumerable" : {#value true, #writable true}});
                break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
            } else {
                break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
            }
        }}) {

        A["length" = loop(0, initk, 0)];
        A
    }
}

let [%slice] = {[#code : %sliceCall, #proto : %FunctionProto, #class: "Function"]}

{ %defineOwnProperty(%slice,
    "length",
    {[] "value" : {#value 2, #writable true},
        "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
    "slice",
    {[] "value" : {#value %slice, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [%BindObjCall] = func(obj, this, args) {
    let (concatted = %concat(obj[<boundArgs>], args))
    %AppExprCheck(obj[<target>], obj[<boundThis>], concatted)
}

let [%BindConstructor] = func(constr, args) {
  let (concatted = %concat(constr[<boundArgs>], args)) // TODO concat for args objects
  %PrimNew(constr[<target>], concatted)
}

let [%MakeBind] = func(obj, this, args) {
  let (len = if (obj[<#class>] == "Function") {
    let (L = prim("-", obj["length"], args["length"])) %max(0, L)}
    else { 0 })
  {[#code: %BindObjCall, #proto: %FunctionProto, #class: "Function", construct: %BindConstructor, target: obj, boundThis: this, boundArgs: args]
    "caller": {#getter %ThrowTypeError, #setter %ThrowTypeError, #enumerable false, #configurable false},
    "arguments": {#getter %ThrowTypeError, #setter %ThrowTypeError, #enumerable false, #configurable false},
    "length": {#value len, #writable false, #enumerable false, #configurable false}}
}

let [%bindCall] = func(obj, this, args) {
    if (!%IsCallable(this)) {
      %TypeError("this not function in bind")
    };
    let (thisArg = args["0"])
    let (A = %slice(args, %oneArgObj(1))) // TODO slice for args objects
    %MakeBind(this, thisArg, A)
}

let [%bind] = {[#code : %bindCall, #proto : %FunctionProto, #class: "Function"]}

{ %defineOwnProperty(%bind,
    "length",
    {[] "value" : {#value 1, #writable true},
        "configurable" : {#value false, #writable true}}) }

{ %define15Property(%FunctionProto, "bind", %bind) }

let [%numToStringAbstract] = func(n, r) {
    rec (nts = func(n, r) {
        label ret: {
            if (n != n) {
                break ret "NaN"
            } else { null };

            if (n == 0) {
                break ret "0"
            } else { null };

            if (prim("<", n, 0)) {
                break ret prim("string+", "-", nts(-n, r))
            } else { null };

            if (n == +inf) {
                break ret "Infinity"
            } else { null };

            if (r == 10) {
                break ret prim("prim->str", n)
            } else { null };
            break ret prim("base", n, r)
        }})
  nts(n, r)
}

let [%numberPrimval] = func(this) {
  if (typeof this == "number") { this } else if (typeof this == "object" && this[<#class>] == "Number") { this[<primval>] } else { %TypeError("not a number") }
} 

let [%numberToStringCall] = func(obj, this, args) {
  let (val = %numberPrimval(this))
  let (rint = if (args["0"] == undefined) { 10 } else { %ToInteger(args["0"]) })
  if (prim("<", rint, 2) || prim(">", rint, 36)) {
    %RangeError("Number.toString received invalid radix")
  } else {
    %numToStringAbstract(val, rint)
  }
}

let [%numberToString] = 
  { [#code : %numberToStringCall, #proto: %FunctionProto, #class: "Function",] }

{%define15Property(%numberToString, "length", 1)}

{%define15Property(%NumberProto, "toString", %numberToString)}

let [%stringIndexOfCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"]))
  let (pos = %ToInteger(args["1"]))
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j == searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) != prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim(">", prim("+", curr, searchLen), len)) { -1 } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("+", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%stringIndexOf] = { [#code : %stringIndexOfCall, #proto : %FunctionProto, #class: "Function"]}

{ %stringIndexOf["length" = 1];
  %stringIndexOf["length"<#enumerable> = false];
  %stringIndexOf["length"<#configurable> = false];
  %stringIndexOf["length"<#writable> = false];
  %StringProto["indexOf" = %stringIndexOf]}

let [%replaceCall] = func(obj, this, args) {
  let (S = %ToString(this))
  let (search = %ToString(args["0"]))
  let (replace = args["1"])
  if(prim("!", %IsCallable(replace))) { throw "String.replace() only supports functions" }
  else {
    rec (loop = func(str) {
      let (start = %stringIndexOf(str, %oneArgObj(search))) {
        if (start == -1) { str }
        else {
          let (replaced = %ToString(replace(undefined, %oneArgObj(replace))))
          let (before = %substring(str, %twoArgObj(0, start)))
          let (afterix = prim("+", start, prim("strlen", search)))
          let (after = %substring(str, %oneArgObj(afterix))) {
            prim("string+", before,
              prim("string+", replaced,
              loop(after)))
          }
        }
      }
    }) {
      loop(S)
    }
  }
}

let [%replace] = { [#code : %replaceCall, #proto : %FunctionProto, #class: "Function"] }

{ %StringProto["replace" = %replace] }

let [%stringLastIndexOfCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"]))
  let (numPos = %ToNumber(args["1"]))
  let (pos = 
    if (numPos != numPos) { 
      +inf
    } else { %ToInteger(numPos) })
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j == searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) != prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim("<", curr, 0)) { -1 } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("-", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%stringLastIndexOf] = {[#code : %stringLastIndexOfCall, #proto : %FunctionProto, #class: "Function"]}

{ %stringLastIndexOf["length" = 1];
  %stringLastIndexOf["length"<#enumerable> = false];
  %stringLastIndexOf["length"<#configurable> = false];
  %stringLastIndexOf["length"<#writable> = false];
  %StringProto["lastIndexOf" = %stringLastIndexOf]}

let [%localeCompareCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (That = %ToString(args["0"]))
  prim("locale-compare", S, That)
}

let [%localeCompare] = {[#code : %localeCompareCall, #proto : %FunctionProto, #class: "Function"]}

{ %localeCompare["length" = 1];
  %localeCompare["length"<#enumerable> = false];
  %localeCompare["length"<#configurable> = false];
  %localeCompare["length"<#writable> = false];
  %StringProto["localeCompare" = %localeCompare]}

let [%stringSliceCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"]))
  let (end = args["1"])
  let (intEnd = if (end == undefined) { len } else { %ToInteger(end) })
  let (from = if (prim("<", intStart, 0)) { 
    %max(prim("+", len, intStart), 0) } else { %min(intStart, len) })
  let (to = if (prim("<", intEnd, 0)) { 
    %max(prim("+", len, intEnd), 0) } else { %min(intEnd, len) })
  let (span = %max(prim("-", to, from), 0))
  rec (build = func(i, result) {
    if (prim("<", i, span)) {
      let (next = prim("string+", result, prim("char-at", S, prim("+", from, i))))
      build(prim("+", i, 1), next)
    } else { result }
  })
  build(0, "")
}

let [%stringSlice] = {[#code : %stringSliceCall, #proto : %FunctionProto, #class: "Function"]}

{ %stringSlice["length" = 2];
  %stringSlice["length"<#enumerable> = false];
  %stringSlice["length"<#configurable> = false];
  %stringSlice["length"<#writable> = false];
  %StringProto["slice" = %stringSlice]}

let [%toLowerCaseCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-lower", S)
}

let [%toLowerCase] = {[#code : %toLowerCaseCall, #proto : %FunctionProto, #class: "Function"]}

{%StringProto["toLowerCase" = %toLowerCase]}

let [%toUpperCaseCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-upper", S)
}

let [%toUpperCase] = {[#code : %toUpperCaseCall, #proto : %FunctionProto, #class: "Function"]}

{%StringProto["toUpperCase" = %toUpperCase]}

// Turkish language support NYI
{%StringProto["toLocaleLowerCase" = %toLowerCase];
 %StringProto["toLocaleUpperCase" = %toUpperCase]}

let [%splitCall] = func(obj, this, args) {
  "String.prototype.split NYI"
}

let [%split] = {[#code : %splitCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%StringProto,
  "split",
  {[] "value" : {#value %split, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%IsFinite] = func(n) {
  prim("!", (n != n || n == +inf || n == -inf))
}

// http://es5.github.com/#x15.9.1.2
let [%msPerDay] = 86400000
let [%msPerHour] = 3600000
let [%msPerMin] = 60000
let [%msPerSecond] = 1000
let [%Day] = func(t) { prim("floor", prim("/", t, %msPerDay)) }
let [%TimeWithinDay] = func(t) { prim("%", t, %msPerDay) }

// http://es5.github.com/#x15.9.1.3
let [%DaysInYear] = func(y) {
  if (prim("%", y, 4) != 0) {
    365
  }
  else {
    if (prim("%", y, 400) == 0 || prim("%", y, 100) != 0) {
      366
    }
    else {
      365
    }
  }
}

// http://es5.github.com/#DayFromYear
let [%DayFromYear] = func(y) {
  let (fragment = func(offset, coefficient) {
    prim("floor", prim("/", prim("-", y, offset), coefficient))
  })
  let (base = prim("*", 365, prim("-", y, 1970)))
  let (part1 = fragment(1969, 4))
  let (part2 = fragment(1901, 100))
  let (part3 = fragment(1601, 400))
  prim("+", prim("-", prim("+", base, part1), part2), part3)
}

// http://es5.github.com/#TimeFromYear 
let [%TimeFromYear] = func(y) {
  prim("*", %msPerDay, %DayFromYear(y))
}

// http://es5.github.com/#YearFromTime
let [%YearFromTime] = func(t) {
  let (sign = prim("sign", t))
  let (start = if (sign == 1) {1969} else {1970})
  rec (loop = func(y) {
    if (prim("<=", %TimeFromYear(y), t)
        && prim(">", %TimeFromYear(prim("+", 1, y)), t)) {
      y
    }
    else {
      loop(prim("+", y, sign))
    }
  })
  loop(start)
}

// http://es5.github.com/#x15.9.1.4
let [%DayWithinYear] = func(t) {
  prim("-", %Day(t), %DayFromYear(%YearFromTime(t)))
}

// http://es5.github.com/#InLeapYear
let [%InLeapYear] = func(t) {
  if(%DaysInYear(%YearFromTime(t)) == 365) {
    0
  } else {
    1
  }
}

let [%DaysInMonth] = func(m, leap) {
  let (m = prim("%", m, 12))
  if (m == 3 || m == 5 || m == 8 || m == 10) {
    30
  } else if (m == 1) {
    prim("+", 28, leap)
  } else {
    31
  }
}

// NOTE(joe): It might be obvious to others, but it wasn't to me.  Since
// January is month #0 and February is month #1, and they happen before
// the leap day, they are being treated specially by the algorithms
// below.  For March and beyond, we can generalize the behavior into
// helpers, but the first two cases both require special handling.

// http://es5.github.com/#x15.9.1.4
let [%MonthFromTime] = func(t) {
  let (DayWithinYear = func(t) {
    prim("-", %Day(t), %DayFromYear(%YearFromTime(t)))
  })
  let (CheckLeapRange = func(start, end) {
    prim("<=", prim("+", start, %InLeapYear(t)), DayWithinYear(t)) &&
    prim("<", DayWithinYear(t), prim("+", end, %InLeapYear(t)))
  })
  if (prim("<=", 0, %DayWithinYear(t)) &&
      prim("<", %DayWithinYear(t), 31)) {
    0
  } else if(prim("<=", 31, %DayWithinYear(t)) &&
            prim("<", %DayWithinYear(t), prim("+", 59, %InLeapYear(t)))) {
    1
  }
  else if(CheckLeapRange(59, 90)) { 2 }
  else if(CheckLeapRange(90, 120)) { 3 }
  else if(CheckLeapRange(120, 151)) { 4 }
  else if(CheckLeapRange(151, 181)) { 5 }
  else if(CheckLeapRange(181, 212)) { 6 }
  else if(CheckLeapRange(212, 243)) { 7 }
  else if(CheckLeapRange(243, 273)) { 8 }
  else if(CheckLeapRange(273, 304)) { 9 }
  else if(CheckLeapRange(304, 334)) { 10 }
  else if(CheckLeapRange(334, 365)) { 11 }
  else { %TypeError("Something terrible in date %MonthFromTime")}
}

// http://es5.github.com/#x15.9.1.5
let [%DateFromTime] = func(t) {
  let (mft = %MonthFromTime(t))
  let (CalcDay = func(offset) {
    prim("-", prim("-", %DayWithinYear(t), offset), %InLeapYear(t))
  })
  if (mft == 0) { prim("+", %DayWithinYear(t), 1) }
  else if (mft == 1) { prim("-", %DayWithinYear(t), 30) }
  else if (mft == 2) { CalcDay(58) }
  else if (mft == 3) { CalcDay(89) }
  else if (mft == 4) { CalcDay(119) }
  else if (mft == 5) { CalcDay(150) }
  else if (mft == 6) { CalcDay(180) }
  else if (mft == 7) { CalcDay(211) }
  else if (mft == 8) { CalcDay(242) }
  else if (mft == 9) { CalcDay(272) }
  else if (mft == 10) { CalcDay(303) }
  else if (mft == 11) { CalcDay(333) }
  else { %TypeError("Something terrible happened in %DateFromTime")}
}

let [%LocalTime] = func(t) { t }

let [%MakeDateDayTime] = func(day, time) { prim("+", prim("*", day, %msPerDay), time) }

// http://es5.github.com/#x15.9.1.12
// Implementation draws heavily from the date test harness
let [%MakeDay] = func(yr, mt, date) {
  if (prim("!", (%IsFinite(yr) && %IsFinite(mt) && %IsFinite(date)))) {
    NaN
  }
  else {
    let (y = %ToInteger(yr))
    let (m = %ToInteger(mt))
    let (dt = %ToInteger(date))
    let (ym = prim("+", y, prim("floor", prim("/", m, 12))))
    let (mn = prim("%", m, 12))
    let (yt = %TimeFromYear(y))
    rec (loop = func(t, mo, leap) {
      if(prim("<", mo, m)) {
        let (leap = %InLeapYear(t))
        let (t = prim("+", t, prim("*", %DaysInMonth(mo, leap), %msPerDay)))
        loop(t, prim("+", mo, 1), leap)
      } else {
        t
      }
    }) {
    let (t = loop(yt, 0, %InLeapYear(yt)))
    if (%YearFromTime(t) != ym ||
        %MonthFromTime(t) != mn ||
        %DateFromTime(t) != 1) {
      NaN
    } else {
      prim("-", prim("+", %Day(t), dt), 1)
    }
  }
  }
}

let [%MakeTime] = func(h, m, s, ms) {
  if (prim("!", (%IsFinite(h) && %IsFinite(m) && %IsFinite(s) && %IsFinite(ms)))) {
    NaN
  }
  else {
    let (hour = %ToInteger(h))
    let (min = %ToInteger(m))
    let (sec = %ToInteger(s))
    let (millis = %ToInteger(ms))
    let (t = prim("+",
      prim("+",
        prim("+",
          prim("*", hour, %msPerHour),
          prim("*", min, %msPerMin)),
        prim("*", sec, %msPerSecond)),
      millis)) {
      t
    }
  }

}

// http://es5.github.com/#x15.9.1.9
// S5 has no time zone adjustments or daylight savings time.
// It is, for the time being, indifferent to your i18n and l10n concerns.
let [%UTC] = func(t) { t }

let [%getYearCall] = func(obj, this, args) { 78 } // TODO: implement

let [%getYear] = { [#code : %getYearCall,] }

let [%getMonthCall] = func(obj, this, args) { 3 } // TODO: implement

let [%getMonth] = { [#code: %getMonthCall,] }

{(/*:START SYM EVAL*/0)}

let [%DateProto] = { 
  [#proto : %ObjectProto, #class: "Date",]
  "getYear" : {#value %getYear, #writable false},
  "getMonth": {#value %getMonth, #writable false},
}

{(/*:STOP SYM EVAL*/0)}

let [%MakeDate] = func (v) {
  {[#class: "Date", 
    #extensible: true,
    #proto: %DateProto,
    primval: v,
    virtual: false]}
}

let [%dateToStringCall] = func(obj, this, args) {
  "Date toString NYI"
}

let [%dateToString] = {[#code : %dateToStringCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%DateProto, "toString", %dateToString)}

let [%dateValueOfCall] = func(obj, this, args) {
  this[<primval>]
}

let [%dateValueOf] = {[#code : %dateValueOfCall, #proto : %FunctionProto, #class: "Function"]}

{%DateProto["valueOf" = %dateValueOf] }


// http://es5.github.com/#x15.9.1.14
let [%TimeClip] = func(t) {
  if (prim("!", %IsFinite(t) &&
      prim("<=", prim("abs", t), 8.64e15))) {
    NaN
  } else {
    %ToInteger(t)
  }
}

let [%DateCall] = func(obj, this, args) {
  let (o = %MakeDate(%getCurrentUTC()))
  %dateToString(o, {[]})
}

let [%DateConstructor] = func(constr, args) {
  let (nargs = %ComputeLength(args))
  if (nargs == 0) {
    %MakeDate(%getCurrentUTC())
  }
  else if (nargs == 1) {
    let (v = %ToPrimitive(args["0"]))
    let (V =
      if (prim("typeof", v) == "string") { %parse(v) } else { %ToNumber(v) })
    let (clipped = %TimeClip(V))
    { [#proto : %DateProto, #class : "Date", #extensible : true, primval : clipped,] }
  } else {
    let (y = %ToNumber(args["0"]))
    let (m = %ToNumber(args["1"]))
    let (dt = if (args["2"] == undefined) { 1 } else { %ToNumber(args["2"]) })
    let (h = if (args["3"] == undefined) { 0 } else { %ToNumber(args["3"]) })
    let (min = if (args["4"] == undefined) { 0 } else { %ToNumber(args["4"]) })
    let (s = if (args["5"] == undefined) { 0 } else { %ToNumber(args["5"]) })
    let (milli = if (args["6"] == undefined) { 0 } else { %ToNumber(args["6"]) })
    let (yr = 
      let (tiy = %ToInteger(y))
      let (rangecond1 = prim("<", 0, tiy) || 0 == tiy)
      let (rangecond2 = prim("<", tiy, 99) || tiy == 99)
      if (y != y && rangecond1 && rangecond2) {
        prim("+", 1900, tiy) } else { y })
    let (finalDate = %MakeDateDayTime(%MakeDay(yr, m, dt), %MakeTime(h, min, s, milli)))
    let (primval = %TimeClip(%UTC(finalDate))) {
      { [#proto : %DateProto, #class : "Date", #extensible : true, primval : primval,] }
    }
  }
}

let [%DateGlobalFuncObj] = { [#code : %DateCall, #proto : %FunctionProto, #class: "Function", construct: %DateConstructor]
                             "prototype" : {#value %DateProto, #writable true} }

// http://es5.github.com/#x15.9.5.26
let [%dateGetTimezoneOffsetCall] = func(obj, this, args) {
  let (t = this[<primval>])
  if (t == NaN) { NaN }
  else {
    0
  }
}

let [%dateGetTimezoneOffset] = {[
    #code : %dateGetTimezoneOffsetCall,
    #proto : %FunctionProto,
  ]}

{%define15Property(%DateProto, "getTimezoneOffset", %dateGetTimezoneOffset)}

let [%dategetDayCall] = func(obj, this, args) {
  let (day = prim("floor", prim("/", this[<primval>], %msPerDay)))
  let (weekday = prim("%", prim("+", day, 4), 7)) {
    weekday
  }
}

let [%dategetDay] = {[#code : %dategetDayCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%DateProto, "getDay", %dategetDay)}

let [%dategetDateCall] = func(obj, this, args) {
  let (t = this[<primval>])
  if (t == NaN) { t } else { %DateFromTime(%LocalTime(t)) }
}

let [%dategetDate] = {[#code: %dategetDateCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%DateProto, "getDate", %dategetDate)}

let [%defineNYIProperty] = func(base, name) {
  let (unimplFunc = func(obj, this, args) {
    %TypeError(prim("string+", name, " NYI"))
  })
  let (unimplObj = {[#code: unimplFunc, #proto: %FunctionProto, #class: "Function"]})
  %define15Property(base, name, unimplObj)
}

{
  %defineNYIProperty(%DateGlobalFuncObj, "parse");
  %defineNYIProperty(%DateGlobalFuncObj, "UTC");
  %defineNYIProperty(%DateProto, "getTime");
  %defineNYIProperty(%DateProto, "getFullYear");
  %defineNYIProperty(%DateProto, "getUTCFullYear");
  %defineNYIProperty(%DateProto, "getUTCMonth");
//  %defineNYIProperty(%DateProto, "getDate");
  %defineNYIProperty(%DateProto, "getUTCDate");
  %defineNYIProperty(%DateProto, "getUTCDay");
  %defineNYIProperty(%DateProto, "getHours");
  %defineNYIProperty(%DateProto, "getUTCHours");
  %defineNYIProperty(%DateProto, "getMinutes");
  %defineNYIProperty(%DateProto, "getUTCMinutes");
  %defineNYIProperty(%DateProto, "getSeconds");
  %defineNYIProperty(%DateProto, "getUTCSeconds");
  %defineNYIProperty(%DateProto, "getMilliseconds");
  %defineNYIProperty(%DateProto, "getUTCMilliseconds");
  %defineNYIProperty(%DateProto, "setTime");
  %defineNYIProperty(%DateProto, "setMilliseconds");
  %defineNYIProperty(%DateProto, "setUTCMilliseconds");
  %defineNYIProperty(%DateProto, "setSeconds");
  %defineNYIProperty(%DateProto, "setUTCSeconds");
  %defineNYIProperty(%DateProto, "setMinutes");
  %defineNYIProperty(%DateProto, "setUTCMinutes");
  %defineNYIProperty(%DateProto, "setHours");
  %defineNYIProperty(%DateProto, "setUTCHours");
  %defineNYIProperty(%DateProto, "setDate");
  %defineNYIProperty(%DateProto, "setUTCDate");
  %defineNYIProperty(%DateProto, "setMonth");
  %defineNYIProperty(%DateProto, "setUTCMonth");
  %defineNYIProperty(%DateProto, "setFullYear");
  %defineNYIProperty(%DateProto, "setUTCFullYear");
  %defineNYIProperty(%DateProto, "toUTCString");
  %defineNYIProperty(%DateProto, "toGMTString");
  %defineNYIProperty(%DateProto, "setYear")
}

let [%testCall] = func(obj, this, args) {
  prim("print", "You used the es5.env testCall.  Are you sure you didn't forget to include the regexp.js library, or regexp.env?")
}

let [%test] = { [#code : %testCall,] }

{(/*:START SYM EVAL*/0)}

let [%RegExpProto] = { [#proto : %ObjectProto,]
  "test" : {#value %test, #writable false} }

{(/*:STOP SYM EVAL*/0)}

let [%RegExpConstructor] = func(obj, this, args) {
  {[#proto : %RegExpProto,]}
}

let [%RegExpCode] = func(obj, this, args) { %RegExpConstructor(obj, args) }

let [%RegExpGlobalFuncObj] = {[#code : %RegExpCode, #proto : %FunctionProto, #class: "Function", construct: %RegExpConstructor]
  "prototype" : {#value %RegExpProto, #writable false},
  "length" : {#value 2,
              #writable false,
              #configurable false,
              #enumerable false}}

{%RegExpProto["constructor" = %RegExpGlobalFuncObj]}

/* NOTE(Justin) Does not match spec (http://es5.github.com/#x15.1.2.2).
   We are ignoring any radix argument and using OCaml's float_of_string func. */
let [%parseIntCall] = func(obj, this, args) {
  let (numstr = %ToString(args["0"]))
  prim("prim->num", numstr)
}

let [%parseInt] = { [#code : %parseIntCall, #proto : %FunctionProto, #class: "Function"] }

let [%decodeURICall] = func(obj, this, args) {
  "decodeURI NYI"
}

let [%decodeURI] = {[#code : %decodeURICall, #proto: %FunctionProto, #class: "Function"]}

let [%decodeURIComponentCall] = func(obj, this, args) {
  "decodeURIComponent NYI"
}

let [%decodeURIComponent] = {[#code : %decodeURIComponentCall, #proto: %FunctionProto, #class: "Function"]}

let [%encodeURICall] = func(obj, this, args) {
  "encodeURI NYI"
}

let [%encodeURI] = {[#code : %encodeURICall, #proto: %FunctionProto, #class: "Function"]}

let [%encodeURIComponentCall] = func(obj, this, args) {
  "encodeURIComponent NYI"
}

let [%encodeURIComponent] = {[#code : %encodeURIComponentCall, #proto: %FunctionProto, #class: "Function"]}

let [%expCall] = func() {
  undefined
}

let [%exp] = { [#code : %expCall,] }

let [%Math] = { []
  "E" : {#value 2.7182818284590452354, #writable false},
  "LN10": {#value 2.302585092994046, #writable false},
  "LN2" : {#value 0.6931471805599453, #writable false},
  "LOG2E" : {#value 1.4426950408889634, #writable false},
  "LOG10E" : {#value 0.4342944819032518, #writable false},
  "PI" : {#value 3.141592653589793, #writable false},
  "SQRT1_2" : {#value 0.7071067811865476, #writable false},
  "SQRT2" : {#value 1.4142135623730951, #writable false},
  "exp" : {#value %exp, #writable false} }

let [%minMaxCall] = func(this, args, op, init) {
  let (end = args["length"])

    label ret: {
        if (end == 0) {
            break ret init
        } else { null };

        rec (loop = func(best, i) {
            if (prim("<", i, end)) {
              let (curr = %ToNumber(args[prim("prim->str", i)])) {
                if (curr != curr) {
                    break ret NaN
                } else { null };

                loop(op(best, curr), prim("+", i, 1))
              }
            } else { best }
        })
        break ret loop(init, 0)
    }
}

let [%mathMinCall] = func(obj, this, args) {
  %minMaxCall(this, args, %min, +inf)
}

let [%mathMin] = {[#code : %mathMinCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%mathMin,
  "length",
  {[] "value" : {#value 2, #writable true},
      "configurable" : {#value false, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%Math,
  "min",
  {[] "value" : {#value %mathMin, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathMaxCall] = func(obj, this, args) {
  %minMaxCall(this, args, %max, -inf)  
}

let [%mathMax] = {[#code : %mathMaxCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%mathMax,
  "length",
  {[] "value" : {#value 2, #writable true},
      "configurable" : {#value false, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%Math,
  "max",
  {[] "value" : {#value %mathMax, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathAbsCall] = func(obj, this, args) {
  let (n = %ToNumber(args["0"]))
    label ret: {
        if (n != n) { break ret n } else { null };
        if (n == -inf) { break ret +inf} else { null };
        break ret prim("abs", n)
    }
}

let [%mathAbs] = {[#code : %mathAbsCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "abs",
  {[] "value" : {#value %mathAbs, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%acosCall] = func(obj, this, args) {
  "acos NYI"
}

let [%acos] = {[#code : %acosCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "acos",
  {[] "value" : {#value %acos, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%asinCall] = func(obj, this, args) {
  "asin NYI"
}

let [%asin] = {[#code : %asinCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "asin",
  {[] "value" : {#value %asin, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%atanCall] = func(obj, this, args) {
  "atan NYI"
}

let [%atan] = {[#code : %atanCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "atan",
  {[] "value" : {#value %atan, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%atan2Call] = func(obj, this, args) {
  "atan2 NYI"
}

let [%atan2] = {[#code : %atan2Call, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "atan2",
  {[] "value" : {#value %atan2, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%cosCall] = func(obj, this, args) {
  "cos NYI"
}

let [%cos] = {[#code : %cosCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "cos",
  {[] "value" : {#value %cos, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%randomCall] = func(obj, this, args) {
  4 // IEEE-Vetted random number
}

let [%random] = {[#code : %randomCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "random",
  {[] "value" : {#value %random, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%roundCall] = func(obj, this, args) {
  "round NYI"
}

let [%round] = {[#code : %roundCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "round",
  {[] "value" : {#value %round, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%sinCall] = func(obj, this, args) {
  let (n = %ToNumber(args["0"])) {
    label ret: {
      if (n != n) {
        break ret n
      } else { null };

      if (n == 0) {
        break ret n
      } else { null };

      if (n == +inf) {
        break ret NaN
      } else { null };

      if (n == -inf) {
        break ret NaN
      } else { null };

      break ret prim("sin", n)
    }
  }
}

let [%sin] = {[#code : %sinCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "sin",
  {[] "value" : {#value %sin, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%sqrtCall] = func(obj, this, args) {
  "sqrt NYI"
}

let [%sqrt] = {[#code : %sqrtCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "sqrt",
  {[] "value" : {#value %sqrt, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%tanCall] = func(obj, this, args) {
  "tan NYI"
}

let [%tan] = {[#code : %tanCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "tan",
  {[] "value" : {#value %tan, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathLogCall] = func(obj, this, args) {
  let (n = %ToNumber(args["0"]))
    label ret: {
        if (n != n) { break ret n } else { null };
        if (prim("<", n, 0)) { break ret NaN } else { null };
        if (n == 0) { break ret -inf } else { null };
        if (n == 1) { break ret 0 } else { null };
        if (n == +inf) { break ret n } else { null };
        break ret prim("log", n)
    }
}

let [%mathLog] = {[#code : %mathLogCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "log",
  {[] "value" : {#value %mathLog, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathCeilCall] = func(obj, this, args) {
  let (x = %ToNumber(args["0"]))
    label ret: {
        if (x != x || x == 0 || x == -inf || x == +inf) {
            break ret x
        } else { null };
        break ret prim("ceil", x)
    }
}

let [%mathCeil] = {[#code : %mathCeilCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "ceil",
  {[] "value" : {#value %mathCeil, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathFloorCall] = func(obj, this, args) {
  let (x = %ToNumber(args["0"]))
    label ret: {
        if (x != x || x == 0 || x == -inf || x == +inf) {
            break ret x
        } else { null };
        break ret prim("floor", x)
    }
}
  
let [%mathFloor] = {[#code : %mathFloorCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
  "floor",
  {[] "value" : {#value %mathFloor, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%PrimAdd] = func(l, r) {
    let (l = %ToPrimitive(l))
    let (r = %ToPrimitive(r))
  if (prim("typeof", l) == "string") {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else if (prim("typeof", r) == "string") {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else {
    let (lnum = prim("prim->num", l))
    let (rnum = prim("prim->num", r))
    prim("+", lnum, rnum)
  }
}

let [%mathPowCall] = func(obj, this, args) {
    let (x = %ToNumber(args["0"]))
    let (y = %ToNumber(args["1"]))

    label ret: {
        if (y != y) {
            break ret NaN
        } else { null };

        if (y == 0) {
            break ret 1
        } else { null };

        if (x != x && y != 0) {
            break ret NaN
        } else { null };

        let (absX = prim("abs", x)) {
        if (prim(">", absX, 1) && y == +inf) {
            break ret +inf
        } else { null };

        if (prim(">", absX, 1) && y == -inf) {
            break ret 0
        } else { null };

        if (absX == 1 && ((y == +inf) || (y == -inf))) {
            break ret NaN
        } else { null };

        if (prim("<", absX, 1) && y == +inf) {
            break ret 0
        } else { null };

        if (prim("<", absX, 1) && y == -inf) {
            break ret +inf
        } else { null };

        if (x == +inf && prim(">", y, 0)) {
            break ret +inf
        } else { null };

        if (x == +inf && prim("<", y, 0)) {
            break ret 0
        } else { null };

        let (isOdd = func(n) {
            let (divided = prim("/", n, 2))
            (prim("floor", n) == n) && (prim("floor", divided) != divided)
        }) {
        if (x == -inf && prim(">", y, 0)) {
            break ret if (isOdd(y)) { -inf } else { +inf }
        } else { null };

        if (x == -inf && prim("<", y, 0)) {
            break ret 0
        } else { null };

        if (x == 0 && prim(">", y, 0)) {
            break ret 0
        } else { null };

        if (x == 0 && prim("<", y, 0)) {
            break ret +inf
        } else { null };

        // If x is -0 and y<0 and y is an odd integer, the result is -inf
        // If x is -0 and y<0 and y is not an odd integer, the result +inf
        let (oddY = isOdd(y))
        if (x == 0 && prim("<", y, 0) && oddY) {
            break ret -inf
        } else { null };
        if (x == 0 && prim("<", y, 0)) {
            break ret +inf
        } else { null };

        let (isFinite = func(n) {
            n != +inf && n != -inf
        })
        let (finiteX = isFinite(x))
        let (finiteY = isFinite(y))
        if (prim("<", x, 0) && finiteX && finiteY && prim("floor", y) != y) {
            break ret NaN
        } else { null };

        break ret prim("pow", x, y)
    }}}
}

let [%mathPow] = {[#code : %mathPowCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%Math,
    "pow",
    {[] "value" : {#value %mathPow, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [%valueOfCall] = func(this, args, proto, typestr) {
  let (hasWrongProto = this[<#proto>] != proto)
  let (hasWrongTypeof = %Typeof(this) != typestr)
  let (isntProto = this != proto)
  if (hasWrongProto && hasWrongTypeof && isntProto) {
    %TypeError("valueOf")
  } else {
    if (hasWrongTypeof) { this[<primval>] } else { this }
  }
}

let [%stringValueOf] = 
  {[#code : func(obj, this, args) { 
      %valueOfCall(this, args, %StringProto, "string") 
    },
    #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%StringProto,
  "valueOf",
  {[] "value" : {#value %stringValueOf, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%numValueOf] = 
  {[#code : func(obj, this, args) { 
      %valueOfCall(this, args, %NumberProto, "number") 
    },
    #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%NumberProto,
  "valueOf",
  {[] "value" : {#value %numValueOf, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%booleanValueOf] = 
 {[#code : func(obj, this, args) { 
    %valueOfCall(this, args, %BooleanProto, "boolean")
  },
  #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%BooleanProto,
  "valueOf",
  {[] "value" : {#value %booleanValueOf, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%toFixedCall] = func(obj, this, args) {
  let (x = %numberPrimval(this))
  let (f = %ToInteger(args["0"])) {
    if (prim("<", f, 0) || prim(">", f, 20)) {
      %RangeError("invalid fractionDigits in Number.toFixed")
    };
    if (x === NaN) {
      "NaN"
    } else if (prim(">=", x, 1e21)) {
      %ToString(x)
    } else { prim("to-fixed", x, f) }
  }
}

let [%toFixed] = {[#code : %toFixedCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%toFixed,
  "length",
  {[] "value" : {#value 1, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

{%defineOwnProperty(%NumberProto,
  "toFixed",
  {[] "value" : {#value %toFixed, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%numTLSCall] = func(obj, this, args) {
  let (x = if (prim("typeof", this) == "number") { this } 
    else { this[<primval>] })
  let (obj = {[#proto : %StringProto, primval : prim("prim->str", x),]})
  %toLocaleString(obj, {[]})
}

let [%numTLS] = {[#code : %numTLSCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%NumberProto,
  "toLocaleString",
  {[] "value" : {#value %numTLS, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%toExponentialCall] = func(obj, this, args) {
  // TODO: implement
  "toExponential NYI"
}

let [%toExponential] = {[#code : %toExponentialCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%NumberProto,
  "toExponential",
  {[] "value" : {#value %toExponential, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%toPrecisionCall] = func(obj, this, args) {
  // TODO: implement
  "toPrecision NYI"
}

let [%toPrecision] = {[#code : %toPrecisionCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%NumberProto,
  "toPrecision",
  {[] "value" : {#value %toPrecision, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%SignedRightShift] = func(l, r) {
  prim(">>", %ToInt32(l), %ToUint32(r))
}

let [%LeftShift] = func(l, r) {
  prim("<<", %ToInt32(l), %ToUint32(r))
}

let [%UnsignedRightShift] = func(l, r) {
  prim(">>>", %ToUint32(l), %ToUint32(r))
}

let [%PrepostOp] = func(obj, fld, op, is_pre) {
  let (oldValue = %ToNumber(%GetField(obj, fld)))
  let (newValue = op(oldValue, 1)) {
    %set-property(obj, fld, newValue);
    if (is_pre) { newValue } else { oldValue }
  }
}

let [%PrimMultOp] = func(l, r, op) {
  op(%ToNumber(l), %ToNumber(r))
}

let [%NumberCompareOp] = func(l, r) {
  if (l === NaN || r === NaN) { undefined }
  else if (l === r) { false }
  else if (l === 0 && r === -0) { false }
  else if (l === -0 && r === 0) { false }
  else if (l === +inf) { false }
  else if (r === +inf) { true }
  else if (r === -inf) { false }
  else if (l === -inf) { true }
  else { prim("<", l, r) }
}

let [%PrimitiveCompareOp] = func(l, r) {
  if (typeof l == "string" && typeof r == "string") { prim("string<", l, r) }
  else { %NumberCompareOp(prim("prim->num", l), prim("prim->num", r)) }
}

let [%CompareOp] = func(l, r, swap, neg) {
  let (px = %ToPrimitive(l))
  let (py = %ToPrimitive(r))
  let (res = if (swap) { %PrimitiveCompareOp(py, px) } else { %PrimitiveCompareOp(px, py) })
  if (res == undefined) { false }
  else if (neg) { !res } else { res }
}

let [%BitwiseInfix] = func(l, r, op) {
  let (lnum = %ToInt32(l))
  let (rnum = %ToInt32(r))
  op(lnum, rnum)
}

// 10.2.2.1
rec [%EnvCheckAssign] = func(context, id, val, strict) {
  if (context == null) {
    if (strict) { %UnboundId(id) } else { 
      %global[id<#value> = val]
    } 
  } else if (context[<#class>] == "DeclEnvRec") {
    if (prim("hasProperty", context, id)) {
      if (context[id<#writable>]) {
        context[id<#value> = val]
      } else {
        if (strict) { %TypeError(prim("string+", id, " is read-only")) }
      }
    } else { %EnvCheckAssign(context[<parent>], id, val, strict) }
  } else if (context[<#class>] == "ObjEnvRec") {
    let (bindings = context[<bindings>]) 
    if (prim("hasProperty", bindings, id)) { %set-property(bindings, id, val) }
    else { %EnvCheckAssign(context[<parent>], id, val, strict) }
  } else { throw "[env] Context not well formed! In %EnvCheckAssign" }
}

// 10.2.2.1
rec [%EnvGet] = func(context, id, strict) {
  if (context == null) {
    %UnboundId(id) 
  } else if (context[<#class>] == "DeclEnvRec") {
    if (prim("hasProperty", context, id)) { context[id] }
    else { %EnvGet(context[<parent>], id, strict) }
  } else if (context[<#class>] == "ObjEnvRec") {
    let (bindings = context[<bindings>])
    if (prim("hasProperty", bindings, id)) { bindings[id] }
    else { %EnvGet(context[<parent>], id, strict) }
  } else { throw "[env] Context not well formed! In %EnvGet" }
}

rec [%EnvTypeof] = func(context, id) {
  if (context == null) {
    "undefined"
  } else if (context[<#class>] == "DeclEnvRec") {
    if (prim("hasProperty", context, id)) { %Typeof(context[id]) }
    else { %EnvTypeof(context[<parent>], id) }
  } else if (context[<#class>] == "ObjEnvRec") {
    let (bindings = context[<bindings>])
    if (prim("hasProperty", bindings, id)) { %Typeof(bindings[id]) }
    else { %EnvTypeof(context[<parent>], id) }
  } else { throw "[env] Context not well formed! In %EnvTypeof" }
}

rec [%EnvDelete] = func(context, id, strict) {
  if (strict) { %SyntaxError("unqualified name delete in strict mode") };
  if (context == null) {
    true
  } else if (context[<#class>] == "DeclEnvRec") {
    if (prim("hasProperty", context, id)) { 
        try { context[delete id]; true } catch { func(e) { false } } 
    } else { %EnvDelete(context[<parent>], id, strict) }
  } else if (context[<#class>] == "ObjEnvRec") {
    let (bindings = context[<bindings>])
    if (prim("hasProperty", bindings, id)) { %Delete(bindings, id, false) }
    else { %EnvDelete(context[<parent>], id, strict) }
  } else { throw "[env] Context not well formed! In %EnvDelete" }
}

let [%EnvPrepostOp] = func(context, id, op, is_pre, strict) {
  let (oldValue = %ToNumber(%EnvGet(context, id, strict)))
  let (newValue = op(oldValue, 1)) {
    %EnvCheckAssign(context, id, newValue, strict);
    if (is_pre) { newValue } else { oldValue }
  }
}

let [%EnvImplicitThis] = func(context) {
  if (context[<#class>] == "DeclEnvRec") {
    undefined
  } else if (context[<#class>] == "ObjEnvRec") {
    if (context[<provideThis>]) { context[<bindings>] } else { undefined }
  } else { throw "[env] Context not well formed! In %EnvImplicitThis" }
}

// 10.2.2.3
let [%newObjEnvRec] = func(parent, obj, pt) {
  {[parent: parent, #class: "ObjEnvRec", #extensible: true,
    bindings: obj,
    provideThis: pt]}
}

let [%newDeclEnvRec] = func(parent) {
  {[parent: parent, #class: "DeclEnvRec", #extensible: true]}
}

let [%DeclEnvAddBinding] = func(context, name, val, mutable, deletable) {
  %AddDataField(context, name, val, mutable, true, deletable)
}

// The global environment (10.2.3)
let [%globalContext] = %newObjEnvRec(null, %global, false)

// based on 10.5, 10.2.1.1.2 and 10.2.1.2.2
let [%defineGlobalVar] = func(context, id, configurableBindings) {
  if (context[<#class>] == "DeclEnvRec") {
    if (prim("!", prim("hasProperty", context, id))) {
      context[id<#configurable> = true];
      context[id<#writable> = true];
      context[id<#value> = undefined];
      context[id<#enumerable> = true];
      context[id<#configurable> = configurableBindings]
    }
  } else if (context[<#class>] == "ObjEnvRec") {
    let (bindings = context[<bindings>]) 
    if (prim("!", prim("hasProperty", bindings, id))) {
      bindings[id<#configurable> = true];
      bindings[id<#writable> = true];
      bindings[id<#value> = undefined];
      bindings[id<#enumerable> = true];
      bindings[id<#configurable> = configurableBindings] 
    }
  } else { throw "[env] Context not well formed!" }
}

let [%defineFunction] = func(context, id, fo, configurableBindings) {
  // TODO make this right
  %defineGlobalVar(context, id, configurableBindings);
  %EnvCheckAssign(context, id, fo, true)
}

// 11.4.6
let [%UnaryPlus] = func(expr) {
  %ToNumber(expr)
}

// 11.4.7
let [%UnaryNeg] = func(expr) {
  -%ToNumber(expr)
}

let [%BitwiseNot] = func(expr) {
  prim("~", %ToInt32(expr))
}

let [%UnaryNot] = func(expr) {
  !%ToBoolean(expr)
}

let [%logCall] = func(o, s) {
  rec (loop = func(i) {
    if (prim("hasProperty", s, prim("prim->str", i))) {
      prim("pretty", s[prim("prim->str", i)]);
      loop(prim("+", i, 1))
    } else {
      undefined
    }
  })  
  loop(0)
}

let [%log] = { [#code : %logCall, #proto: %FunctionProto, #class: "Function"] }

let [%console] = {
  [#proto: null,]
  "log": {#value %log, #writable false},
  "info": {#value %log, #writable false},
  "warn": {#value %log, #writable false},
  "error": {#value %log, #writable false}
}

let [%configurableEval] = func(evalThis, evalContext, useStrict, args) {
  let (evalStr = args["0"])
  let (evalStr = if (useStrict) {
    prim("string+", "'use strict';", evalStr)
  } else {
    evalStr
  })
  let (globalEnv = %makeGlobalEnv['make']) {
    globalEnv["$this"<#value> = evalThis];
    globalEnv["nonstrictContext"<#value> = evalContext];
    globalEnv["strictContext"<#value> = %newDeclEnvRec(evalContext)];
    globalEnv["evalCode"<#value> = true];
    if (typeof evalStr == 'string') {
      let (ret = @eval(evalStr, globalEnv))
      if (ret == empty) { undefined } else { ret }
    } else {
      evalStr
    }
  }
}

let [%evalCall] = func(obj, this, args) {
  %configurableEval(%global, %globalContext, false, args)
}

let [%eval] = { [#code : %evalCall, #proto: %FunctionProto, #class: "Function"] }

let [%maybeDirectEval] = func(theThis, theContext, args, strict) { 
  let (contextEval = %EnvGet(theContext, "eval", false))
  if (contextEval == %eval) {
    %configurableEval(theThis, theContext, strict, args)
  } else {
    %AppExprCheck(contextEval, undefined, args)
  }
}

let [%FunctionConstructor] = func(this, args) {
  let (argCount = %ComputeLength(args))
  rec (formArgString = func(n, result) {
    if (n == prim("-", argCount, 1)) {
      result
    } else {
      let (currentArg = %ToString(args[prim("prim->str", n)]))
      let (next = 
        if (n == prim("-", argCount, 2)) { 
          prim("string+", result, currentArg)
        } else {
          prim("string+", prim("string+", result, currentArg), ",")
        })
      formArgString(prim("+", n, 1), next)
    }
  })
  let (body = 
    if (argCount == 0) { "" } else {
      args[prim("prim->str", prim("-", argCount, 1))]
    })
  let (P = if (argCount == 0 || argCount == 1) { "" }
    else { formArgString(0, "") })
  let (prefix = 
    prim("string+", "((function(){ return function (", 
                    prim("string+", P, "){")))
  let (final = prim("string+", prefix, prim("string+", body, "}; })());")))
  %evalCall(undefined, {[] "0": {#value final, #writable false}})
}

let [%FunctionGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %FunctionProto, #class: "Function", construct: %FunctionConstructor] 
    "prototype" : {#value %FunctionProto, #writable false},
    "length" : {#value 0, #writable false}
  } {
          %FunctionProto["constructor" = %FunctionGlobalFuncObj];
          %FunctionProto["constructor"<#enumerable> = false] 
  }


let [%isFiniteCall] = func(obj, this, args) {
  %IsFinite(%ToNumber(args["0"]))
}

let [%isFinite] = {[#code : %isFiniteCall, #proto : %FunctionProto, #class: "Function"]}

let [%parseFloatCall] = func(obj, this, args) {
  "parseFloat NYI"
}

let [%parseFloat] = {[#code : %parseFloatCall, #proto : %FunctionProto, #class: "Function"]}

{
  %global["window" = %global];
  %global["print" = %print];
  %global["console" = %console];
  %global["Array" = %ArrayGlobalFuncObj];
  %global["Array"<#enumerable> = false];
  %global["String" = %StringGlobalFuncObj];
  %global["String"<#enumerable> = false];
  %global["Object" = %ObjectGlobalFuncObj];
  %global["Object"<#enumerable> = false];
  %global["Number" = %NumberGlobalFuncObj];
  %global["Number"<#enumerable> = false];
  %global["Boolean" = %BooleanGlobalFuncObj];
  %global["Boolean"<#enumerable> = false];
  %global["Date" = %DateGlobalFuncObj];
  %global["Date"<#enumerable> = false];
  %global["Function" = %FunctionGlobalFuncObj];
  %global["Function"<#enumerable> = false];
  %global["isNaN" = %isNaN];
  %global["isNaN"<#enumerable> = false];
  %global["isFinite" = %isFinite];
  %global["isFinite"<#enumerable> = false];
  %global["Math" = %Math];
  %global["Math"<#enumerable> = false];
  %global["parseInt" = %parseInt];
  %global["parseInt"<#enumerable> = false];
  %global["parseFloat" = %parseFloat];
  %global["parseFloat"<#enumerable> = false];
  %global["decodeURI" = %decodeURI];
  %global["decodeURI"<#enumerable> = false];
  %global["decodeURIComponent" = %decodeURIComponent];
  %global["decodeURIComponent"<#enumerable> = false];
  %global["encodeURI" = %encodeURI];
  %global["encodeURI"<#enumerable> = false];
  %global["encodeURIComponent" = %encodeURIComponent];
  %global["encodeURIComponent"<#enumerable> = false];
  %global["TypeError" = %TypeErrorGlobalFuncObj];
  %global["TypeError"<#enumerable> = false];
  %global["ReferenceError" = %ReferenceErrorGlobalFuncObj];
  %global["ReferenceError"<#enumerable> = false];
  %global["SyntaxError" = %SyntaxErrorGlobalFuncObj];
  %global["SyntaxError"<#enumerable> = false];
  %global["RangeError" = %RangeErrorGlobalFuncObj];
  %global["RangeError"<#enumerable> = false];
  %global["EvalError" = %EvalErrorGlobalFuncObj];
  %global["EvalError"<#enumerable> = false];
  %global["URIError" = %URIErrorGlobalFuncObj];
  %global["URIError"<#enumerable> = false];
  %global["Error" = %ErrorGlobalFuncObj];
  %global["Error"<#enumerable> = false];
  %global["RegExp" = %RegExpGlobalFuncObj];
  %global["RegExp"<#enumerable> = false];

  %ObjectProto["propertyIsEnumerable" = %propertyIsEnumerable];
  %ObjectProto["propertyIsEnumerable"<#enumerable> = false]
}

{%global["eval" = %eval];
 %global["eval"<#enumerable> = false]}

{%global["NaN" = NaN];
 %global["NaN"<#enumerable> = false];
 %global["NaN"<#configurable> = false];
 %global["NaN"<#writable> = false]}

{%global["Infinity" = +inf];
 %global["Infinity"<#enumerable> = false];
 %global["Infinity"<#configurable> = false];
 %global["Infinity"<#writable> = false]}

{%global["undefined" = undefined];
 %global["undefined"<#enumerable> = false];
 %global["undefined"<#configurable> = false];
 %global["undefined"<#writable> = false]}

let [%escapeCall] = func(obj, this, args) {
  "escape NYI"
}

let [%escape] = {[#code : %escapeCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%global,
  "escape",
  {[] "value" : {#value %escape, #writable true},
      "enumerable" : {#value false, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

let [%unescapeCall] = func(obj, this, args) {
  "unescape NYI"
}

let [%unescape] = {[#code : %unescapeCall, #proto : %FunctionProto, #class: "Function"]}

{%defineOwnProperty(%global,
  "unescape",
  {[] "value" : {#value %unescape, #writable true},
      "enumerable" : {#value false, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

{(/*:START SYM EVAL*/0)}

// Set up global environment
let [strictContext] = %globalContext
let [nonstrictContext] = %globalContext
let [$this] = %global
let [evalCode] = false

