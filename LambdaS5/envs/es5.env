let [%assert] = func(b, s) {
  if (b) { true } else { throw s }
}

let [%zeroArgObj] = func() { {[]} }

let [%oneArgObj] = func(arg) {
  {[] "0": {#value arg, #writable false}}
}

let [%twoArgObj] = func(arg1, arg2) {
  {[] "0": {#value arg1, #writable false},
      "1": {#value arg2, #writable false}}
}

{(/*:START SYM EVAL*/0)}

// To be bound later
let [%makeGlobalEnv] = { [] }

let [%ObjectProto] = { [#proto : null,] }

// The global object (15.1)
let [%global] = { [#proto : %ObjectProto, #class: "GlobalObject"] }

rec [%protoOfField] = func(object, fld) {
  if (object == null) { object }
  else if (prim("hasOwnProperty", object, fld)) { object }
  else { %protoOfField(object[<#proto>], fld) }
}

{(/*:STOP SYM EVAL*/0)}

{(/*:START SYM EVAL*/0)}

let [%AppExpr] = func(fun, this, args) {
  fun(this, args)
}

{(/*:STOP SYM EVAL*/0)}

let [%ErrorProto] = 
  { [#proto : %ObjectProto, #class : "Error",]
    "name" : {#value "Error", #writable true, #enumerable false, #configurable true},
    "message" : {#value "", #writable true, #enumerable false, #configurable true}}

let [%MakeNativeErrorProto] = func(name) {
  { [#proto : %ErrorProto, #class: "Error"] 
    "name" : {#value name, #writable true, #enumerable false, #configurable true},
    "message" : {#value "", #writable true, #enumerable false, #configurable true}}
}

let [%TypeErrorProto] = %MakeNativeErrorProto("TypeError")

let [%ReferenceErrorProto] = %MakeNativeErrorProto("ReferenceError")

let [%SyntaxErrorProto] = %MakeNativeErrorProto("SyntaxError")

let [%EvalErrorProto] = %MakeNativeErrorProto("EvalError")

let [%RangeErrorProto] = %MakeNativeErrorProto("RangeError")

let [%IsJSError] = func(thing) {
  object? thing && prim("hasOwnProperty", thing, "%js-exn")
}

let [%JSError] = func(err) {
  { [#class: "JSError", #extensible: false] "%js-exn" : {#value err, #writable false, #enumerable false, #configurable false} }
}

let [%MakeNativeError] = func(proto, msg) {
  let (exc = { [#proto: proto, #class: "Error"] }) {
    if (msg != undefined) {
      exc['message'<#value> = msg];
      exc['message'<#enumerable> = false]
    };
    exc
  }
}

let [%NativeError] = func(proto, msg) {
  throw %JSError(%MakeNativeError(proto, msg))
}

let [%ReferenceError] = func(msg) {
  %NativeError(%ReferenceErrorProto, msg)
}

let [%UnboundId] = func(id) {
  %ReferenceError(prim("string+", "Unbound identifier: ", id))
}

let [%SyntaxError] = func(msg) {
  %NativeError(%SyntaxErrorProto, msg)
}

let [%TypeError] = func(msg) {
  %NativeError(%TypeErrorProto, msg)
}

let [%RangeError] = func(msg) {
  %NativeError(%RangeErrorProto, msg)
}

let [%NativeErrorOr] = func(proto, msg, v, strict) {
  if (strict) { %NativeError(proto, msg) } else { v }
}

let [%ReferenceErrorOr] = func(msg, v, strict) {
  %NativeErrorOr(%ReferenceErrorProto, msg, v, strict)
}

let [%SyntaxErrorOr] = func(msg, v, strict) {
  %NativeErrorOr(%SyntaxErrorProto, msg, v, strict)
}

let [%TypeErrorOr] = func(msg, v, strict) {
  %NativeErrorOr(%TypeErrorProto, msg, v, strict)
}

let [%RangeErrorOr] = func(msg, v, strict) {
  %NativeErrorOr(%RangeErrorProto, msg, v, strict)
}

let [%ThrowTypeErrorFun] = func(obj, this, args) {
  let (msg = args["0"<#value>])
  %TypeError(msg)
}

let [%functionToStringCall] = func(obj, this, args) {
  let (t = typeof this)
  if (t == "object") {
    if (this[<#class>] == "Function") {
      if (prim("hasInternal", this, "codetxt")) { this[<codetxt>] } else {"<internal function>"}
    } else { %TypeError("Function.prototype.toString got a non-function") }
  } else { %TypeError("Function.prototype.toString got a non-object") }
}

let [%BooleanProto] = 
  { [#proto : %ObjectProto, #class : "Boolean", primval : false,]}

let [%MakeBoolean] = func(v) {
  {[#class: "Boolean",
    #extensible: true,
    #proto: %BooleanProto,
    primval: v]}
}

let [%NumberProto] = { [#proto : %ObjectProto, #class : "Number", primval : 0,]}

let [%MakeNumber] = func(v) {
  {[#class: "Number",
    #extensible: true,
    #proto: %NumberProto,
    primval: v]}
}

let [%ToBoolean] = func(x) {
  prim("prim->bool", x)
}

// 11.4.2
let [%Void] = func(val) {
  undefined
}

// 11.4.3
let [%Typeof] = func(val) {
  let (tp = typeof val)
  if (tp == "object") {
    if (val[<#code>] == undefined) { "object" } else { "function" }
  } else if (tp == "undefined") { "undefined" } 
  else if (tp == "null") { "object" }
  else if (tp == "boolean") { "boolean" }
  else if (tp == "number") { "number" }
  else if (tp == "string") { "string" }
  else { throw "[env] invalid value in %Typeof" }
}

let [%CheckObjectCoercible] = func(o) {
  if (o == undefined || o == null) {
    %TypeError("Not object coercible")
  } else { empty }
}

let [%ObjectTypeCheck] = func(o) {
  if (object? o) { 
    empty
  } else { 
    %TypeError(prim("string+", prim("prim->str", o), " is not an object")) 
  }
}

let [%IsCallable] = func(o) {
  %Typeof(o) == "function"
}

let [%ComputeLength] = func(args) {
  rec (loop = func(iter) { 
    let (strx = prim("prim->str", iter)) 
    if (prim("hasOwnProperty", args, strx)) { 
      loop(iter + 1)
    } else { 
      iter
    }
  }) { loop(0) }
}

let [%AppExprCheck] = func(fun, this, args) {
  if(%IsCallable(fun)) {
    %AppExpr(fun, this, args)
  } else {
    %TypeError("Not a function")
  } 
}

let [%GetOwnPropertyDefault] = func(obj, id, f_data, f_acc, f_undef) {
  if (prim("hasOwnProperty", obj, id)) {
    if (prim("isAccessor", obj, id)) {
      f_acc(obj[id<#getter>], obj[id<#setter>], obj[id<#enumerable>], obj[id<#configurable>])
    } else {
      f_data(obj[id<#value>], obj[id<#writable>], obj[id<#enumerable>], obj[id<#configurable>])
    }
  } else { f_undef() }
}

let [%GetOwnProperty] = func(obj, id, f_data, f_acc, f_undef) {
  if (prim("hasInternal", obj, "getprop")) {
    obj[<getprop>](obj, id, f_data, f_acc, f_undef)
  } else {
    %GetOwnPropertyDefault(obj, id, f_data, f_acc, f_undef)
  }
}

// TODO exotic objects
rec [%GetProperty] = func(obj, id, f_data, f_acc, f_undef) {
  %GetOwnProperty(obj, id, f_data, f_acc, func() {
    if (obj[<#proto>] == null) { f_undef() }
    else { %GetProperty(obj[<#proto>], id, f_data, f_acc, f_undef) }
  })
}

let [%HasProperty] = func(obj, id) {
  %GetProperty(obj, id, func(v,w,e,c) { true }, func(g,s,e,c) { true }, func(){ false })
}

let [%runConstruct] = func(constr, args) {
  constr[<construct>](constr, args)
}

// 11.2.2
let [%PrimNew] = func(constr, args) {
  if (!object? constr) { %TypeError("not a constructor") }
  else if (!prim("hasInternal", constr, "construct")) { %TypeError("not a constructor") }
  else { %runConstruct(constr, args) }
}

let [%StringIndices] = func(obj, s) {
  let (len = prim("strlen", s))
  rec (loop = func(i) {
    if (prim("<", i, len)) {
      obj[prim("prim->str", i)<#value> = prim("char-at", s, i)];
      loop(prim("+", i, 1))
    } else { undefined }
  })
  loop(0)
}

let [%ArrayIdx] = func(arr, idx) { 
    if (prim("hasOwnProperty", arr, idx)) { arr[idx<#value>] } else { undefined }
}

{(/*:START SYM EVAL*/0)}

let [%StringProto] = { [#proto : %ObjectProto, #class : "String", primval : "",] 
  "length" : {#value 0, #writable false}}

{(/*:STOP SYM EVAL*/0)}

let [%NumberToInteger] = func(num) {
  if (num === NaN) { 0 }
  else if (num == 0 || num == +inf || num == -inf) { num } 
  else { prim("sign", num) * prim("floor", prim("abs", num)) }
}

let [%GetOwnPropertyString] = func(obj, id, f_data, f_acc, f_undef) {
  %GetOwnPropertyDefault(obj, id, f_data, f_acc,
    func() {
      let (idx = %NumberToInteger(prim("prim->num", id)))
      let (str = obj[<primval>])
      let (len = prim("strlen", str))
      if (prim("prim->str", idx) != id) { 
        f_undef() 
      } else if (prim("<=", len, idx)) {
        f_undef()
      } else {
        f_data(prim("char-at", str, idx), true, false, false)
      }
    })
}

let [%MakeString] = func (v) {
  {[#class: "String", 
    #extensible: true,
    #proto: %StringProto,
    primval: v,
    getprop: %GetOwnPropertyString
    ]
    "length" : {#value prim("strlen", v), #writable true}}
}

// 9.9
let [%ToObject] = func (o) {
  let (t = typeof o) 
  if (t == "null") { 
     %TypeError("%ToObject received null")
  } else if (t == "undefined") {
    %TypeError("%ToObject received undefined")
  } else if (t == "object") {
    o
  } else if (t == "string") {
    %MakeString(o)
  } else if (t == "number") {
    %MakeNumber(o)
  } else if (t == "boolean") {
    %MakeBoolean(o)
  } else { throw "[env] Invalid type in %ToObject" }
}

// 8.12.3
let [%GetDefault] = func(obj, this, fld) {
  %GetProperty(obj, fld, 
    func(v, w, e, c) { v },
    func(g, s, e, c) { if (g == undefined) { undefined } else { %AppExpr(g, this, %zeroArgObj()) } },
    func() { undefined })
}

let [%Get] = func(obj, this, fld) {
  if (prim("hasInternal", obj, "get")) {
    obj[<get>](obj, this, fld)
  } else {
    %GetDefault(obj, this, fld)
  }
}

let [%Get1] = func(obj, fld) { %Get(obj, obj, fld) }

let [%GetPrim] = func(obj, fld) { %Get(%ToObject(obj), obj, fld) }

let [%DefaultValueDefaultSub] = func(obj, str, next) { func() {
  let (f = %Get1(obj, str))
  if (%IsCallable(f)) {
    let (res = %AppExpr(f, obj, %zeroArgObj()))
    if (primitive? res) {res } 
    else { next() }
  } else { next() }
}}

let [%DefaultValueDefault] = func(obj, hint) {
  let (met1 = if (hint == "string") { "toString" } else { "valueOf" })
  let (met2 = if (hint != "string") { "toString" } else { "valueOf" })
  %DefaultValueDefaultSub(obj, met1, %DefaultValueDefaultSub(obj, met2, func() { %TypeError("valueOf and toString both absent in DefaultValue") }))()
}

let [%DefaultValue] = func(obj, hint) {
  if (prim("hasInternal", obj, "defval")) {
    obj[<defval>](obj, hint)
  } else {
    %DefaultValueDefault(obj, hint)
  }
}

let [%ToPrimitiveHint] = func(val, hint) {
  if (object? val) {
    %DefaultValue(val, hint)
  }
  else { val }
}

let [%ToPrimitive] = func(val) {
    // TODO exception for date objects
    %ToPrimitiveHint(val, "number")
}

let [%ToString] = func(val) {
    prim("prim->str", %ToPrimitiveHint(val, "string"))
}

// 8.7.1 4
let [%GetField] = func(v, fld) {
  if (typeof v == "object") {
    %Get1(v, fld)
  } else {
    %GetPrim(v, fld)
  }
}

let [%GetOp] = func(v, fld, strict) {
  %GetField(v, fld)
}

let [%PropertyAccess] = func(cont, o, fld, strict) {
    %CheckObjectCoercible(o);
    cont(o, %ToString(fld), strict)
}

let [%AppMethodOp] = func(fargs) { func(v, fld, strict) {
  let (fun = %GetField(v, fld))
  let (args = fargs()) {
    %AppExprCheck(fun, v, args)
  }
}}

let [%resolveThis] = func(strict, obj) {
  if (strict) {
    obj
  } else {
    if ((obj == null) || (obj == undefined)) {
      %global
    } else if (typeof obj == "object") {
      obj
    } else {
      %ToObject(obj)
    }
  }
}

let [%in] = func(l, r) {
  if (!object? r) {
    %TypeError("not an object")
  } else {
    %HasProperty(r, %ToString(l))
  }
}

let [%ToNumber] = func(x) {
  prim("prim->num", %ToPrimitiveHint(x, "number"))
}

let [%ToInteger] = func(i) {
  %NumberToInteger(%ToNumber(i)) 
}

let [%instanceof] = func(l, r) {
  label ret: {
    if (%Typeof(r) != "function") {
      %TypeError("Non-function given to instanceof")
    } else { null };

    if (!object? l) {
      break ret false
    } else { null };

    let (O = %Get1(r, "prototype")) 
    if (!object? O) {
      %TypeError("Prototype was not function or object")
    } else { 
      rec (search = func(v) {
        let (vp = v[<#proto>])
        if (vp == null) {
          false
        } else {
          if (O == vp) {
            true
          } else {
            search(vp)
          }
        }
      })
      break ret search(l)
    }
  }
}

let [%AddDataField] = func(obj, name, v, w, e, c) {
  if (prim("hasOwnProperty", obj, name)) { fail("property already exists in %AddDataField") };
  obj[name<#value> = v];
  obj[name<#writable> = w];
  obj[name<#enumerable> = e];
  obj[name<#configurable> = c];
  undefined
}

let [%AddAccessorField] = func(obj, name, g, s, e, c) {
  if (prim("hasOwnProperty", obj, name)) { fail("property already exists in %AddAccessorField") };
  obj[name<#getter> = g];
  obj[name<#setter> = s];
  obj[name<#enumerable> = e];
  obj[name<#configurable> = c];
  undefined
}

let [%DefaultCall] = func(obj, this, args) {
  obj[<usercode>](obj, %resolveThis(obj[<strict>], this), args)
}

// 13.2.2
let [%DefaultConstruct] = func(constr, args) {
  let (cproto1 = %Get1(constr, "prototype"))
  let (cproto = if (object? cproto1) { cproto1 } else { %ObjectProto })
  let (newobj = {[#proto: cproto]})
  let (constr_ret = %AppExpr(constr, newobj, args))
  if (object? constr_ret) { constr_ret } else { newobj }
}

let [%FunctionProtoCall] = func(obj, this, args) { undefined }

let [%FunctionProto] = {
  [#proto: %ObjectProto, #class : "Function", #code : %FunctionProtoCall, construct: %DefaultConstruct]
  "length" : {#value 0, #writable true} }

let [%functionToString] = 
  { [#code : %functionToStringCall, #proto: %FunctionProto, #class: "Function",] 
  "length" : {#value 0, #writable false, #configurable false, #enumerable false} }

{
  %FunctionProto["toString"<#value> = %functionToString];
  %FunctionProto["toString"<#enumerable> = false]
}

let [%ThrowTypeError] = {[
    #code: %ThrowTypeErrorFun,
    #proto: %FunctionProto,
    #extensible: false,
    #class: "Function",
  ]
  "length": {#value 0, #writable false, #enumerable false, #configurable false}
}

let [%IsStrictFunction] = func(v) {
  object? v && v[<#class>] == "Function" && prim("hasInternal", v, "strict") && v[<strict>]
}

let [%GetFunction] = func(obj, this, fld) {
  let (v = %GetDefault(obj, this, fld))
  if (fld == "caller" && %IsStrictFunction(v)) {
    %TypeError("trying to get caller!")
  } else {
    v
  }
}

// 13.2
let [%MakeFunctionObject] = func(body, len, codetxt, strict) {
  let (fobj = {[#class: "Function", #proto: %FunctionProto, #code: %DefaultCall, #extensible: true, 
                                    construct: %DefaultConstruct, usercode: body, codetxt: codetxt, strict: strict, get: %GetFunction]
               "length": {#value len, #writable false, #enumerable false, #configurable false}})
  let (proto = {[#class: "Object", #proto: %ObjectProto]
                "constructor": {#value fobj, #writable true, #enumerable false, #configurable true}}) {
    %AddDataField(fobj, "prototype", proto, true, false, false);
    if (strict) {
      %AddAccessorField(fobj, "caller", %ThrowTypeError, %ThrowTypeError, false, false);
      %AddAccessorField(fobj, "arguments", %ThrowTypeError, %ThrowTypeError, false, false)
    };
    fobj
  }
}

let [%StxEq] = func(x1, x2) {
    prim("stx=", x1, x2)
}

let [%notStxEq] = func(x1, x2) { !%StxEq(x1, x2) }

// 11.9.3
rec [%EqEq] = func(x1, x2) {
    let (t1 = prim("typeof", x1))
    let (t2 = prim("typeof", x2))
    if(t1 == t2) {
        x1 == x2
    } else if((t1 == "undefined" && t2 == "null") ||
              (t1 == "null" && t2 == "undefined")) {
        true 
    } else if(t1 == "number" && t2 == "string") {
        x1 == prim("prim->num", x2) 
    } else if(t1 == "string" && t2 == "number") {
        prim("prim->num", x1) == x2 
    } else if(t1 == "boolean") {
        %EqEq(prim("prim->num", x1), x2) 
    } else if (t2 == "boolean") {
        %EqEq(x1, prim("prim->num", x2)) 
    } else if((t1 == "string" || t1 == "number") && (t2 == "object")) {
        %EqEq(x1, %ToPrimitive(x2)) 
    } else if((t2 == "string" || t2 == "number") && (t1 == "object")) {
        %EqEq(%ToPrimitive(x1), x2) 
    } else {
        false 
    }
}

let [%notEqEq] = func(x1, x2) { !%EqEq(x1, x2) }

let [%printCall] = func(obj, o, s) {
    prim("print", %ToString(s["0"<#value>]))
}

let [%print] = { [#code : %printCall, #proto: %FunctionProto, #class: "Function"] }

let [%len] = func(list) {
    rec (inner_len = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                prim("+", 1, inner_len(prim("+", 1, iter)))
            }
            else { iter }
        })
    inner_len(0)
}

let [%slice_internal] = func(list, min, max) {
    let (retObj = {[#extensible: true,]}) {
        rec (inner_slice = func(iter, ix) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                retObj[prim("prim->str", ix)<#value> = list[prim("prim->str", iter)<#value>] ];
                if(prim(">", iter, max)) { undefined }
                else { inner_slice(prim("+", iter, 1), prim("+", ix, 1)) }
            }
            else { retObj["length"<#value> = ix] }
        })
        inner_slice(min, 0);
        retObj
    }
}

let [%makeDataDescriptor] = func(v, w, e, c) {
  {[#extensible: false, #class: "PropDesc"]
    "value": {#value v, #writable false, #enumerable false, #configurable false},
    "writable": {#value w, #writable false, #enumerable false, #configurable false},
    "enumerable": {#value e, #writable false, #enumerable false, #configurable false},
    "configurable": {#value c, #writable false, #enumerable false, #configurable false}}
}

let [%defaultDataDescriptor] = func() {
  %makeDataDescriptor(undefined, false, false, false)
}

let [%makeAccessorDescriptor] = func(g, s, e, c) {
  {[#extensible: false, #class: "PropDesc"]
    "get": {#value g, #writable false, #enumerable false, #configurable false},
    "set": {#value s, #writable false, #enumerable false, #configurable false},
    "enumerable": {#value e, #writable false, #enumerable false, #configurable false},
    "configurable": {#value c, #writable false, #enumerable false, #configurable false}}
}

let [%defaultAccessorDescriptor] = func() {
  %makeAccessorDescriptor(undefined, undefined, false, false)
}

let [%makeValueOnlyDescriptor] = func(v) {
  {[#extensible: false, #class: "PropDesc"]
    "value": {#value v, #writable false, #enumerable false, #configurable false}}
}

let [%isDataDescriptor] = func(attr-obj) {
    prim("hasOwnProperty", attr-obj, "value") || prim("hasOwnProperty", attr-obj, "writable")
}

let [%isAccessorDescriptor] = func(attr-obj) {
    prim("hasOwnProperty", attr-obj, "get") || prim("hasOwnProperty", attr-obj, "set")
}

let [%isGenericDescriptor] = func(attr-obj) {
    (%isAccessorDescriptor(attr-obj) == false &&
     %isDataDescriptor(attr-obj) == false)
}

let [%descriptorFieldGet] = func(d, f, deflt) {
  if (prim("hasOwnProperty", d, f)) { d[f<#value>] } else { deflt }
} 

let [%updateDataDescriptor] = func(fd, d) {
  %makeDataDescriptor(
    %descriptorFieldGet(d, "value", fd["value"<#value>]),
    %descriptorFieldGet(d, "writable", fd["writable"<#value>]),
    %descriptorFieldGet(d, "enumerable", fd["enumerable"<#value>]),
    %descriptorFieldGet(d, "configurable", fd["configurable"<#value>]))
}

let [%updateAccessorDescriptor] = func(fd, d) {
  %makeAccessorDescriptor(
    %descriptorFieldGet(d, "get", fd["get"<#value>]),
    %descriptorFieldGet(d, "set", fd["set"<#value>]),
    %descriptorFieldGet(d, "enumerable", fd["enumerable"<#value>]),
    %descriptorFieldGet(d, "configurable", fd["configurable"<#value>]))
}

// TODO for any descriptor, not just full
let [%updateDescriptor] = func(fd, d) {
  if (%isDataDescriptor(fd)) {
    %updateDataDescriptor(fd, d)
  } else if (%isAccessorDescriptor(fd)) {
    %updateAccessorDescriptor(fd, d)
  } else {
    throw "[env] updateDescriptor: not a full descriptor"
  }
}

let [%toDataDescriptor] = func(d) {
  %updateDataDescriptor(%defaultDataDescriptor(), d)
}

let [%toAccessorDescriptor] = func(d) {
  %updateAccessorDescriptor(%defaultAccessorDescriptor(), d)
}

let [%descriptorFieldContains] = func(d1, d2, f) {
  if (prim("hasOwnProperty", d1, f)) {
    if (prim("hasOwnProperty", d2, f)) {
      prim("sameValue", d1[f<#value>], d2[f<#value>])
    } else { false }
  } else { true }
}

let [%descriptorContains] = func(d1, d2) {
  %descriptorFieldContains(d1, d2, "value") &&
  %descriptorFieldContains(d1, d2, "writable") &&
  %descriptorFieldContains(d1, d2, "get") &&
  %descriptorFieldContains(d1, d2, "set") &&
  %descriptorFieldContains(d1, d2, "enumerable") &&
  %descriptorFieldContains(d1, d2, "configurable")
}

let [%GetOwnPropertyDescriptor] = func(obj, field) {
  %GetOwnProperty(obj, field, 
    %makeDataDescriptor,
    %makeAccessorDescriptor,
    func() { undefined }
  )
}

let [%descriptorFieldNotSame] = func(fd, d, f) {
  if (prim("hasOwnProperty", d, f)) {
    !prim("sameValue", d[f<#value>], fd[f<#value>])
  } else {
    false
  }
}

let [%descriptorCantChangeEnumerable] = func(fd, d) {
  if (fd["configurable"<#value>]) { 
    false
  } else if (prim("hasOwnProperty", d, "configurable") && d["configurable"<#value>]) { 
    true
  } else {
    %descriptorFieldNotSame(fd, d, "enumerable")
  }
}

let [%descriptorCantChangeData] = func(fd, d) {
  if (fd["configurable"<#value>]) { 
    false
  } else if (fd["writable"<#value>]) {
    false 
  } else if (prim("hasOwnProperty", d, "writable") && d["writable"<#value>]) {
    true
  } else {
    %descriptorFieldNotSame(fd, d, "value")
  }
}

let [%descriptorCantChangeAccessor] = func(fd, d) {
  if (fd["configurable"<#value>]) {
    false
  } else {
    %descriptorFieldNotSame(fd, d, "get") || %descriptorFieldNotSame(fd, d, "set")
  }
}

let [%dataDescriptorWrite] = func(obj, field, fd) {
  if (!prim("hasOwnProperty", obj, field) || obj[field<#configurable>]) {
    obj[field<#writable> = true];
    obj[field<#value> = fd["value"<#value>]];
    obj[field<#writable> = fd["writable"<#value>]];
    obj[field<#enumerable> = fd["enumerable"<#value>]];
    obj[field<#configurable> = fd["configurable"<#value>]]
  } else if (!prim("isAccessor", obj, field) && obj[field<#writable>]) {
    obj[field<#value> = fd["value"<#value>]];
    obj[field<#writable> = fd["writable"<#value>]]
  };
  empty
}

let [%accessorDescriptorWrite] = func(obj, field, fd) {
  if (!prim("hasOwnProperty", obj, field) || obj[field<#configurable>]) {
    obj[field<#getter> = fd["get"<#value>]];
    obj[field<#setter> = fd["set"<#value>]];
    obj[field<#enumerable> = fd["enumerable"<#value>]];
    obj[field<#configurable> = fd["configurable"<#value>]]
  };
  empty
}

let [%descriptorWrite] = func(obj, field, fd) {
  if (%isDataDescriptor(fd)) {
    %dataDescriptorWrite(obj, field, fd)
  } else {
    %accessorDescriptorWrite(obj, field, fd)
  }
}

// 8.12.9
let [%defineOwnPropertyDefault] = func(obj, field, attr-obj, strict) {
  let (current = %GetOwnPropertyDescriptor(obj, field))
  let (reject = func(msg) { %TypeErrorOr(msg, false, strict) })
  let (accept = func(ncurrent) { %descriptorWrite(obj, field, %updateDescriptor(ncurrent, attr-obj)); true })
  if (current == undefined) {
    if (obj[<#extensible>]) {
      if (%isGenericDescriptor(attr-obj) || %isDataDescriptor(attr-obj)) {
        let (fd = %toDataDescriptor(attr-obj))
        %AddDataField(obj, field, fd["value"<#value>], fd["writable"<#value>], fd["enumerable"<#value>], fd["configurable"<#value>]); true
      } else {
        let (fd = %toAccessorDescriptor(attr-obj))
        %AddAccessorField(obj, field, fd["get"<#value>], fd["set"<#value>], fd["enumerable"<#value>], fd["configurable"<#value>]); true
      }
    } else {
      reject("defineOwnProperty: object not extensible")
    }
  } else if (%descriptorContains(attr-obj, current)) { 
    true 
  } else if (%descriptorCantChangeEnumerable(current, attr-obj)) {
    reject("defineOwnProperty: field not configurable")
  } else if (%isGenericDescriptor(attr-obj)) {
    accept(current)
  } else if (%isDataDescriptor(current) != %isDataDescriptor(attr-obj)) { 
    if (!current["configurable"<#value>]) {
      reject("defineOwnProperty: cannot change type of property")
    } else {
      if (%isDataDescriptor(current)) {
        accept(%toAccessorDescriptor(current))
      } else {
        accept(%toDataDescriptor(current))
      }
    }
  } else if (%isDataDescriptor(current) && %isDataDescriptor(attr-obj)) {
    if (%descriptorCantChangeData(current, attr-obj)) {
      reject("defineOwnProperty: cannot change data")
    } else {
      accept(current)
    }
  } else if (%isAccessorDescriptor(current) && %isAccessorDescriptor(attr-obj)) {
    if (%descriptorCantChangeAccessor(current, attr-obj)) {
      reject("defineOwnProperty: cannot change accessor")
    } else {
      accept(current)
    }
  } else {
    accept(current)
  }
}

let [%defineOwnProperty] = func(obj, field, attr-obj, strict) {
  if (prim("hasInternal", obj, "defineprop")) {
    obj[<defineprop>](obj, field, attr-obj, strict)
  } else {
    %defineOwnPropertyDefault(obj, field, attr-obj, strict)
  }
}

// 8.12.7
let [%DeleteDefault] = func(obj, fld, strict) {
  let (desc = %GetOwnPropertyDescriptor(obj, fld))
  if (desc == undefined) { true }
  else if (!desc["configurable"<#value>]) {
    if (strict) { %TypeError("unconfigurable delete in strict mode") }
    else { false }
  } else {
    if (prim("hasOwnProperty", obj, fld)) { obj[delete fld] }; true
  }
}

let [%Delete] = func(obj, fld, strict) {
  if (prim("hasInternal", obj, "del")) {
    obj[<del>](obj, fld, strict)
  } else {
    %DeleteDefault(obj, fld, strict)
  }
}

// 11.4.1 4
let [%DeleteOp] = func(obj, fld, strict) { %Delete(%ToObject(obj), fld, strict) }

// 8.12.5
let [%Put] = func(obj, this, fld, val, strict) {
  %GetOwnProperty(obj, fld,
    func(v, w, e, c) { 
      if (w) {
        if (prim("primitive?", this)) {
          %TypeErrorOr("setting a field on a transient object", empty, strict)
        } else {
          %defineOwnProperty(obj, fld, %makeValueOnlyDescriptor(val), strict); empty 
        }
      } else { 
        %TypeErrorOr("setting unwritable field", empty, strict)
      } 
    },
    func(g, s, e, c) { 
      if (s == undefined) { 
        %TypeErrorOr("setting accessor field with no setter", empty, strict) 
      } else { 
        %AppExpr(s, this, %oneArgObj(val)); empty 
      } 
    },
    func() {
      if (obj[<#proto>] == null) {
        if (obj[<#extensible>]) { 
          if (prim("primitive?", this)) {
            %TypeErrorOr("setting a field on a transient object", empty, strict)
          } else {
            %defineOwnProperty(obj, fld, %makeDataDescriptor(val, true, true, true), strict); empty 
          }
        } else { 
          %TypeErrorOr("adding a field to a non-extensible object", empty, strict) 
        }
      } else {
        %GetProperty(obj[<#proto>], fld, 
          func(v, w, e, c) { 
            if (obj[<#extensible>]) { 
              if(w) { 
                if (prim("primitive?", this)) {
                  %TypeErrorOr("setting a field on a transient object", empty, strict)
                } else {
                  %defineOwnProperty(obj, fld, %makeDataDescriptor(val, true, true, true), strict); empty 
                }
              } else { 
                %TypeErrorOr("shadowing unwritable field", empty, strict) 
              } 
            } else { 
              %TypeErrorOr("adding a field to a non-extensible object", empty, strict) 
            } 
          },
          func(g, s, e, c) { if (s == undefined) { %TypeErrorOr("setting accessor field with no setter", empty, strict) } else { %AppExpr(s, this, %oneArgObj(val)); empty } },
          func() { 
            if (obj[<#extensible>]) { 
              if (prim("primitive?", this)) {
                %TypeErrorOr("setting a field on a transient object", empty, strict)
              } else {
                %defineOwnProperty(obj, fld, %makeDataDescriptor(val, true, true, true), strict); empty 
              }
            } else { 
              %TypeErrorOr("adding a field to a non-extensible object", empty, strict)
            } })
      }
    })
}

let [%Put1] = func(obj, fld, val, strict) { %Put(obj, obj, fld, val, strict) }

let [%PutPrim] = func(v, fld, val, strict) { %Put(%ToObject(v), v, fld, val, strict) }

let [%SetField] = func(v, fld, val, strict) {
  if (typeof v == "object") {
    %Put1(v, fld, val, strict)
  } else {
    %PutPrim(v, fld, val, strict)
  }
}

let [%SetOp] = func(val_thunk) { func(v, fld, strict) {
  let (val = val_thunk()) {
    %SetField(v, fld, val, strict); val
  }
}}

let [%ModifyOp] = func(op, val_thunk) { func(v, fld, strict) {
  let (val = op(%GetField(v, fld), val_thunk())) {
    %SetField(v, fld, val, strict); val
  }
}}

// Defines a property on an object from section 15.
// If given attributes, uses them, otherwise, uses the defaults
// as specified at the end of the intro to 15:
//    Every other property described in this clause has the attributes 
//    { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } 
//    unless otherwise specified.
let [%define15Property] = func(obj, field, prop) {
  %AddDataField(obj, field, prop, true, false, true)
}

// 8.10.5
let [%ToPropertyDescriptor] = func(propobj) {
  %ObjectTypeCheck(propobj);
  let (attrobj = {[#extensible: true, #class: "PropDesc"]}) {
    if (%HasProperty(propobj, "enumerable")) {
      %AddDataField(attrobj, "enumerable", %ToBoolean(%Get1(propobj, "enumerable")), false, false, false)
    };
    if (%HasProperty(propobj, "configurable")) {
      %AddDataField(attrobj, "configurable", %ToBoolean(%Get1(propobj, "configurable")), false, false, false)
    };
    if (%HasProperty(propobj, "value")) {
      %AddDataField(attrobj, "value", %Get1(propobj, "value"), false, false, false)
    };
    if (%HasProperty(propobj, "writable")) {
      %AddDataField(attrobj, "writable", %ToBoolean(%Get1(propobj, "writable")), false, false, false)
    };
    if (%HasProperty(propobj, "get")) {
      let (get = %Get1(propobj, "get"))
      if (%IsCallable(get) || get == undefined) { 
        %AddDataField(propobj, "get", get, false, false, false) 
      } else { %TypeError("non-function getter") }
    };
    if (%HasProperty(propobj, "set")) {
      let (set = %Get1(propobj, "set"))
      if (%IsCallable(set) || set == undefined) { 
        %AddDataField(propobj, "set", set, false, false, false)
      } else { %TypeError("non-function setter") }
    };
    if (%isDataDescriptor(attrobj) && %isAccessorDescriptor(attrobj)) {
      %TypeError("The attributes given to defineProperty were inconsistent")
    };
    attrobj[<#extensible> = false];
    attrobj
  }
}

let [%definePropertyCall] = func(obj, this, args) {
    let (obj = args["0"<#value>])
    let (field = args["1"<#value>])
    let (propobj = args["2"<#value>]) {
        %ObjectTypeCheck(obj);
        %defineOwnProperty(obj, %ToString(field), %ToPropertyDescriptor(propobj), true)
    }
}

let [%defineProperty] = { [#code : %definePropertyCall, #proto: %FunctionProto, #class: "Function"] }

let [%callCall] = func(this, args) {
  let (callArgs = %slice_internal(args, 1, %len(args))) {
    this(args["0"<#value>], callArgs)
  }
}

// http://es5.github.com/#x15.3.4.3
// 15.3.4.3 Function.prototype.apply (thisArg, argArray)
let [%applyCall] = func(this, args) {
  let (applyArgs1 = args["1"<#value>]) 
  let (applyArgs =
    if ((prim("typeof", applyArgs1) == 'undefined') || 
        applyArgs1 == null) {
      {[]}
    } else { applyArgs1 }) {
    %ObjectTypeCheck(applyArgs);
    this(args["0"<#value>], applyArgs)
  }
}


let [%call] = { [#code : %callCall, #proto : %FunctionProto, #class: "Function"] }
let [%apply] = { [#code : %applyCall, #proto : %FunctionProto, #class: "Function"] }

{%define15Property(%FunctionProto, "call", %call)}

{%define15Property(%FunctionProto, "apply", %apply)}

let [%primEach] = func(arr, fn) {
  rec (loop = func(i) {
    let (istr = %ToString(i))
    if(prim("hasOwnProperty", arr, istr)) {
      fn(%Get1(arr, istr));
      loop(prim("+", i , 1))
    } else {
      undefined
    }
  })
  loop(0)
}

// TODO: implement ForIn right
//let [%PropItr] = func(obj) {
//  let (index = 0)
//  func() { 
//    if (prim("hasOwnProperty", obj, prim("prim->str", index))) {
//      let (rval = obj[prim("prim->str", index)]) {
//        index := prim("+", index, 1);
//        rval
//      }
//    } else {
//      undefined
//    }
//  }
//}

let [%isNaNCall] = func(obj, this, args) {
    %ToNumber(args["0"<#value>]) === NaN
}

let [%isNaN] = { [#code : %isNaNCall, #proto : %FunctionProto, #class: "Function"] }

let [%etsCall] = func(obj, this, args) {
  if (!object? this) {
    %TypeError("This not object in Error.prototype.toString")
  } else {
    let (name = if (%Get1(this, "name") == undefined) { "Error" } else {
      %ToString(%Get1(this, "name")) })
    let (msg = if (%Get1(this, "message") == undefined) { "" } else {
      %ToString(%Get1(this, "message")) })
    let (c1 = name == "")
    let (c2 = msg == "")
      label ret: {
          if (c1 && c2) {
              break ret "Error"
          } else { null };
          if (c1) {
              break ret msg
          } else { null };
          if (c2) {
              break ret name
          } else { null };
          
          let (prefix = prim("string+", name, ": "))
          break ret prim("string+", prefix, msg)
      }
  }
}

let [%ets] = {[#code : %etsCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ErrorProto, "toString", %ets)}

let [%NumberCall] = func(obj, this, args) {
  if (%ComputeLength(args) == 0) { 0 } else { %ToNumber(args["0"<#value>]) }
}

let [%NumberConstructor] = func(constr, args) {
  %MakeNumber(if (%ComputeLength(args) == 0) { 0 } else { %ToNumber(args["0"<#value>]) })
}

let [%NumberGlobalFuncObj] = 
  { [#code : %NumberCall, #proto : %FunctionProto, #class: "Function", construct: %NumberConstructor]
    "prototype" : {#value %NumberProto, #writable false},
    "MAX_VALUE" : {#value 1.79769313486231571e+308, #writable false},
    "MIN_VALUE" : {#value 5.0e-324, #writable false},
    "NaN" : {#value NaN, #writable false},
    "NEGATIVE_INFINITY" : {#value -inf, #writable false},
    "POSITIVE_INFINITY" : {#value +inf, #writable false},
    "length" : {#value 1, #writable false}}

{%NumberProto["constructor"<#value> = %NumberGlobalFuncObj]}

let [%stringToStringCall] = func(obj, this, args) {
  let (t = typeof this)
  if (t == "string") { this } 
  else if (t == "object") {
    if (this[<#class>] == "String") { this[<primval>] } 
    else { %TypeError("String.prototype.toString got a non-string object") }
  } else { %TypeError("String.prototype.toString got a non-string value") }
}

let [%stringToString] = 
  { [#code : %stringToStringCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false} }

{%define15Property(%StringProto, "toString", %stringToString)}

let [%StringCall] = func(obj, this, args) {
  let (argCount = %ComputeLength(args))
  if (argCount == 0) { "" } else { %ToString(args["0"<#value>]) }
}

let [%StringConstructor] = func(constr, args) {
  %MakeString(%StringCall(undefined, undefined, args))
}

let [%StringGlobalFuncObj] = 
  { [#code : %StringCall, #proto : %FunctionProto, #class: "Function", construct: %StringConstructor]
    "length" : {#value 1, #writable false, #enumerable false, #configurable false},
    "prototype" : {#value %StringProto, #writable false, #enumerable false, #configurable false}}

let [%BooleanCall] = func(obj, this, args) {
  %ToBoolean(args["0"<#value>])
}

let [%BooleanConstructor] = func(constr, args) {
  %MakeBoolean(%ToBoolean(args["0"<#value>]))
}

let [%booleanToStringCall] = func(obj, this, args) {
  let (t = prim("typeof", this))
  let (b = if (t == "boolean") { this } else {
    if (t == "object") {
      if (this[<#class>] == "Boolean") {
        this[<primval>]
      } else { %TypeError("Boolean.prototype.toString got non-boolean object")}
    } else { %TypeError(prim("string+", "Boolean.prototype.toString got ", t)) }
  })
  if (b) { "true" } else { "false" }
}

let [%booleanToString] = 
  { [#code : %booleanToStringCall, #proto: %FunctionProto, #class: "Function",] 
    "length" : {#value 0, #writable false, #enumerable false, #configurable false} }

{%define15Property(%BooleanProto, "toString", %booleanToString)}

let [%BooleanGlobalFuncObj] = { 
  [#code : %BooleanCall, #proto : %FunctionProto, #class: "Function", construct: %BooleanConstructor] 
  "prototype" : {#value %BooleanProto, #writable false, #enumerable false, #configurable false},
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}
} 

{%define15Property(%BooleanProto, "constructor", %BooleanGlobalFuncObj)}

{%define15Property(%StringProto, "constructor", %StringGlobalFuncObj)}

let [%MakeObject] = func() {
  {[#proto: %ObjectProto]}
}

let [%ObjectCall] = func(obj, this, args) {
  if (%ComputeLength(args) == 0 || args["0"<#value>] == null || args["0"<#value>] == undefined)
  { %MakeObject() } else { %ToObject(args["0"<#value>]) }
}

let [%ObjectConstructor] = func(constr, args) {
  %ObjectCall(constr, undefined, args)
}

 let [%ObjectGlobalFuncObj] = 
  { [#code : %ObjectCall, #proto : %FunctionProto, #class: "Function", construct: %ObjectConstructor] 
    "prototype" : {#value %ObjectProto, #writable false},
    "length" : {#value 1, #writable false},
  } {
          %ObjectProto["constructor"<#value> = %ObjectGlobalFuncObj];
          %ObjectProto["constructor"<#enumerable> = false]
  }

let [%gpoCall] = func(obj, this, args) {
  let (O = args["0"<#value>]) {
     %ObjectTypeCheck(O);
     O[<#proto>]
  }
}

let [%gpo] = {[#code : %gpoCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "getPrototypeOf", %gpo)}

let [%gopdCall] = func(obj, this, args) { // TODO
  let (O = args["0"<#value>]) {
      %ObjectTypeCheck(O);
      let (name = %ToString(args["1"<#value>]))

      label ret: {
          if (prim("!", prim("hasOwnProperty", O, name))) {
              break ret undefined
          } else { null };
          
          let (obj = {[#proto : %ObjectProto,]}) {
              %defineOwnProperty(obj,
                                 "enumerable",
                                 {[] "value" : {#value O[name<#enumerable>], #writable true},
                                  "writable" : {#value true, #writable true},
                                  "enumerable" : {#value true, #writable true},
                                  "configurable" : {#value true, #writable true}}, true);
              %defineOwnProperty(obj,
                                 "configurable",
                                 {[] "value" : {#value O[name<#configurable>], #writable true},
                                  "writable" : {#value true, #writable true},
                                  "enumerable" : {#value true, #writable true},
                                  "configurable" : {#value true, #writable true}}, true);
          
              if (prim("!", prim("isAccessor", O, name))) {
                      %defineOwnProperty(obj,
                                         "value",
                                         {[] "value" : {#value %Get1(O, name), #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}}, true);
                      %defineOwnProperty(obj,
                                         "writable",
                                         {[] "value" : {#value O[name<#writable>], #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}}, true);
                  break ret obj
              } else {
                      %defineOwnProperty(obj,
                                         "get",
                                         {[] "value" : {#value O[name<#getter>], #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}}, true);
                      %defineOwnProperty(obj,
                                         "set",
                                         {[] "value" : {#value O[name<#setter>], #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}}, true);
                  break ret obj
              }
          }
      }
  }
}

let [%gopd] = {[#code : %gopdCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "getOwnPropertyDescriptor", %gopd)}

let [%objectToStringCall] = func(obj, this, args) {
    label ret: {
        if (this == undefined) {
            break ret "[object Undefined]"
        } else { undefined };
        
        if (this == null) {
            break ret "[object Null]"
        } else { undefined };
        
        let (O = %ToObject(this))
        let (class = O[<#class>])
        break ret prim("string+", "[object ", prim("string+", class, "]"))
    }
}

let [%objectToString] = 
  { [#code : %objectToStringCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false} }

let [%propEnumCall] = func(obj, this, args) {
  let (getOwnProperty = func(o, f) {
    if (prim("hasOwnProperty", o, f)) { %Get1(o, f) } else { undefined }})
  if (args["0"<#value>] == undefined) { false } else {
  let (P = %ToString(args["0"<#value>]))
  let (O = %ToObject(this))
  let (desc = getOwnProperty(O, P))
  if (desc == undefined) {
    false
  } else { 
    O[P<#enumerable>] 
  }}
}

let [%propEnum] = 
  {[#code : %propEnumCall, #proto : %FunctionProto, #class: "Function"]
    "length" : {#value 1, #writable false} }

let [%toLocaleStringCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (toString = %Get1(O, "toString"))
  if (toString[<#code>] == null) {
    %TypeError("toLocaleString")
  } else {
    toString(O, {[]})
  }
}

let [%toLocaleString] = 
  { [#code : %toLocaleStringCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false} }

let [%objectValueOfCall] = func(obj, this, args) {
  %ToObject(this)
}

let [%objectValueOf] = 
  { [#code : %objectValueOfCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false}
  }


let [%hasOwnPropertyCall] = func(obj, this, args) {
   prim("hasOwnProperty", %ToObject(this), %ToString(args["0"<#value>]))
}

let [%hasOwnProperty] = 
  { [#code : %hasOwnPropertyCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 1, #writable false}
  }


let [%isPrototypeOfCall] = func(obj, this, args) {
    rec (searchChain = func(o, v) {
      let (vproto = v[<#proto>])
      if (vproto == null) {
        false
      } else {
        if (o == vproto) {
          true
        } else {
          searchChain(o, vproto) 
        }
      }
    })
    if (!object? (args["0"<#value>])) {
      false
    } else {
      let (O = %ToObject(this))
      searchChain(O, args["0"<#value>])
    }
}

let [%isPrototypeOf] = 
  { [#code : %isPrototypeOfCall, #proto : %FunctionProto, #class: "Function"]
    "length" : {#value 1, #writable false}
  } 

{ 
  %define15Property(%ObjectProto, "toString", %objectToString);
  %define15Property(%ObjectProto, "toLocaleString", %toLocaleString);
  %define15Property(%ObjectProto, "valueOf", %objectValueOf);
  %define15Property(%ObjectProto, "hasOwnProperty", %hasOwnProperty);
  %define15Property(%ObjectProto, "isPrototypeOf", %isPrototypeOf)
}

let [%RunSelfConstructorCall] = func(obj, this, args) {
  obj[<construct>](this, args)
}

let [%NativeErrorConstructor] = func(proto) {
  func(this, args) {
    let (msg = if (prim("hasOwnProperty", args, "0")) { %ToString(args["0"<#value>]) } else { undefined })
    %MakeNativeError(proto, msg)
  }
}

let [%ErrorConstructor] = %NativeErrorConstructor(%ErrorProto)

let [%ErrorGlobalFuncObj] = 
  {[#code : %RunSelfConstructorCall, #proto : %FunctionProto, #class: "Function", construct: %ErrorConstructor]
   "prototype" : {#value %ErrorProto, #writable false}}

{%ErrorProto["constructor"<#value> = %ErrorGlobalFuncObj]}

let [%SyntaxErrorConstructor] = %NativeErrorConstructor(%SyntaxErrorProto)

let [%SyntaxErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %SyntaxErrorProto, #class: "Function", construct: %SyntaxErrorConstructor] 
    "prototype" : {#value %SyntaxErrorProto, #writable false} }

{%SyntaxErrorProto["constructor"<#value> = %SyntaxErrorGlobalFuncObj]}

let [%EvalErrorConstructor] = %NativeErrorConstructor(%EvalErrorProto)

let [%EvalErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %FunctionProto, #class: "Function", construct: %EvalErrorConstructor]
    "prototype" : {#value %EvalErrorProto, #writable false} }

{%EvalErrorProto["constructor"<#value> = %EvalErrorGlobalFuncObj]}

let [%RangeErrorConstructor] = %NativeErrorConstructor(%RangeErrorProto)

let [%RangeErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %RangeErrorProto, #class: "Function", construct: %RangeErrorConstructor] 
    "prototype" : {#value %RangeErrorProto, #writable false} }

{%RangeErrorProto["constructor"<#value> = %RangeErrorGlobalFuncObj]}

let [%ReferenceErrorConstructor] = %NativeErrorConstructor(%ReferenceErrorProto)

let [%ReferenceErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %ReferenceErrorProto, #class: "Function", construct: %ReferenceErrorConstructor] 
    "prototype" : {#value %ReferenceErrorProto, #writable false} }

{%ReferenceErrorProto["constructor"<#value> = %ReferenceErrorGlobalFuncObj]}

let [%TypeErrorConstructor] = %NativeErrorConstructor(%TypeErrorProto)

let [%TypeErrorGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %TypeErrorProto, #class: "Function", construct: %TypeErrorConstructor] 
    "prototype" : {#value %TypeErrorProto, #writable false} }

{%TypeErrorProto["constructor"<#value> = %TypeErrorGlobalFuncObj]}

{(/*:START SYM EVAL*/0)}

let [%URIErrorProto] = 
  { [#proto : %ErrorProto,]
    "name" : {#value "URIError", #writable false}}

{(/*:STOP SYM EVAL*/0)}

let [%URIErrorConstructor] = %NativeErrorConstructor(%URIErrorProto)

let [%URIErrorGlobalFuncObj] = 
  { [#code : %URIErrorConstructor, #proto : %FunctionProto, #class: "Function", construct: %URIErrorConstructor]
    "prototype" : {#value %URIErrorProto, #writable false} }

{%URIErrorProto["constructor"<#value> = %URIErrorGlobalFuncObj]}

{(/*:START SYM EVAL*/0)}

let [%ArrayProto] = { [#proto : %ObjectProto, #class : "Array",]
  "length" : {#value 0, #writable true} }

{(/*:STOP SYM EVAL*/0)}

let [%ToUint] = func(n, limit) {
  let (number = %ToNumber(n))
  if (number != number || number == 0 || number == +inf || number == -inf) { 
    0 
  } else {
    let (sign = prim("sign", number))
    let (posInt = prim("*", sign, prim("floor", prim("abs", number))))
    if (prim("<", sign, 0)) {
      let (close = prim("%", posInt, limit))
      prim("+", close, limit)
    } else { 
      prim("%", posInt, limit)
    }
  }
}

let [%ToUint32] = func(n) {
  %ToUint(n, 4294967296.0)
}

let [%ToInt32] = func(n) {
  let (int32bit = %ToUint32(n))
  if (prim(">=", int32bit, 2147483648.0)) {
    prim("-", int32bit, 4294967296.0)
  } else {
    int32bit
  }
}

let [%ToUint16] = func(n) {
  %ToUint(n, 65536.0)
}

rec [%ArrayLengthChange] = func(arr, oldlen, newlen) {
  if (prim("<", newlen, oldlen)) {
    if (%Delete(arr, prim("prim->str", %ToString(oldlen - 1)), false)) {
      %ArrayLengthChange(arr, oldlen - 1, newlen)
    } else {
      arr["length"<#value> = oldlen]; false
    }
  } else {
    arr["length"<#value> = newlen]; true
  }
}

let [%isArrayIndex] = func(v) {
  let (newlen = %ToUint32(v))
  v == %ToString(newlen) && newlen != 4294967295.0
}

let [%defineOwnPropertyArray] = func(obj, field, attr-obj, strict) {
  let (reject = func(msg) { %TypeErrorOr(msg, false, strict) })
  let (oldLen = obj["length"<#value>])
  let (oldLenWritable = obj["length"<#writable>])
  if (field == "length") {
    if (!prim("hasOwnProperty", attr-obj, "value")) { 
      %defineOwnPropertyDefault(obj, field, attr-obj, strict)
    } else {
      let (newLen = %ToUint32(attr-obj["value"<#value>]))
      let (newLenWritable = %descriptorFieldGet(attr-obj, "writable", true)) {
      if (newLen != %ToNumber(attr-obj["value"<#value>])) {
        %RangeError("invalid new array length")
      };
      if (%descriptorFieldGet(attr-obj, "enumerable", false)) { 
        reject("change enumerable on length") 
      } else if (%descriptorFieldGet(attr-obj, "configurable", false)) {
        reject("change configurable on length")
      } else if (newLen == oldLen) {
        if (!oldLenWritable && %descriptorFieldGet(attr-obj, "writable", false)) {
          reject("change writable on unwritable length")
        } else {
          if (oldLenWritable && !newLenWritable) {
            obj["length"<#writable> = false]
          };
          true
        }
      } else if (!oldLenWritable) {
        reject("change on unwritable length")
      } else {
        let (resizeSucceeded = %ArrayLengthChange(obj, oldLen, newLen)) {
          if (oldLenWritable && !newLenWritable) {
            obj["length"<#writable> = false]
          };
          if (resizeSucceeded) {
            true
          } else {
            reject("resized array with undeletable fields")
          }
        }
      }
    }}
  } else if (%isArrayIndex(field)) {
    let (idx = %ToUint32(field))
    if (prim(">=", idx, oldLen) && !oldLenWritable) {
      reject()
    } else {
      let (succeeded = %defineOwnPropertyDefault(obj, field, attr-obj, false))
      if (!succeeded) {
        reject()
      } else {
        if (prim(">=", idx, oldLen)) {
          obj["length"<#value> = idx+1]
        };
        true
      }
    }
  } else {
    %defineOwnPropertyDefault(obj, field, attr-obj, strict)
  }
}

let [%MakeArray] = func(len) {
  {[#proto: %ArrayProto, #class: "Array", defineprop: %defineOwnPropertyArray] "length": {#value len, #writable true}}
}

let [%gopnCall] = func(obj, this, args) {
  let (O = args["0"<#value>]) {
      %ObjectTypeCheck(O);
      let (props = get-own-field-names(O))
      let (len = props["length"<#value>])
      let (A = %MakeArray(len))
      rec (loop = func(i) {
          if (prim("<", i, len)) {
              let (to = prim("prim->str", i))
              let (from = prim("prim->str", prim("-", len, prim("+", i, 1))))
              A[to<#value> = %Get1(props, from)];
              loop(prim("+", i, 1))
          } 
      }) {
          loop(0);
          A
      }
  }
}

let [%gopn] = {[#code : %gopnCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "getOwnPropertyNames", %gopn)}

{%define15Property(%ObjectGlobalFuncObj, "defineProperty", %defineProperty)}

let [%definePropertiesCall] = func(obj, this, args) {
  let (O = args["0"<#value>]) {
          %ObjectTypeCheck(O);
      let (props = %ToObject(args["1"<#value>]))
      let (names = get-own-field-names(props))
      let (len = names["length"<#value>])
      rec (loop = func(i) {
          label ret: {
              if (prim("<", i, len)) {
                  let (indx = prim("prim->str", i))
                  let (name = %Get1(names, indx))
                  if (props[name<#enumerable>]) {
                      let (argsObj = {[]}) {
                          argsObj["0"<#value> = O];
                          argsObj["1"<#value> = name];
                          argsObj["2"<#value> = %Get1(props, name) ];
                          argsObj["length"<#value> = 3];
                              %defineProperty(null, argsObj);
                          break ret loop(prim("+", i, 1))
                      }
                  } else {
                      break ret loop(prim("+", i, 1))
                  }
              } else { break ret undefined }
          }})
      loop(0);
      O
  }
}

let [%defineProperties] = 
  {[#code : %definePropertiesCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "defineProperties", %defineProperties)}

let [%createCall] = func(obj, this, args) {
  let (O = args["0"<#value>])
  let (t = prim("typeof", O))
  if (t != "object" && t != "null") {
    %TypeError("Object.create failed")
  } else {
        let (obj = {[#proto : O,]}) {
            if (prim(">=", args["length"<#value>], 2) && args["1"<#value>] != undefined) {
                let (Properties = %ToObject(args["1"<#value>]))
                let (argsObj = {[]}) {
                    argsObj["0"<#value> = obj];
                    argsObj["1"<#value> = Properties];
                    argsObj["length"<#value> = 2];
                    %defineProperties(null, argsObj);
                    obj
                }
            } else {
                obj
            }
        }
  }
}

let [%create] = {[#code : %createCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "create", %create)}

let [%sealCall] = func(obj, this, args) {
    let (O = args["0"<#value>]) {
            %ObjectTypeCheck(O);
        
        let (names = get-own-field-names(O))
        let (len = names["length"<#value>])
        rec (loop = func(i) {
            if (prim("<", i, len)) {
                let (name = names[prim("prim->str", i)<#value>])
                O[name<#configurable> = false];
                loop(prim("+", i, 1))
            } else { null }
        })
        loop(0);
        O[<#extensible>=false];
        O
    }
}

let [%seal] = {[#code : %sealCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "seal", %seal)}

let [%freezeCall] = func(obj, this, args) {
  let (O = args["0"<#value>]) {
      %ObjectTypeCheck(O);

      let (names = get-own-field-names(O))
      let (len = names["length"<#value>])
      rec (loop = func(i) {
          if (prim("<", i, len)) {
              let (name = names[prim("prim->str", i)<#value>]) {
                  if (prim("!", prim("isAccessor", O, name))) {
                      if (O[name<#writable>]) {
                          O[name<#writable> = false]
                      }
                  };
                  
                  O[name<#configurable> = false];
                  loop(prim("+", i, 1))
              }
          } else { null }
      }) {
          loop(0);
          O[<#extensible> = false];
          O
      }
  }
}

let [%freeze] = {[#code : %freezeCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "freeze", %freeze)}

let [%preventExtensionsCall] = func(obj, this, args) {
    let (O = args["0"<#value>]) {
            %ObjectTypeCheck(O);
        O[<#extensible> = false];
        O
    }
}

let [%preventExtensions] = 
  {[#code : %preventExtensionsCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "preventExtensions", %preventExtensions)}

let [%isFrozenCall] = func(obj, this, args) {
    let (O = args["0"<#value>]) {
            %ObjectTypeCheck(O);
        let (names = get-own-field-names(O))
        let (len = names["length"<#value>])
        rec (loop = func(i) {
            label ret: {
                if (prim("<", i, len)) {
                    let (name = names[prim("prim->str", i)<#value>])
                    let (isData = prim("!", prim("isAccessor", O, name))) {
                    
                    if (isData && O[name<#writable>]) {
                        break ret false
                    } else { null };
                    
                    if (O[name<#configurable>]) {
                        break ret false
                    } else { null };
                    
                    break ret loop(prim("+", i, 1))
      }
                } else { break ret prim("!", O[<#extensible>]) }
            }})
        loop(0)
    }
}

let [%isFrozen] = {[#code : %isFrozenCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "isFrozen", %isFrozen)}

let [%isSealedCall] = func(obj, this, args) {
    let (O = args["0"<#value>]) {
            %ObjectTypeCheck(O);
        let (names = get-own-field-names(O))
        let (len = names["length"<#value>])
        rec (loop = func(i) {
            label ret: {
                if (prim("<", i, len)) {
                    let (name = names[prim("prim->str", i)<#value>])
                    if (O[name<#configurable>]) {
                        break ret false
                    } else { null };
                    break ret loop(prim("+", i, 1))
                } else { break ret prim("!", O[<#extensible>]) }
            }})
        loop(0)
    }
}

let [%isSealed] = {[#code : %isSealedCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "isSealed", %isSealed)}

let [%isExtensibleCall] = func(obj, this, args) {
    let (O = args["0"<#value>]) {
            %ObjectTypeCheck(O);
        O[<#extensible>]
    }
}

let [%isExtensible] = {[#code : %isExtensibleCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "isExtensible", %isExtensible)}

let [%propertyNames] = func(obj, get-non-enumerable) {
  let (aux = {[#extensible : true,]})
  rec (helper = func(obj) {
    if (obj == null) {
      undefined
    } else {
      let (cur = get-own-field-names(obj))
      let (length = cur["length"<#value>])
      rec (loop = func(i) {
        if (prim("<", i, length)) { 
          let (istr = prim("prim->str",i)) {
            if (obj[cur[istr<#value>]<#enumerable>] || get-non-enumerable) {
              aux[cur[istr<#value>]<#value> = true]
            } else {undefined };
            loop(prim("+",i,1)) 
          }
        }
        else { undefined }
      })
      loop(0);
      helper(obj[<#proto>])
    }
  }) {
    helper(obj);
    get-own-field-names(aux)
  }
}

let [%keysCall] = func(obj, this, args) {
    let (O = args["0"<#value>]) {
            %ObjectTypeCheck(O);

        let (names = get-own-field-names(O))
        let (len = names["length"<#value>])
        let (A = %MakeArray(0))
        
        rec (loop = func(i, enumCount) {
            if (prim("<", i, len)) {
                let (indx = prim("prim->str", i))
                let (name = names[indx<#value>])
                if (O[name<#enumerable>]) {
                    let (pd = {[] "value" : {#value name, #writable true},
                               "writable" : {#value true, #writable true},
                               "enumerable" : {#value true, #writable true},
                               "configurable" : {#value true, #writable true}})
                        %defineOwnProperty(A, prim("prim->str", enumCount), pd, true);
                    loop(prim("+", i, 1), prim("+", enumCount, 1))
                } else {
                    loop(prim("+", i, 1), enumCount)  
                }
            } else { A["length"<#value> = enumCount] }
        }) {
            loop(0, 0);
            A
        }
    }
}

let [%keys] = {[#code : %keysCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%ObjectGlobalFuncObj, "keys", %keys)}

let [%fromccCall] = func(obj, this, args) {
  if (args["length"<#value>] == 0) {
    ""
  } else {
    let (end = args["length"<#value>])
    rec (loop = func(i, soFar) {
      if (prim("<", i, end)) {
        let (char = prim("ascii_ntoc", %ToUint16(args[prim("prim->str", i)<#value>])))
        let (next = prim("string+", soFar, char))
        loop(prim("+", i, 1), next)
      } else { soFar }
    })
    loop(0, "")
  }
}

let [%fromCharCode] = 
  {[#code : %fromccCall, #proto : %FunctionProto, #class: "Function"]
    "length" : {#value 1, #writable false}}

{%define15Property(%StringGlobalFuncObj, "fromCharCode", %fromCharCode)}

let [%joinCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = %Get1(O, "length"))
  let (len = %ToUint32(lenVal))
  let (sep = if (args["0"<#value>] == undefined) { "," } 
    else { %ToString(args["0"<#value>]) })
    label ret: {
        if (len == 0) {
            break ret ""
        } else { null };
        rec (loop = func(k, R) {
            if (prim(">=", k, len)) {
                R
            } else {
                let (S = prim("string+", R, sep))
                let (element = %Get1(O, %ToString(k)))
                let (next =
                     if (element == null || element == undefined) { "" }
                     else { %ToString(element) })
                loop(prim("+", k, 1), prim("string+", S, next)) 
            }
        })
        let (start = if (%Get1(O, "0") == undefined || %Get1(O, "0") == null) { "" }
             else { %ToString(%Get1(O, "0")) })
        break ret loop(1, start)
    }
}

let [%join] = { [#code : %joinCall, #proto : %FunctionProto, #class: "Function"] 
                "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "join", %join)}

let [%popCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = %Get1(O, "length"))
  let (len = %ToUint32(lenVal))
  if (len == 0) {
    %Put1(O, "length", 0, true);
    undefined
  } else {
    let (indx = %ToString(prim("-", len, 1)))
      let (element = %Get1(O, indx)) {
          %Delete(O, indx, false);
          %Put1(O, "length", %ToNumber(indx), true);
          element
      }
  }
}

let [%pop] = { [#code : %popCall, #proto : %FunctionProto, #class: "Function"] 
               "length" : {#value 0, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "pop", %pop)}

let [%pushCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = %Get1(O, "length"))
  let (len = %ToUint32(lenVal))
  rec (loop = func(i, n) {
    if (prim("<", i, args["length"<#value>])) {
      let (ii = prim("prim->str", i))
      %SetField(O, %ToString(n), args[ii<#value>]);
      //O[%ToString(n) = args[ii] ];
      loop(prim("+", i, 1), prim("+", n, 1))
    } else { n }
  })
  loop(0, len)
}

let [%push] = {[#code : %pushCall, #proto : %FunctionProto, #class: "Function"]
               "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "push", %push)}

let [%reverseCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = %Get1(O, "length"))
  let (len = %ToUint32(lenVal))
  let (middle = prim("floor", prim("/", len, 2)))
  rec (loop = func(lower) {
    if (lower != middle) {
        label ret: {        
          let (upper = prim("-", prim("-", len, lower), 1))
          let (upperP = %ToString(upper))
          let (lowerP = %ToString(lower))
          let (lowerValue = %Get1(O, lowerP))
          let (upperValue = %Get1(O, upperP))
          let (lowerExists = %HasProperty(O, lowerP))
          let (upperExists = %HasProperty(O, upperP)) {
            
            if (lowerExists && upperExists) {
                %Put1(O, lowerP, upperValue, true);
                %Put1(O, upperP, lowerValue, true);
                break ret loop(prim("+", lower, 1))
            } else { null };
            
            if (upperExists) {
                %Put1(O, lowerP, upperValue, true);
                %Delete(O, upperP, false);
                break ret loop(prim("+", lower, 1))
            } else { null };
            
            if (lowerExists) {
                %Delete(O, lowerP, false);
                %Put1(O, upperP, lowerValue, true);
                break ret loop(prim("+", lower, 1))
            } else { null };
            
            break ret loop(prim("+", lower, 1))
        }
      }
    }
  }) {
      loop(0);
      O
  }
}

let [%reverse] = {[#code : %reverseCall, #proto : %FunctionProto, #class: "Function"]
                  "length" : {#value 0, #writable false, #enumerable false, #configurable false}}

{ %define15Property(%ArrayProto, "reverse", %reverse)}

let [%shiftCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = %Get1(O, "length"))
  let (len = %ToUint32(lenVal))
  if (len == 0) {
    %Put1(O, "length", 0, true);
    undefined
  } else { 
    let (first = %Get1(O, "0")) {
    rec (loop = func(k) {
        label ret: {
            if (prim(">=", k, len)) {
                break ret undefined
            } else { null };
            
            let (from = %ToString(k))
            let (to = %ToString(prim("-", k, 1)))
            let (fromPresent = %HasProperty(O, from))
            if (fromPresent) {
                let (fromVal = %Get1(O, from))
                %Put1(O, to, fromVal, true);
                break ret loop(prim("+", k, 1))
            } else {
                %Delete(O, to, false);
                break ret loop(prim("+", k, 1))
            }
        }})
    loop(1);
    let (newLen = prim("-", len, 1)) {
      %Delete(O, %ToString(newLen), false);
      %Put1(O, "length", newLen, true);
      first
    }
  }
  }
}

let [%shift] = {[#code : %shiftCall, #proto : %FunctionProto, #class: "Function"]
                "length" : {#value 0, #writable false, #enumerable false, #configurable false}}

{ %define15Property(%ArrayProto, "shift", %shift)}

let [%arrayToStringCall] = func(obj, this, args) {
  let (array = %ToObject(this))
  let (thefunc = array["join"<#value>])
  let (ffunc = 
  if (!object? thefunc) {
    %objectToStringCall
  } else {
    if (thefunc[<#code>] == null) {
      %objectToStringCall
    } else { thefunc }
  })
  ffunc(array, {[]})
}

let [%arrayToString] = 
  { [#code : %arrayToStringCall, #proto : %FunctionProto, #class: "Function"] 
    "length" : {#value 0, #writable false} }

{ %define15Property(%ArrayProto, "toString", %arrayToString) }

let [%arrayTLSCall] = func(obj, this, args) {
  let (isCallable = func(o) {
      label ret: {
          if (!object? o) {
              break ret false 
          } else { null };
          if (o[<#code>] == null) {
              break ret false
          } else { null };
          break ret true
      }})
  let (array = %ToObject(this))
  let (arrayLen = %Get1(array, "length"))
  let (len = %ToUint32(arrayLen))
  let (separator = " ")
    label ret: {
        if (len == 0) {
            break ret ""
        } else { null };
        let (firstElement = %Get1(array, "0"))
        let (R = if (firstElement == null || firstElement == undefined) { "" } else {
            let (elementObj = %ToObject(firstElement))
            let (funcc = %Get1(elementObj, "toLocaleString")) { 
              if (prim("!", isCallable(funcc))) {
                %TypeError("Not callable in ArrayTLS")
            }
            else { null };
            funcc(elementObj, {[]}) }})
        rec (inner = func(k, r) {
            if (prim(">=", k, len)) {
                r
            } else {
                let (S = prim("string+", prim("prim->str", r), separator))
                let (nextElement = %Get1(array, prim("prim->str", k)))
                let (toAppend = if (nextElement == null ||
                                    nextElement == undefined) { "" } else {
                                        let (elementObj = %ToObject(nextElement))
                                        let (funcc = %Get1(elementObj, "toLocaleString")) {
                                            if (prim("!", isCallable(funcc))) {
                                                throw %JSError({[#proto : %TypeErrorProto,]})
                                            } else { null };
                                            funcc(elementObj, {[]}) }})
                inner(prim("+", k, 1), 
                      prim("string+", prim("prim->str", r),
                           prim("prim->str", toAppend)))
            }
        })
        break ret inner(1, R)
    }
}

let [%arrayToLocaleString] = 
  { [#code : %arrayTLSCall, #proto : %FunctionProto, #class: "Function"]
    "length" : {#value 0, #writable false} }

{ %define15Property(%ArrayProto, "toLocaleString", %arrayToLocaleString) }

let [%ArrayConstructor] = func(this, args) {
  let (argCount = %ComputeLength(args))
    label ret: {
        if (prim(">=", argCount, 2)) {
            let (rtnobj = %MakeArray(0))
            rec (init = func(n) {
                rtnobj[ prim("prim->str", n)<#value> = args[prim("prim->str", n)<#value>] ];
                if (prim(">", n, 0)) {
                    init(prim("-", n, 1))
                }
            }) {
                init(argCount);
                rtnobj["length"<#value> = argCount ];
                break ret rtnobj
            }
        } else { null };
        let (c1 = prim("typeof", args["0"<#value>]) == "number")
        let (c2 = if (c1) { %ToUint32(args["0"<#value>]) != args["0"<#value>] } else { false })
        if (c2) {
            throw %JSError({[#proto : %RangeErrorProto,]})
        } else {
            if (c1) {
                break ret %MakeArray(%ToUint32(args["0"<#value>]))
            } else {
                let (rtn = %MakeArray(argCount)) {
                    %defineOwnProperty(rtn,
                                       "0",
                                       {[] "value" : {#value args["0"<#value>], #writable true},
                                        "writable" : {#value true, #writable true},
                                        "enumerable" : {#value true, #writable true},
                                        "configurable" : {#value true, #writable true}}, true);
                    break ret rtn
                }
            }
        }
    }
}

let [%concatCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = %ArrayConstructor(emptyobj, emptyobj))
  rec (procElt = func(obj, elt, n) {
    let (procNormalElt = func(nelt, k) {
      %Put1(obj, prim("prim->str", k), nelt, true);
      prim("+", k, 1)
    })
    rec (procArrayElt = func(arr, fromIndex, toIndex) {
      if (%Get1(arr, prim("prim->str", fromIndex)) == undefined) {
        toIndex
      } else {
        %Put1(obj, prim("prim->str", toIndex), %Get1(arr, prim("prim->str", fromIndex)), true);
        procArrayElt(arr, prim("+", fromIndex, 1), prim("+", toIndex, 1))
      }
    })
    if (object? elt) {
      if (elt[<#class>] == "Array") {
        procArrayElt(elt, 0, n)
      } else {
        procNormalElt(elt, n)
      }
    } else {
      procNormalElt(elt, n)
    }
  })
  rec (procAllElts = func(from, fromIndex, toIndex) {
    if (%Get1(from, prim("prim->str", fromIndex)) != undefined) {
      let (nextI = procElt(A, %Get1(from, prim("prim->str", fromIndex)), toIndex))
      procAllElts(from, prim("+", fromIndex, 1), nextI)
    } else { toIndex }
  })
  let (halftime = if (O[<#class>] == "Array") {
    procAllElts(O, 0, 0) } else { A["0"<#value> = O]; 1 })
    let (end = procAllElts(args, 0, halftime)) {
        A["length"<#value> = end];
        A
    }
}

let [%concat] = 
  { [#code : %concatCall, #proto : %FunctionProto, #class: "Function"] 
    "length": {#value 1, #writable false, #enumerable false, #configurable false}}

{ %define15Property(%ArrayProto, "concat", %concat)}

let [%sortCall] = func(obj, this, args) {
  let (obj = %ToObject(this))
  let (sortCompare = func(j, k) {
    let (jString = %ToString(j))
    let (kString = %ToString(k))

    let (hasj = %HasProperty(obj, jString))
    let (hask = %HasProperty(obj, kString))
      label ret: {
          if (hasj == false && hask == false) {
              break ret 0
          } else { null };
          
          if (hasj == false) {
              break ret 1
          } else { null };
          
          if (hask == false) {
              break ret -1
          } else { null };
          
          let (x = %Get1(obj, jString))
          let (y = %Get1(obj, kString)) {
              if (x == undefined && y == undefined) {
                  break ret 0
              } else { null };
              
              if (x == undefined) {
                  break ret 1
              } else { null };
          
              if (y == undefined) {
                  break ret -1
              } else { null };
          
              if (args["0"<#value>] != undefined) {
                  if (prim('!', %IsCallable(args["0"<#value>]))) {
                      throw %JSError({[#proto : %TypeErrorProto,]})
                  } else { null };
                  
                  break ret args["0"<#value>](undefined, 
                                      {[] "0" : {#value x, #writable true},
                                       "1" : {#value y, #writable true}})
              } else { null };
              
              let (xString = %ToString(x))
              let (yString = %ToString(y)) {
              
                  if (prim("string<", xString, yString)) {
                      break ret -1
                  } else { null };
                  
                  if (prim("string<", yString, xString)) {
                      break ret 1
                  } else { null };
                  break ret 0
              }
          }
      }})

  let (insert = func(elt, before) {
    rec (insertAndShift = func(prior, i) {
      let (indx = prim("prim->str", i))
        let (next = %Get1(obj, indx)) {
            %Put1(obj, indx, prior, true);
            if (prim("<", i, before)) {
                insertAndShift(next, prim("+", i, 1))
            } else { undefined }
        }
    })

    rec (loop = func(currIndex) {
      if (currIndex == before) {
        // elt can stay where it was
        undefined
      } else {
        let (indx = prim("prim->str", currIndex))
        let (result = sortCompare(currIndex, before))
        if (result == 1) {
          let (old = %Get1(obj, indx)) {
            %Put1(obj, indx, elt, true);
            insertAndShift(old, prim("+", currIndex, 1))
          }
        } else {
          loop(prim("+", currIndex, 1))
        }
      }
    })

    loop(0)
  }) 
  let (len = %Get1(obj, "length"))
  rec (isort = func(i) {
    if (prim("<", i, len)) {
      insert(%Get1(obj, prim("prim->str", i)), i);
      isort(prim("+", i, 1))
    } else { obj }
  })

  isort(1)
}

let [%sort] = { [#code : %sortCall, #proto : %FunctionProto, #class: "Function"] 
                "length": {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "sort", %sort)}

let [%ArrayCall] = func(obj, this, args) { %ArrayConstructor(obj, args) }

let [%ArrayGlobalFuncObj] = 
  { [#code : %ArrayCall, #proto : %FunctionProto, #class : "Function", construct: %ArrayConstructor] 
    "prototype" : {#value %ArrayProto, #writable false, #enumerable false, #configurable false},
    "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{ %define15Property(%ArrayProto, "constructor", %ArrayGlobalFuncObj) }

let [%getCurrentUTC] = func() { prim("current-utc-millis", undefined) }

let [%parse] = func(v) { 0 } // TODO: implement

let [%charAtCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"<#value>]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    ""
  } else { 
    prim("char-at", S, position)
  }
}

let [%charAt] = {[#code : %charAtCall, #proto : %FunctionProto, #class: "Function"] 
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "charAt", %charAt)}

let [%charCodeAtCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"<#value>]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    NaN
  } else { 
    prim("ascii_cton", prim("char-at", S, position))
  }
}

let [%charCodeAt] = {[#code : %charCodeAtCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "charCodeAt", %charCodeAt)}

let [%stringConcatCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (end = args["length"<#value>])
  rec (loop = func(i, soFar) {
    if (prim("<", i, end)) {
      let (next = %ToString(args[prim("prim->str", i)<#value>]))
      loop(prim("+", i, 1), prim("string+", soFar, next))
    } else { soFar }
  })
  loop(0, S)
}

let [%stringConcat] = {[#code : %stringConcatCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "concat", %stringConcat)}

let [%min] = func(a, b) {
  if (prim("<=", a, b)) { a } else { b }
}
let [%max] = func(a, b) {
  if (prim("<=", a, b)) { b } else { a }
}

let [%substringCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"<#value>]))
  let (intEnd =
    let (end = args["1"<#value>])
    if (end == undefined) { len } else { %ToInteger(end) })
  let (finalStart = %min(%max(intStart, 0), len))
  let (finalEnd = %min(%max(intEnd, 0), len))
  let (from = %min(finalStart, finalEnd))
  let (to = %max(finalStart, finalEnd))
  rec (loop = func(i, soFar) {
    if (prim("<", i, to)) {
      loop(prim("+", i, 1), prim("string+", soFar, prim("char-at", S, i)))
    } else { soFar }
  })
  loop(from, "")
}

let [%substring] = {[#code : %substringCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "substring", %substring)}

let [%spliceCall] = func(obj, this, args) {
  let (start = args["0"<#value>])
  let (deleteCount = args["1"<#value>])

  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = %MakeArray(0))
  let (lenVal = %Get1(O, "length"))
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(start))
  let (actualStart = 
    if (prim("<", relativeStart, 0)) {
      %max(prim("+", len, relativeStart), 0)
    } else {
      %min(relativeStart, len)
    })
  let (actualDeleteCount =
       %min(%max(%ToInteger(deleteCount), 0), prim("-", len, actualStart))) {

      rec (writeToALoop = func(k) {
          if (prim("<", k, actualDeleteCount)) {
              let (from = %ToString(prim("+", actualStart, k)))
              if (%HasProperty(O, from)) {
                  let (fromValue = %Get1(O, from))
                      %defineOwnProperty(A,
                                         %ToString(k),
                                         {[] "value" : {#value fromValue, #writable true},
                                          "writable" : {#value true, #writable true},
                                          "enumerable" : {#value true, #writable true},
                                          "configurable" : {#value true, #writable true}}, false);
                  A["length"<#value> = prim("+", A["length"<#value>], 1)];
                  writeToALoop(prim("+", k, 1))
              } else {
                  writeToALoop(prim("+", k, 1))
              }
          } else { undefined }
      })
      writeToALoop(0);
      
      let (itemCount = prim("-", args["length"<#value>], 2)) {
          let (step1 = func() {
              if (prim("<", itemCount, actualDeleteCount)) {
                  let (end = prim("-", len, actualDeleteCount))
                  rec (writeToOLoop = func(k) {
                      if (prim("<", k, end)) {
                          let (from = %ToString(prim("+", k, actualDeleteCount)))
                          let (to = %ToString(prim("+", k, itemCount)))
                          if (%HasProperty(O, from)) {
                              %Put1(O, to, %Get1(O, from), true);
                              writeToOLoop(prim("+", k, 1))
                          } else { 
                              %Delete(O, to, false);
                              writeToOLoop(prim("+", k, 1))
                          }
                      } else { undefined }
                  })
                  writeToOLoop(actualStart);
                  
                  let (delLimit = prim("+", prim("-", len, actualDeleteCount), itemCount))
                  rec (deleteloop = func(k) {
                      if (prim(">", k, delLimit)) {
                          let (next = prim("-", k, 1)) {
                              %Delete(O, %ToString(next), false);
                              deleteloop(next)
                          }
                      } else { undefined }
                  })
                  deleteloop(len)
              } else { null }
          })
          step1();
          
          let (step2 = func() {
              if (prim(">", itemCount, actualDeleteCount)) {
                  rec (writeToOLoop = func(k) {
                      if (prim(">", k, actualStart)) {
                          let (from = %ToString(prim("+", k, prim("-", actualDeleteCount, 1))))
                          let (to = %ToString(prim("+", k, prim("-", itemCount, 1))))
                          if (%HasProperty(O, from)) {
                              %Put1(O, to, %Get1(O, from), true);
                          writeToOLoop(prim("-", k, 1))
                          } else { 
                              %Delete(O, to, false);
                              writeToOLoop(prim("-", k, 1))
                          }
                      } else { undefined }
                  })
                  
                  writeToOLoop(prim("-", len, actualDeleteCount))
              } else {
                  undefined
              }
          })
          step2();
          
          let (outerEnd = args["length"<#value>])
          rec(outerloop = func(k, argsIndex) {
              if (prim("<", argsIndex, outerEnd)) {
                  %Put1(O, %ToString(k), args[prim("prim->str", argsIndex)<#value>], true);
                  outerloop(prim("+", k, 1), prim("+", argsIndex, 1))
              } else { undefined }
          })
          outerloop(actualStart, 2);
          %Put1("length", prim("+", prim("-", len, actualDeleteCount), itemCount), true);
          A
      }
  }
}

let [%splice] = {[#code : %spliceCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "splice", %splice)}

let [%unshiftCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = %Get1(O, "length"))
  let (len = %ToUint32(lenVal))
  let (argCount = %ComputeLength(args)) {

      rec (Oloop = func(k) {
          if (prim(">", k, 0)) {
              let (from = %ToString(prim("-", k, 1)))
              let (to = %ToString(prim("+", k, prim("-", argCount, 1))))
              if (%HasProperty(O, from)) {
                  %Put1(O, to, %Get1(O, from), true);
                  Oloop(prim("-", k, 1))
              } else { 
                  %Delete(O, to, false);
                  Oloop(prim("-", k, 1))
              }
          } else { undefined }
      })
      Oloop(len);

      let (end = %ComputeLength(args))
      rec (argsLoop = func(argsIndex, j) {
          if (prim("<", argsIndex, end)) {
              %Put1(O, %ToString(j), args[prim("prim->str", argsIndex)<#value>], true);
              argsLoop(prim("+", argsIndex, 1), prim("+", j, 1))
          } else { undefined }
      })
      argsLoop(0, 0);
      
      let (finalLen = prim("+", len, argCount)) {
          %Put1(O, "length", finalLen, true);
          finalLen
      }
    }
}

let [%unshift] = {[#code : %unshiftCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "unshift", %unshift)}

let [%arrayIndexOfCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = %Get1(O, "length"))
  let (len = %ToUint32(lenValue))

    label ret: {
        if (len == 0) {
            break ret -1
        } else { undefined };
        
        let (n = if (args["1"<#value>] == undefined) { 0 } else { %ToInteger(args["1"<#value>]) }) {
            if (prim(">=", n, len)) {
                break ret -1
            } else { undefined };
            
            rec (loop = func(k) {
                if (prim("<", k, len)) {
                    let (kStr = %ToString(k))
                    if (%HasProperty(O, kStr)) {
                        let (elementK = %Get1(O, kStr))
                        if (args["0"<#value>] == elementK) {
                            break ret k
                        } else { undefined };
                        loop(prim("+", k, 1))
                    } else { 
                        loop(prim("+", k, 1))
                    }
            } else { undefined }
            })
            let (start = if (prim(">=", n, 0)) { n } else {
                    %max(prim("-", len, prim("abs", n)), 0)
            }) {
                loop(start);
                break ret -1
            }
        }
    }
}

let [%arrayIndexOf] = {[#code : %arrayIndexOfCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "indexOf", %arrayIndexOf)}

let [%arrayLastIndexOfCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = %Get1(O, "length"))
  let (len = %ToUint32(lenValue))

    label ret: {
        if (len == 0) {
            break ret -1
        } else { undefined };
        
        let (n = if (args["1"<#value>] == undefined) { prim("-", len, 1) } 
             else { %ToInteger(args["1"<#value>]) })
        rec (loop = func(k) {
            if (prim(">=", k, 0)) {
                let (kstr = %ToString(k))
                if (%HasProperty(O, kstr)) {
                    if (%Get1(O, kstr) == args["0"<#value>]) {
                        break ret k
                    } else { loop(prim("-", k, 1)) }
                } else { loop(prim("-", k, 1)) } 
            } else { undefined }
        })
        
        let (start = if (prim(">=", n, 0)) { %min(n, prim("-", len, 1)) }
             else { prim("-", len, prim("abs", n)) })
        loop(start);
        break ret -1
    }
}

let [%arrayLastIndexOf] = {[#code : %arrayLastIndexOfCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "lastIndexOf", %arrayLastIndexOf)}

let [%foreachCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenVal = %Get1(O, "length"))
  let (len = %ToUint32(lenVal))
  let (callbackfn = args["0"<#value>])
  
  label ret: {

      if (prim('!', %IsCallable(callbackfn))) {
          %TypeError("Callback not a function in forEach")
      } else { undefined };
      
      let (T = args["1"<#value>])
      rec (loop = func(k) {
          if (prim("<", k, len)) {
              let (Pk = %ToString(k))
              if (%HasProperty(O, Pk)) {
                  let (kValue = %Get1(O, Pk))
                  let (argslist = 
                       {[] "0" : {#value kValue, #writable true},
                        "1" : {#value k, #writable true},
                        "2" : {#value O, #writable true}})
                  callbackfn(T, argslist);
                  loop(prim("+", k, 1))
              } else {
                  loop(prim("+", k, 1))
              }
          } else { undefined }
      })
      loop(0);
      undefined
  }
}

let [%foreach] = {[#code : %foreachCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "forEach", %foreach)}

let [%mapCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = %Get1(O, "length"))
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"<#value>])
  
    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
      %TypeError("Callback not a function in map")
        } else { null };
        
        let (T = args["1"<#value>])
        let (A = %MakeArray(0))
        
        rec (loop = func(k) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                if (%HasProperty(O, Pk)) {
                    let (kValue = %Get1(O, Pk))
                    let (argsObj = {[]}) {
                        argsObj["0"<#value> = kValue];
                        argsObj["1"<#value> = k];
                        argsObj["2"<#value> = O];
                        argsObj["length"<#value> = 3];
                        let (mappedValue = callbackfn(T, argsObj))
                            %defineOwnProperty(A,
                                               Pk,
                                               {[] "value" : {#value mappedValue, #writable true},
                                                "writable" : {#value true, #writable true},
                                                "enumerable" : {#value true, #writable true},
                                                "configurable" : {#value true, #writable true}}, false);
                        loop(prim("+", k, 1))
                    }
                } else {
                    loop(prim("+", k, 1))  
                }
            } else { A["length"<#value> = k] }
        }) {
        
            loop(0);
            break ret A
        }
    }
}

let [%map] = {[#code : %mapCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "map", %map)}

let [%filterCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = %Get1(O, "length"))
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"<#value>])

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
      %TypeError("Callback not a function in filter")
        } else { null };
        
        let (T = args["1"<#value>])
  let (A = %MakeArray(0))
        
        rec (loop = func(k, to) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                if (%HasProperty(O, Pk)) {
                    let (kValue = %Get1(O, Pk))
                    let (argsObj = {[]}) {
                        argsObj["0"<#value> = kValue];
                        argsObj["1"<#value> = k];
                        argsObj["2"<#value> = O];
                        argsObj["length"<#value> = 3];
                        let (selected  = callbackfn(T, argsObj))
                        if (%ToBoolean(selected)) {
                                %defineOwnProperty(A, %ToString(to),
                                                   {[] "value" : {#value kValue, #writable true},
                                                    "writable" : {#value true, #writable true},
                                                    "enumerable" : {#value true, #writable true},
                                                    "configurable" : {#value true, #writable true}}, false);
                            loop(prim("+", k, 1), prim("+", to, 1))
                        } else {
                            loop(prim("+", k, 1), to)
                        }
                    }
                } else {
                    loop(prim("+", k, 1), to)
                }
            } else { 
                A["length"<#value> = to]
            }
        }) {
            loop(0, 0);
            break ret A
        }
    }
}

let [%filter] = {[#code : %filterCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "filter", %filter)}

let [%reduceCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = %Get1(O, "length"))
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"<#value>])
  let (has_initial = prim(">=", args["length"<#value>], 2))

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
            %TypeError("Callback not a function in reduce")
        } else { null };

        if (len == 0 && prim("!", has_initial)) {
            %TypeError("Reducing an empty list with not enough arguments.")
        } else { null };

        let (origK = if (has_initial) { -1 } else {
            rec (accumLoop = func(k) {
                if (prim("<", k, len)) {
                    let (Pk = %ToString(k))
                    let (kPresent = %HasProperty(O, Pk))
                    if (kPresent) {
                        k
                    } else {
                        accumLoop(prim("+", k, 1))
                    }
                } else { %TypeError("In Array reduce") }
            })
            accumLoop(0)
        })
        let (accumulator = if (has_initial) { args["1"<#value>] } else { %Get1(O, %ToString(origK)) }) 
        
        rec (outerLoop = func(k, accumulator) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                let (kPresent = %HasProperty(O, Pk))
                if (kPresent) {
                    let (kValue = %Get1(O, Pk))
                    let (argsObj = {[]}) {
                        argsObj["0"<#value> = accumulator];
                        argsObj["1"<#value> = kValue];
                        argsObj["2"<#value> = k];
                        argsObj["3"<#value> = O];
                        argsObj["length"<#value> = 4];
                        let (next = callbackfn(undefined, argsObj))
                        outerLoop(prim("+", k, 1), next)
                    }
                } else {
                    outerLoop(prim("+", k, 1), accumulator)
                }
            } else { accumulator }
        })

        break ret outerLoop(prim("+", origK, 1), accumulator)
    }
}

let [%reduce] = {[#code : %reduceCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "reduce", %reduce)}

let [%everyCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = %Get1(O, "length"))
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"<#value>])

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
      %TypeError("Callback not function in every")
        } else { null };

        let (T = args["1"<#value>])
        rec (loop = func(k) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                let (kPresent = %HasProperty(O, Pk))
                if (kPresent) {
                    let (kValue = %Get1(O, Pk))
                    let (argsObj = {[]}) {
                        argsObj["0"<#value> = kValue];
                        argsObj["1"<#value> = k];
                        argsObj["2"<#value> = O];
                        argsObj["length"<#value> = 3];
                        let (testResult = callbackfn(T, argsObj))
                        if (%ToBoolean(testResult) == false) {
                            false
                        } else {
                            loop(prim("+", k, 1))
                        }
                    }
                } else {
                    loop(prim("+", k, 1))
                }
            } else { true }
        })

        break ret loop(0)
    }
}

let [%every] = {[#code : %everyCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "every", %every)}

let [%someCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = %Get1(O, "length"))
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"<#value>])

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
    %TypeError("Callback not function in some")
        } else { null };

        let (T = args["1"<#value>])
        rec (loop = func(k) {
            if (prim("<", k, len)) {
                let (Pk = %ToString(k))
                let (kPresent = %HasProperty(O, Pk))
                if (kPresent) {
                    let (kValue = %Get1(O, Pk))
                    let (argsObj = {[]}) {
                        argsObj["0"<#value> = kValue];
                        argsObj["1"<#value> = k];
                        argsObj["2"<#value> = O];
                        argsObj["length"<#value> = 3];
                        let (testResult = callbackfn(T, argsObj))
                        if (%ToBoolean(testResult) == true) {
                            true
                        } else {
                            loop(prim("+", k, 1))
                        }
                    }
                } else {
                    loop(prim("+", k, 1))
                }
            } else { false }
        })

        break ret loop(0)
    }
}

let [%some] = {[#code : %someCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "some", %some)}

let [%reduceRightCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (lenValue = %Get1(O, "length"))
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"<#value>])
  let (has_initial = prim(">=", args["length"<#value>], 2))

    label ret: {
        if (prim("!", %IsCallable(callbackfn))) {
            %TypeError("Callback not function in reduceRight")
        } else { null };
        
        if (len == 0 && prim("!", has_initial)) {
            %TypeError("Zero-length array in reduceRight")
        } else { null };
        
        let (origK = if (has_initial) { len } else {
            rec (accumLoop = func(k) {
                if (prim(">=", k, 0)) {
                    let (Pk = %ToString(k))
                    let (kPresent = %HasProperty(O, Pk))
                    if (kPresent) {
                        k
                    } else {
                        accumLoop(prim("-", k, 1))
                    }
                } else { %TypeError("reduceRight") }
            })
            accumLoop(prim("-", len, 1))
        })
        let (accumulator = if (has_initial) { args["1"<#value>] } else { %Get1(O, %ToString(origK)) }) 
        
        rec (outerLoop = func(k, accumulator) {
            if (prim(">=", k, 0)) {
                let (Pk = %ToString(k))
                let (kPresent = %HasProperty(O, Pk))
                if (kPresent) {
                    let (kValue = %Get1(O, Pk))
                    let (argsObj = {[]}) {
                        argsObj["0"<#value> = accumulator];
                        argsObj["1"<#value> = kValue];
                        argsObj["2"<#value> = k];
                        argsObj["3"<#value> = O];
                        argsObj["length"<#value> = 4];
                        let (next = callbackfn(undefined, argsObj))
                        outerLoop(prim("-", k, 1), next)
                    }
                } else {
                    outerLoop(prim("-", k, 1), accumulator)
                }
            } else { accumulator }
        })
        
        break ret outerLoop(prim("-", origK, 1), accumulator)
    }
}

let [%reduceRight] = {[#code : %reduceRightCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%ArrayProto, "reduceRight", %reduceRight)}

let [%sliceCall] = func(obj, this, args) {
  let (O = %ToObject(this))
  let (A = %MakeArray(0))
  let (lenVal = %Get1(O, "length"))
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(args["0"<#value>]))

  let (initk = if (prim("<", relativeStart, 0)) {
    let (added = prim("+", len, relativeStart))
    if (prim(">", added, 0)) { added } else { 0 }
    } else {
      if (prim("<", relativeStart, len)) { relativeStart } else { len }
    })

  let (relativeEnd = if (args["1"<#value>] == undefined) { len } 
    else { %ToInteger(args["1"<#value>]) })

  let (final = if (prim("<", relativeEnd, 0)) {
    let (added = prim("+", len, relativeEnd))
    if (prim(">", added, 0)) { added } else { 0 }
  } else {
    if (prim("<", relativeEnd, len)) { relativeEnd } else { len }
  })

    rec (loop = func(n, k, finalLen) {
        label ret: {
            if (prim(">=", k, final)) {
                break ret finalLen
            } else { null };

            let (Pk = %ToString(k))
            let (kPresent = %HasProperty(O, Pk))
            if (kPresent) {
                let (kValue = %Get1(O, Pk))
                    %defineOwnProperty(A,
                                       %ToString(n),
                                       {[] "value" : {#value kValue, #writable true},
                                        "writable" : {#value true, #writable true},
                                        "configurable" : {#value true, #writable true},
                                        "enumerable" : {#value true, #writable true}}, false);
                break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
            } else {
                break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
            }
        }}) {

        A["length"<#value> = loop(0, initk, 0)];
        A
    }
}

let [%slice] = {[#code : %sliceCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{ %define15Property(%ArrayProto, "slice", %slice) }

let [%BindObjCall] = func(obj, this, args) {
    let (concatted = %concat(obj[<boundArgs>], args))
    %AppExprCheck(obj[<target>], obj[<boundThis>], concatted)
}

let [%BindConstructor] = func(constr, args) {
  let (concatted = %concat(constr[<boundArgs>], args)) // TODO concat for args objects
  %PrimNew(constr[<target>], concatted)
}

let [%MakeBind] = func(obj, this, args) {
  let (len = if (obj[<#class>] == "Function") {
    let (L = prim("-", obj["length"<#value>], args["length"<#value>])) %max(0, L)}
    else { 0 })
  {[#code: %BindObjCall, #proto: %FunctionProto, #class: "Function", construct: %BindConstructor, target: obj, boundThis: this, boundArgs: args]
    "caller": {#getter %ThrowTypeError, #setter %ThrowTypeError, #enumerable false, #configurable false},
    "arguments": {#getter %ThrowTypeError, #setter %ThrowTypeError, #enumerable false, #configurable false},
    "length": {#value len, #writable false, #enumerable false, #configurable false}}
}

let [%bindCall] = func(obj, this, args) {
    if (!%IsCallable(this)) {
      %TypeError("this not function in bind")
    };
    let (thisArg = args["0"<#value>])
    let (A = %slice(args, %oneArgObj(1))) // TODO slice for args objects
    %MakeBind(this, thisArg, A)
}

let [%bind] = {[#code : %bindCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{ %define15Property(%FunctionProto, "bind", %bind) }

let [%numToStringAbstract] = func(n, r) {
    rec (nts = func(n, r) {
        label ret: {
            if (n != n) {
                break ret "NaN"
            } else { null };

            if (n == 0) {
                break ret "0"
            } else { null };

            if (prim("<", n, 0)) {
                break ret prim("string+", "-", nts(-n, r))
            } else { null };

            if (n == +inf) {
                break ret "Infinity"
            } else { null };

            if (r == 10) {
                break ret prim("prim->str", n)
            } else { null };
            break ret prim("base", n, r)
        }})
  nts(n, r)
}

let [%numberPrimval] = func(this) {
  if (typeof this == "number") { this } else if (typeof this == "object" && this[<#class>] == "Number") { this[<primval>] } else { %TypeError("not a number") }
} 

let [%numberToStringCall] = func(obj, this, args) {
  let (val = %numberPrimval(this))
  let (rint = if (args["0"<#value>] == undefined) { 10 } else { %ToInteger(args["0"<#value>]) })
  if (prim("<", rint, 2) || prim(">", rint, 36)) {
    %RangeError("Number.toString received invalid radix")
  } else {
    %numToStringAbstract(val, rint)
  }
}

let [%numberToString] = 
  { [#code : %numberToStringCall, #proto: %FunctionProto, #class: "Function",] 
    "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%NumberProto, "toString", %numberToString)}

let [%stringIndexOfCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"<#value>]))
  let (pos = %ToInteger(args["1"<#value>]))
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j == searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) != prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim(">", prim("+", curr, searchLen), len)) { -1 } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("+", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%stringIndexOf] = { [#code : %stringIndexOfCall, #proto : %FunctionProto, #class: "Function"]
                         "length": {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "indexOf", %stringIndexOf)}

let [%replaceCall] = func(obj, this, args) {
  let (S = %ToString(this))
  let (search = %ToString(args["0"<#value>]))
  let (replace = args["1"<#value>])
  if(prim("!", %IsCallable(replace))) { throw "String.replace() only supports functions" }
  else {
    rec (loop = func(str) {
      let (start = %stringIndexOf(str, %oneArgObj(search))) {
        if (start == -1) { str }
        else {
          let (replaced = %ToString(replace(undefined, %oneArgObj(replace))))
          let (before = %substring(str, %twoArgObj(0, start)))
          let (afterix = prim("+", start, prim("strlen", search)))
          let (after = %substring(str, %oneArgObj(afterix))) {
            prim("string+", before,
              prim("string+", replaced,
              loop(after)))
          }
        }
      }
    }) {
      loop(S)
    }
  }
}

let [%replace] = { [#code : %replaceCall, #proto : %FunctionProto, #class: "Function"] 
                   "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "replace", %replace)}

let [%stringLastIndexOfCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"<#value>]))
  let (numPos = %ToNumber(args["1"<#value>]))
  let (pos = 
    if (numPos != numPos) { 
      +inf
    } else { %ToInteger(numPos) })
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j == searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) != prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim("<", curr, 0)) { -1 } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("-", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%stringLastIndexOf] = {[#code : %stringLastIndexOfCall, #proto : %FunctionProto, #class: "Function"]
                            "length": {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "lastIndexOf", %stringLastIndexOf)}

let [%localeCompareCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (That = %ToString(args["0"<#value>]))
  prim("locale-compare", S, That)
}

let [%localeCompare] = {[#code : %localeCompareCall, #proto : %FunctionProto, #class: "Function"]
                        "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "localeCompare", %localeCompare)}

let [%stringSliceCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"<#value>]))
  let (end = args["1"<#value>])
  let (intEnd = if (end == undefined) { len } else { %ToInteger(end) })
  let (from = if (prim("<", intStart, 0)) { 
    %max(prim("+", len, intStart), 0) } else { %min(intStart, len) })
  let (to = if (prim("<", intEnd, 0)) { 
    %max(prim("+", len, intEnd), 0) } else { %min(intEnd, len) })
  let (span = %max(prim("-", to, from), 0))
  rec (build = func(i, result) {
    if (prim("<", i, span)) {
      let (next = prim("string+", result, prim("char-at", S, prim("+", from, i))))
      build(prim("+", i, 1), next)
    } else { result }
  })
  build(0, "")
}

let [%stringSlice] = {[#code : %stringSliceCall, #proto : %FunctionProto, #class: "Function"]
                      "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "slice", %stringSlice)}

let [%toLowerCaseCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-lower", S)
}

let [%toLowerCase] = {[#code : %toLowerCaseCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%StringProto, "toLowerCase",  %toLowerCase)}

let [%toUpperCaseCall] = func(obj, this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-upper", S)
}

let [%toUpperCase] = {[#code : %toUpperCaseCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%StringProto, "toUpperCase", %toUpperCase)}

// Turkish language support NYI
{%define15Property(%StringProto, "toLocaleLowerCase",  %toLowerCase)}
{%define15Property(%StringProto, "toLocaleUpperCase", %toUpperCase)}

let [%splitCall] = func(obj, this, args) {
  "String.prototype.split NYI"
}

let [%split] = {[#code : %splitCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "split", %split)}

let [%IsFinite] = func(n) {
  prim("!", (n != n || n == +inf || n == -inf))
}

// http://es5.github.com/#x15.9.1.2
let [%msPerDay] = 86400000
let [%msPerHour] = 3600000
let [%msPerMin] = 60000
let [%msPerSecond] = 1000
let [%Day] = func(t) { prim("floor", prim("/", t, %msPerDay)) }
let [%TimeWithinDay] = func(t) { prim("%", t, %msPerDay) }

// http://es5.github.com/#x15.9.1.3
let [%DaysInYear] = func(y) {
  if (prim("%", y, 4) != 0) {
    365
  }
  else {
    if (prim("%", y, 400) == 0 || prim("%", y, 100) != 0) {
      366
    }
    else {
      365
    }
  }
}

// http://es5.github.com/#DayFromYear
let [%DayFromYear] = func(y) {
  let (fragment = func(offset, coefficient) {
    prim("floor", prim("/", prim("-", y, offset), coefficient))
  })
  let (base = prim("*", 365, prim("-", y, 1970)))
  let (part1 = fragment(1969, 4))
  let (part2 = fragment(1901, 100))
  let (part3 = fragment(1601, 400))
  prim("+", prim("-", prim("+", base, part1), part2), part3)
}

// http://es5.github.com/#TimeFromYear 
let [%TimeFromYear] = func(y) {
  prim("*", %msPerDay, %DayFromYear(y))
}

// http://es5.github.com/#YearFromTime
let [%YearFromTime] = func(t) {
  let (sign = prim("sign", t))
  let (start = if (sign == 1) {1969} else {1970})
  rec (loop = func(y) {
    if (prim("<=", %TimeFromYear(y), t)
        && prim(">", %TimeFromYear(prim("+", 1, y)), t)) {
      y
    }
    else {
      loop(prim("+", y, sign))
    }
  })
  loop(start)
}

// http://es5.github.com/#x15.9.1.4
let [%DayWithinYear] = func(t) {
  prim("-", %Day(t), %DayFromYear(%YearFromTime(t)))
}

// http://es5.github.com/#InLeapYear
let [%InLeapYear] = func(t) {
  if(%DaysInYear(%YearFromTime(t)) == 365) {
    0
  } else {
    1
  }
}

let [%DaysInMonth] = func(m, leap) {
  let (m = prim("%", m, 12))
  if (m == 3 || m == 5 || m == 8 || m == 10) {
    30
  } else if (m == 1) {
    prim("+", 28, leap)
  } else {
    31
  }
}

// NOTE(joe): It might be obvious to others, but it wasn't to me.  Since
// January is month #0 and February is month #1, and they happen before
// the leap day, they are being treated specially by the algorithms
// below.  For March and beyond, we can generalize the behavior into
// helpers, but the first two cases both require special handling.

// http://es5.github.com/#x15.9.1.4
let [%MonthFromTime] = func(t) {
  let (DayWithinYear = func(t) {
    prim("-", %Day(t), %DayFromYear(%YearFromTime(t)))
  })
  let (CheckLeapRange = func(start, end) {
    prim("<=", prim("+", start, %InLeapYear(t)), DayWithinYear(t)) &&
    prim("<", DayWithinYear(t), prim("+", end, %InLeapYear(t)))
  })
  if (prim("<=", 0, %DayWithinYear(t)) &&
      prim("<", %DayWithinYear(t), 31)) {
    0
  } else if(prim("<=", 31, %DayWithinYear(t)) &&
            prim("<", %DayWithinYear(t), prim("+", 59, %InLeapYear(t)))) {
    1
  }
  else if(CheckLeapRange(59, 90)) { 2 }
  else if(CheckLeapRange(90, 120)) { 3 }
  else if(CheckLeapRange(120, 151)) { 4 }
  else if(CheckLeapRange(151, 181)) { 5 }
  else if(CheckLeapRange(181, 212)) { 6 }
  else if(CheckLeapRange(212, 243)) { 7 }
  else if(CheckLeapRange(243, 273)) { 8 }
  else if(CheckLeapRange(273, 304)) { 9 }
  else if(CheckLeapRange(304, 334)) { 10 }
  else if(CheckLeapRange(334, 365)) { 11 }
  else { %TypeError("Something terrible in date %MonthFromTime")}
}

// http://es5.github.com/#x15.9.1.5
let [%DateFromTime] = func(t) {
  let (mft = %MonthFromTime(t))
  let (CalcDay = func(offset) {
    prim("-", prim("-", %DayWithinYear(t), offset), %InLeapYear(t))
  })
  if (mft == 0) { prim("+", %DayWithinYear(t), 1) }
  else if (mft == 1) { prim("-", %DayWithinYear(t), 30) }
  else if (mft == 2) { CalcDay(58) }
  else if (mft == 3) { CalcDay(89) }
  else if (mft == 4) { CalcDay(119) }
  else if (mft == 5) { CalcDay(150) }
  else if (mft == 6) { CalcDay(180) }
  else if (mft == 7) { CalcDay(211) }
  else if (mft == 8) { CalcDay(242) }
  else if (mft == 9) { CalcDay(272) }
  else if (mft == 10) { CalcDay(303) }
  else if (mft == 11) { CalcDay(333) }
  else { %TypeError("Something terrible happened in %DateFromTime")}
}

let [%LocalTime] = func(t) { t }

let [%MakeDateDayTime] = func(day, time) { prim("+", prim("*", day, %msPerDay), time) }

// http://es5.github.com/#x15.9.1.12
// Implementation draws heavily from the date test harness
let [%MakeDay] = func(yr, mt, date) {
  if (prim("!", (%IsFinite(yr) && %IsFinite(mt) && %IsFinite(date)))) {
    NaN
  }
  else {
    let (y = %ToInteger(yr))
    let (m = %ToInteger(mt))
    let (dt = %ToInteger(date))
    let (ym = prim("+", y, prim("floor", prim("/", m, 12))))
    let (mn = prim("%", m, 12))
    let (yt = %TimeFromYear(y))
    rec (loop = func(t, mo, leap) {
      if(prim("<", mo, m)) {
        let (leap = %InLeapYear(t))
        let (t = prim("+", t, prim("*", %DaysInMonth(mo, leap), %msPerDay)))
        loop(t, prim("+", mo, 1), leap)
      } else {
        t
      }
    }) {
    let (t = loop(yt, 0, %InLeapYear(yt)))
    if (%YearFromTime(t) != ym ||
        %MonthFromTime(t) != mn ||
        %DateFromTime(t) != 1) {
      NaN
    } else {
      prim("-", prim("+", %Day(t), dt), 1)
    }
  }
  }
}

let [%MakeTime] = func(h, m, s, ms) {
  if (prim("!", (%IsFinite(h) && %IsFinite(m) && %IsFinite(s) && %IsFinite(ms)))) {
    NaN
  }
  else {
    let (hour = %ToInteger(h))
    let (min = %ToInteger(m))
    let (sec = %ToInteger(s))
    let (millis = %ToInteger(ms))
    let (t = prim("+",
      prim("+",
        prim("+",
          prim("*", hour, %msPerHour),
          prim("*", min, %msPerMin)),
        prim("*", sec, %msPerSecond)),
      millis)) {
      t
    }
  }

}

// http://es5.github.com/#x15.9.1.9
// S5 has no time zone adjustments or daylight savings time.
// It is, for the time being, indifferent to your i18n and l10n concerns.
let [%UTC] = func(t) { t }

let [%getYearCall] = func(obj, this, args) { 78 } // TODO: implement

let [%getYear] = { [#code : %getYearCall,] }

let [%getMonthCall] = func(obj, this, args) { 3 } // TODO: implement

let [%getMonth] = { [#code: %getMonthCall,] }

{(/*:START SYM EVAL*/0)}

let [%DateProto] = { [#proto : %ObjectProto, #class: "Date",] }

{%define15Property(%DateProto, "getYear", %getYear)}
{%define15Property(%DateProto, "getMonth", %getMonth)}

{(/*:STOP SYM EVAL*/0)}

let [%MakeDate] = func (v) {
  {[#class: "Date", 
    #extensible: true,
    #proto: %DateProto,
    primval: v]}
}

let [%dateToStringCall] = func(obj, this, args) {
  "Date toString NYI"
}

let [%dateToString] = {[#code : %dateToStringCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%DateProto, "toString", %dateToString)}

let [%dateValueOfCall] = func(obj, this, args) {
  this[<primval>]
}

let [%dateValueOf] = {[#code : %dateValueOfCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%DateProto, "valueOf", %dateValueOf) }


// http://es5.github.com/#x15.9.1.14
let [%TimeClip] = func(t) {
  if (prim("!", %IsFinite(t) &&
      prim("<=", prim("abs", t), 8.64e15))) {
    NaN
  } else {
    %ToInteger(t)
  }
}

let [%DateCall] = func(obj, this, args) {
  let (o = %MakeDate(%getCurrentUTC()))
  %dateToString(o, {[]})
}

let [%DateConstructor] = func(constr, args) {
  let (nargs = %ComputeLength(args))
  if (nargs == 0) {
    %MakeDate(%getCurrentUTC())
  }
  else if (nargs == 1) {
    let (v = %ToPrimitive(args["0"<#value>]))
    let (V =
      if (prim("typeof", v) == "string") { %parse(v) } else { %ToNumber(v) })
    let (clipped = %TimeClip(V))
    { [#proto : %DateProto, #class : "Date", #extensible : true, primval : clipped,] }
  } else {
    let (y = %ToNumber(args["0"<#value>]))
    let (m = %ToNumber(args["1"<#value>]))
    let (dt = if (args["2"<#value>] == undefined) { 1 } else { %ToNumber(args["2"<#value>]) })
    let (h = if (args["3"<#value>] == undefined) { 0 } else { %ToNumber(args["3"<#value>]) })
    let (min = if (args["4"<#value>] == undefined) { 0 } else { %ToNumber(args["4"<#value>]) })
    let (s = if (args["5"<#value>] == undefined) { 0 } else { %ToNumber(args["5"<#value>]) })
    let (milli = if (args["6"<#value>] == undefined) { 0 } else { %ToNumber(args["6"<#value>]) })
    let (yr = 
      let (tiy = %ToInteger(y))
      let (rangecond1 = prim("<", 0, tiy) || 0 == tiy)
      let (rangecond2 = prim("<", tiy, 99) || tiy == 99)
      if (y != y && rangecond1 && rangecond2) {
        prim("+", 1900, tiy) } else { y })
    let (finalDate = %MakeDateDayTime(%MakeDay(yr, m, dt), %MakeTime(h, min, s, milli)))
    let (primval = %TimeClip(%UTC(finalDate))) {
      { [#proto : %DateProto, #class : "Date", #extensible : true, primval : primval,] }
    }
  }
}

let [%DateGlobalFuncObj] = { [#code : %DateCall, #proto : %FunctionProto, #class: "Function", construct: %DateConstructor]
                             "prototype" : {#value %DateProto, #writable false, #enumerable false, #configurable false},
                             "length" : {#value 7, #writable false, #enumerable false, #configurable false} }

// http://es5.github.com/#x15.9.5.26
let [%dateGetTimezoneOffsetCall] = func(obj, this, args) {
  let (t = this[<primval>])
  if (t == NaN) { NaN }
  else {
    0
  }
}

let [%dateGetTimezoneOffset] = {[
    #code : %dateGetTimezoneOffsetCall,
    #proto : %FunctionProto,
  ]}

{%define15Property(%DateProto, "getTimezoneOffset", %dateGetTimezoneOffset)}

let [%dategetDayCall] = func(obj, this, args) {
  let (day = prim("floor", prim("/", this[<primval>], %msPerDay)))
  let (weekday = prim("%", prim("+", day, 4), 7)) {
    weekday
  }
}

let [%dategetDay] = {[#code : %dategetDayCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%DateProto, "getDay", %dategetDay)}

let [%dategetDateCall] = func(obj, this, args) {
  let (t = this[<primval>])
  if (t == NaN) { t } else { %DateFromTime(%LocalTime(t)) }
}

let [%dategetDate] = {[#code: %dategetDateCall, #proto : %FunctionProto, #class: "Function"]}

{%define15Property(%DateProto, "getDate", %dategetDate)}

let [%defineNYIProperty] = func(base, name) {
  let (unimplFunc = func(obj, this, args) {
    %TypeError(prim("string+", name, " NYI"))
  })
  let (unimplObj = {[#code: unimplFunc, #proto: %FunctionProto, #class: "Function"]})
  %define15Property(base, name, unimplObj)
}

{
  %defineNYIProperty(%DateGlobalFuncObj, "parse");
  %defineNYIProperty(%DateGlobalFuncObj, "UTC");
  %defineNYIProperty(%DateProto, "getTime");
  %defineNYIProperty(%DateProto, "getFullYear");
  %defineNYIProperty(%DateProto, "getUTCFullYear");
  %defineNYIProperty(%DateProto, "getUTCMonth");
//  %defineNYIProperty(%DateProto, "getDate");
  %defineNYIProperty(%DateProto, "getUTCDate");
  %defineNYIProperty(%DateProto, "getUTCDay");
  %defineNYIProperty(%DateProto, "getHours");
  %defineNYIProperty(%DateProto, "getUTCHours");
  %defineNYIProperty(%DateProto, "getMinutes");
  %defineNYIProperty(%DateProto, "getUTCMinutes");
  %defineNYIProperty(%DateProto, "getSeconds");
  %defineNYIProperty(%DateProto, "getUTCSeconds");
  %defineNYIProperty(%DateProto, "getMilliseconds");
  %defineNYIProperty(%DateProto, "getUTCMilliseconds");
  %defineNYIProperty(%DateProto, "setTime");
  %defineNYIProperty(%DateProto, "setMilliseconds");
  %defineNYIProperty(%DateProto, "setUTCMilliseconds");
  %defineNYIProperty(%DateProto, "setSeconds");
  %defineNYIProperty(%DateProto, "setUTCSeconds");
  %defineNYIProperty(%DateProto, "setMinutes");
  %defineNYIProperty(%DateProto, "setUTCMinutes");
  %defineNYIProperty(%DateProto, "setHours");
  %defineNYIProperty(%DateProto, "setUTCHours");
  %defineNYIProperty(%DateProto, "setDate");
  %defineNYIProperty(%DateProto, "setUTCDate");
  %defineNYIProperty(%DateProto, "setMonth");
  %defineNYIProperty(%DateProto, "setUTCMonth");
  %defineNYIProperty(%DateProto, "setFullYear");
  %defineNYIProperty(%DateProto, "setUTCFullYear");
  %defineNYIProperty(%DateProto, "toUTCString");
  %defineNYIProperty(%DateProto, "toGMTString");
  %defineNYIProperty(%DateProto, "setYear")
}

let [%testCall] = func(obj, this, args) {
  prim("print", "You used the es5.env testCall.  Are you sure you didn't forget to include the regexp.js library, or regexp.env?")
}

let [%test] = { [#code : %testCall,] }

{(/*:START SYM EVAL*/0)}

let [%RegExpProto] = { [#proto : %ObjectProto,]
  "test" : {#value %test, #writable false} }

{(/*:STOP SYM EVAL*/0)}

let [%RegExpConstructor] = func(obj, this, args) {
  {[#proto : %RegExpProto,]}
}

let [%RegExpCode] = func(obj, this, args) { %RegExpConstructor(obj, args) }

let [%RegExpGlobalFuncObj] = {[#code : %RegExpCode, #proto : %FunctionProto, #class: "Function", construct: %RegExpConstructor]
  "prototype" : {#value %RegExpProto, #writable false},
  "length" : {#value 2,
              #writable false,
              #configurable false,
              #enumerable false}}

{%RegExpProto["constructor"<#value> = %RegExpGlobalFuncObj]}

/* NOTE(Justin) Does not match spec (http://es5.github.com/#x15.1.2.2).
   We are ignoring any radix argument and using OCaml's float_of_string func. */
let [%parseIntCall] = func(obj, this, args) {
  let (numstr = %ToString(args["0"<#value>]))
  prim("prim->num", numstr)
}

let [%parseInt] = { [#code : %parseIntCall, #proto : %FunctionProto, #class: "Function"] }

let [%decodeURICall] = func(obj, this, args) {
  "decodeURI NYI"
}

let [%decodeURI] = {[#code : %decodeURICall, #proto: %FunctionProto, #class: "Function"]}

let [%decodeURIComponentCall] = func(obj, this, args) {
  "decodeURIComponent NYI"
}

let [%decodeURIComponent] = {[#code : %decodeURIComponentCall, #proto: %FunctionProto, #class: "Function"]}

let [%encodeURICall] = func(obj, this, args) {
  "encodeURI NYI"
}

let [%encodeURI] = {[#code : %encodeURICall, #proto: %FunctionProto, #class: "Function"]}

let [%encodeURIComponentCall] = func(obj, this, args) {
  "encodeURIComponent NYI"
}

let [%encodeURIComponent] = {[#code : %encodeURIComponentCall, #proto: %FunctionProto, #class: "Function"]}

let [%expCall] = func() {
  undefined
}

let [%exp] = { [#code : %expCall,] }

let [%Math] = { []
  "E" : {#value 2.7182818284590452354, #writable false},
  "LN10": {#value 2.302585092994046, #writable false},
  "LN2" : {#value 0.6931471805599453, #writable false},
  "LOG2E" : {#value 1.4426950408889634, #writable false},
  "LOG10E" : {#value 0.4342944819032518, #writable false},
  "PI" : {#value 3.141592653589793, #writable false},
  "SQRT1_2" : {#value 0.7071067811865476, #writable false},
  "SQRT2" : {#value 1.4142135623730951, #writable false},
  "exp" : {#value %exp, #writable false} }

let [%minMaxCall] = func(this, args, op, init) {
  let (end = args["length"<#value>])

    label ret: {
        if (end == 0) {
            break ret init
        } else { null };

        rec (loop = func(best, i) {
            if (prim("<", i, end)) {
              let (curr = %ToNumber(args[prim("prim->str", i)<#value>])) {
                if (curr != curr) {
                    break ret NaN
                } else { null };

                loop(op(best, curr), prim("+", i, 1))
              }
            } else { best }
        })
        break ret loop(init, 0)
    }
}

let [%mathMinCall] = func(obj, this, args) {
  %minMaxCall(this, args, %min, +inf)
}

let [%mathMin] = {[#code : %mathMinCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "min", %mathMin)}

let [%mathMaxCall] = func(obj, this, args) {
  %minMaxCall(this, args, %max, -inf)  
}

let [%mathMax] = {[#code : %mathMaxCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "max", %mathMax)}

let [%mathAbsCall] = func(obj, this, args) {
  let (n = %ToNumber(args["0"<#value>]))
    label ret: {
        if (n != n) { break ret n } else { null };
        if (n == -inf) { break ret +inf} else { null };
        break ret prim("abs", n)
    }
}

let [%mathAbs] = {[#code : %mathAbsCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "abs", %mathAbs)}

let [%acosCall] = func(obj, this, args) {
  "acos NYI"
}

let [%acos] = {[#code : %acosCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "acos", %acos)}

let [%asinCall] = func(obj, this, args) {
  "asin NYI"
}

let [%asin] = {[#code : %asinCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "asin", %asin)}

let [%atanCall] = func(obj, this, args) {
  "atan NYI"
}

let [%atan] = {[#code : %atanCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "atan", %atan)}

let [%atan2Call] = func(obj, this, args) {
  "atan2 NYI"
}

let [%atan2] = {[#code : %atan2Call, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "atan2", %atan2)}

let [%cosCall] = func(obj, this, args) {
  "cos NYI"
}

let [%cos] = {[#code : %cosCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "cos", %cos)}

let [%randomCall] = func(obj, this, args) {
  4 // IEEE-Vetted random number
}

let [%random] = {[#code : %randomCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 0, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "random", %random)}

let [%roundCall] = func(obj, this, args) {
  "round NYI"
}

let [%round] = {[#code : %roundCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "round", %round)}

let [%sinCall] = func(obj, this, args) {
  let (n = %ToNumber(args["0"<#value>])) {
    label ret: {
      if (n != n) {
        break ret n
      } else { null };

      if (n == 0) {
        break ret n
      } else { null };

      if (n == +inf) {
        break ret NaN
      } else { null };

      if (n == -inf) {
        break ret NaN
      } else { null };

      break ret prim("sin", n)
    }
  }
}

let [%sin] = {[#code : %sinCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "sin", %sin)}

let [%sqrtCall] = func(obj, this, args) {
  "sqrt NYI"
}

let [%sqrt] = {[#code : %sqrtCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "sqrt", %sqrt)}

let [%tanCall] = func(obj, this, args) {
  "tan NYI"
}

let [%tan] = {[#code : %tanCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "tan", %tan)}

let [%mathLogCall] = func(obj, this, args) {
  let (n = %ToNumber(args["0"<#value>]))
    label ret: {
        if (n != n) { break ret n } else { null };
        if (prim("<", n, 0)) { break ret NaN } else { null };
        if (n == 0) { break ret -inf } else { null };
        if (n == 1) { break ret 0 } else { null };
        if (n == +inf) { break ret n } else { null };
        break ret prim("log", n)
    }
}

let [%mathLog] = {[#code : %mathLogCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "log", %mathLog)}

let [%mathCeilCall] = func(obj, this, args) {
  let (x = %ToNumber(args["0"<#value>]))
    label ret: {
        if (x != x || x == 0 || x == -inf || x == +inf) {
            break ret x
        } else { null };
        break ret prim("ceil", x)
    }
}

let [%mathCeil] = {[#code : %mathCeilCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "ceil", %mathCeil)}

let [%mathFloorCall] = func(obj, this, args) {
  let (x = %ToNumber(args["0"<#value>]))
    label ret: {
        if (x != x || x == 0 || x == -inf || x == +inf) {
            break ret x
        } else { null };
        break ret prim("floor", x)
    }
}
  
let [%mathFloor] = {[#code : %mathFloorCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "floor", %mathFloor)}

let [%PrimAdd] = func(l, r) {
    let (l = %ToPrimitive(l))
    let (r = %ToPrimitive(r))
  if (prim("typeof", l) == "string") {
    prim("string+", prim("prim->str", l), prim("prim->str", r))
  } else if (prim("typeof", r) == "string") {
    prim("string+", prim("prim->str", l), prim("prim->str", r))
  } else {
    prim("+", prim("prim->num", l), prim("prim->num", r))
  }
}

let [%mathPowCall] = func(obj, this, args) {
    let (x = %ToNumber(args["0"<#value>]))
    let (y = %ToNumber(args["1"<#value>]))

    label ret: {
        if (y != y) {
            break ret NaN
        } else { null };

        if (y == 0) {
            break ret 1
        } else { null };

        if (x != x && y != 0) {
            break ret NaN
        } else { null };

        let (absX = prim("abs", x)) {
        if (prim(">", absX, 1) && y == +inf) {
            break ret +inf
        } else { null };

        if (prim(">", absX, 1) && y == -inf) {
            break ret 0
        } else { null };

        if (absX == 1 && ((y == +inf) || (y == -inf))) {
            break ret NaN
        } else { null };

        if (prim("<", absX, 1) && y == +inf) {
            break ret 0
        } else { null };

        if (prim("<", absX, 1) && y == -inf) {
            break ret +inf
        } else { null };

        if (x == +inf && prim(">", y, 0)) {
            break ret +inf
        } else { null };

        if (x == +inf && prim("<", y, 0)) {
            break ret 0
        } else { null };

        let (isOdd = func(n) {
            let (divided = prim("/", n, 2))
            (prim("floor", n) == n) && (prim("floor", divided) != divided)
        }) {
        if (x == -inf && prim(">", y, 0)) {
            break ret if (isOdd(y)) { -inf } else { +inf }
        } else { null };

        if (x == -inf && prim("<", y, 0)) {
            break ret 0
        } else { null };

        if (x == 0 && prim(">", y, 0)) {
            break ret 0
        } else { null };

        if (x == 0 && prim("<", y, 0)) {
            break ret +inf
        } else { null };

        // If x is -0 and y<0 and y is an odd integer, the result is -inf
        // If x is -0 and y<0 and y is not an odd integer, the result +inf
        let (oddY = isOdd(y))
        if (x == 0 && prim("<", y, 0) && oddY) {
            break ret -inf
        } else { null };
        if (x == 0 && prim("<", y, 0)) {
            break ret +inf
        } else { null };

        let (isFinite = func(n) {
            n != +inf && n != -inf
        })
        let (finiteX = isFinite(x))
        let (finiteY = isFinite(y))
        if (prim("<", x, 0) && finiteX && finiteY && prim("floor", y) != y) {
            break ret NaN
        } else { null };

        break ret prim("pow", x, y)
    }}}
}

let [%mathPow] = {[#code : %mathPowCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 2, #writable false, #enumerable false, #configurable false}}

{%define15Property(%Math, "pow", %mathPow)}

let [%valueOfCall] = func(this, args, proto, typestr) {
  let (hasWrongProto = this[<#proto>] != proto)
  let (hasWrongTypeof = %Typeof(this) != typestr)
  let (isntProto = this != proto)
  if (hasWrongProto && hasWrongTypeof && isntProto) {
    %TypeError("valueOf")
  } else {
    if (hasWrongTypeof) { this[<primval>] } else { this }
  }
}

let [%stringValueOf] = 
  {[#code : func(obj, this, args) { 
      %valueOfCall(this, args, %StringProto, "string") 
    },
    #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 0, #writable false, #enumerable false, #configurable false}}

{%define15Property(%StringProto, "valueOf", %stringValueOf)}

let [%numberValueOf] = 
  {[#code : func(obj, this, args) { 
      %valueOfCall(this, args, %NumberProto, "number") 
    },
    #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 0, #writable false, #enumerable false, #configurable false}}

{%define15Property(%NumberProto, "valueOf", %numberValueOf)}

let [%booleanValueOf] = 
 {[#code : func(obj, this, args) { 
    %valueOfCall(this, args, %BooleanProto, "boolean")
  },
  #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 0, #writable false, #enumerable false, #configurable false}}

{%define15Property(%BooleanProto, "valueOf", %booleanValueOf)}

let [%toFixedCall] = func(obj, this, args) {
  let (x = %numberPrimval(this))
  let (f = %ToInteger(args["0"<#value>])) {
    if (prim("<", f, 0) || prim(">", f, 20)) {
      %RangeError("invalid fractionDigits in Number.toFixed")
    };
    if (x === NaN) {
      "NaN"
    } else if (prim(">=", x, 1e21)) {
      %ToString(x)
    } else { prim("to-fixed", x, f) }
  }
}

let [%toFixed] = {[#code : %toFixedCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%NumberProto, "toFixed", %toFixed)}

let [%numTLSCall] = func(obj, this, args) {
  let (x = if (prim("typeof", this) == "number") { this } 
    else { this[<primval>] })
  let (obj = {[#proto : %StringProto, primval : prim("prim->str", x),]})
  %toLocaleString(obj, {[]})
}

let [%numTLS] = {[#code : %numTLSCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 0, #writable false, #enumerable false, #configurable false}}

{%define15Property(%NumberProto, "toLocaleString", %numTLS)}

let [%toExponentialCall] = func(obj, this, args) {
  // TODO: implement
  "toExponential NYI"
}

let [%toExponential] = {[#code : %toExponentialCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%NumberProto, "toExponential", %toExponential)}

let [%toPrecisionCall] = func(obj, this, args) {
  // TODO: implement
  "toPrecision NYI"
}

let [%toPrecision] = {[#code : %toPrecisionCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%NumberProto, "toPrecision", %toPrecision)}

let [%SignedRightShift] = func(l, r) {
  prim(">>", %ToInt32(l), %ToUint32(r))
}

let [%LeftShift] = func(l, r) {
  prim("<<", %ToInt32(l), %ToUint32(r))
}

let [%UnsignedRightShift] = func(l, r) {
  prim(">>>", %ToUint32(l), %ToUint32(r))
}

let [%PrepostOp] = func(op, is_pre) { func(v, fld, strict) {
  let (oldValue = %ToNumber(%GetField(v, fld)))
  let (newValue = op(oldValue, 1)) {
    %SetField(v, fld, newValue, strict);
    if (is_pre) { newValue } else { oldValue }
  }
}}

let [%PrimMultOp] = func(l, r, op) {
  op(%ToNumber(l), %ToNumber(r))
}

let [%PrimSub] = func(l, r) { %PrimMultOp(l, r, func(x1, x2) { prim("-", x1, x2) }) }
let [%PrimMult] = func(l, r) { %PrimMultOp(l, r, func(x1, x2) { prim("*", x1, x2) }) }
let [%PrimDiv] = func(l, r) { %PrimMultOp(l, r, func(x1, x2) { prim("/", x1, x2) }) }
let [%PrimMod] = func(l, r) { %PrimMultOp(l, r, func(x1, x2) { prim("%", x1, x2) }) }

let [%PrimComma] = func(l, r) { r }

let [%NumberCompareOp] = func(l, r) {
  if (l === NaN || r === NaN) { undefined }
  else if (l === r) { false }
  else if (l === 0 && r === -0) { false }
  else if (l === -0 && r === 0) { false }
  else if (l === +inf) { false }
  else if (r === +inf) { true }
  else if (r === -inf) { false }
  else if (l === -inf) { true }
  else { prim("<", l, r) }
}

let [%PrimitiveCompareOp] = func(l, r) {
  if (typeof l == "string" && typeof r == "string") { prim("string<", l, r) }
  else { %NumberCompareOp(prim("prim->num", l), prim("prim->num", r)) }
}

let [%CompareOp] = func(l, r, swap, neg) {
  let (px = %ToPrimitive(l))
  let (py = %ToPrimitive(r))
  let (res = if (swap) { %PrimitiveCompareOp(py, px) } else { %PrimitiveCompareOp(px, py) })
  if (res == undefined) { false }
  else if (neg) { !res } else { res }
}

let [%LtOp] = func(l, r) { %CompareOp(l, r, false, false) }
let [%GtOp] = func(l, r) { %CompareOp(l, r, true, false) }
let [%LeOp] = func(l, r) { %CompareOp(l, r, true, true) }
let [%GeOp] = func(l, r) { %CompareOp(l, r, false, true) }

let [%BitwiseInfix] = func(l, r, op) {
  let (lnum = %ToInt32(l))
  let (rnum = %ToInt32(r))
  op(lnum, rnum)
}

let [%BitwiseAnd] = func(l, r) { %BitwiseInfix(l, r, func(x1, x2) { prim("&", x1, x2) }) }
let [%BitwiseOr] = func(l, r) { %BitwiseInfix(l, r, func(x1, x2) { prim("|", x1, x2) }) }
let [%BitwiseXor] = func(l, r) { %BitwiseInfix(l, r, func(x1, x2) { prim("^", x1, x2) }) }

// 10.2.2.1
rec [%EnvGetId] = func(context, id, f) {
  if (context == null) {
    f(context)
  } else if (context[<#class>] == "DeclEnvRec") {
    if (prim("hasOwnProperty", context, id)) {
      f(context)
    } else { %EnvGetId(context[<parent>], id, f) }
  } else if (context[<#class>] == "ObjEnvRec") {
    let (bindings = context[<bindings>])
    if (%HasProperty(bindings, id)) {
      f(context)
    } else { %EnvGetId(context[<parent>], id, f) }
  } else { throw "[env] Context not well formed! In %EnvGetId" }
}

let [%EnvHasBinding] = func(context, id) {
  if (context[<#class>] == "DeclEnvRec") {
    prim("hasOwnProperty", context, id)
  } else if (context[<#class>] == "ObjEnvRec") {
    %HasProperty(context[<bindings>], id)
  } else { throw "[env] Context not well formed! In %EnvHasBinding" }
}

let [%DeclEnvAddBinding] = func(context, name, val, mutable, deletable) {
  %AddDataField(context, name, val, mutable, true, deletable)
}

let [%EnvCreateImmutableBinding] = func(context, id) {
  if (context[<#class>] == "DeclEnvRec") {
    %DeclEnvAddBinding(context, id, empty, true, false); empty
  } else { fail("[env] Context not well formed! In %EnvCreateImutableBinding") }
}

let [%EnvInitializeImmutableBinding] = func(context, id, val) {
  if (context[<#class>] == "DeclEnvRec") {
    if (context[id<#value>] != empty) { fail("Not an immutable binding") };
    context[id<#value> = val];
    context[id<#writable> = false];
    empty
  } else { fail("[env] Context not well formed! In %EnvInitializeImmutableBinding") }
}

let [%EnvCreateMutableBinding] = func(context, id, configurable) {
  if (context[<#class>] == "DeclEnvRec") {
    %DeclEnvAddBinding(context, id, undefined, true, configurable); empty
  } else if (context[<#class>] == "ObjEnvRec") {
    %defineOwnProperty(context[<bindings>], id, %makeDataDescriptor(undefined, true, true, configurable), true); empty
  } else { throw "[env] Context not well formed! In %EnvCreateMutableBinding" }
}

let [%EnvSetMutableBinding] = func(context, id, val, strict) {
  if (context[<#class>] == "DeclEnvRec") {
    if (context[id<#value>] == empty) {
      if (strict) { %TypeError(prim("string+", id, " is (uninitialized) read-only")) } else { empty }
    } else if (context[id<#writable>]) {
      context[id<#value> = val]; empty
    } else {
      if (strict) { %TypeError(prim("string+", id, " is read-only")) } else { empty }
    }
  } else if (context[<#class>] == "ObjEnvRec") {
    %Put1(context[<bindings>], id, val, strict) 
  } else { throw "[env] Context not well formed! In %EnvSetMutableBinding" }
}

let [%EnvCreateSetMutableBinding] = func(context, id, val, configurable, strict) {
  %EnvCreateMutableBinding(context, id, configurable);
  %EnvSetMutableBinding(context, id, val, strict)
}

let [%EnvGetBindingValue] = func(context, id, strict) {
  if (context[<#class>] == "DeclEnvRec") {
    if (context[id<#value>] == empty) { // uninitialized immutable binding
      if (strict) { %ReferenceError("reading an uninitialized binding") } else { undefined }
    } else {
      context[id<#value>] 
    }
  } else if (context[<#class>] == "ObjEnvRec") {
    let (bindings = context[<bindings>])
    if (%HasProperty(bindings, id)) {
      %Get1(bindings, id)
    } else {
      if (strict) { %ReferenceError("reading nonexistent binding") } else { undefined }
    }
  } else { throw "[env] Context not well formed! In %EnvGetBindingValue" }
}

let [%EnvGetValue] = func(context, id, strict) {
  if (context == null) {
    %UnboundId(id) 
  } else {
    %EnvGetBindingValue(context, id, strict)
  }
}

let [%EnvPutValue] = func(context, id, val, strict) {
  if (context == null) {
    if (strict) { %UnboundId(id) } else { 
      %Put1(%global, id, val, false)
    } 
  } else {
    %EnvSetMutableBinding(context, id, val, strict)
  }
}

let [%EnvAssign] = func(context, id, val_thunk, strict) {
  let (f = func(context) {
    let (val = val_thunk()) {
      %EnvPutValue(context, id, val, strict); val
    }
  })
  %EnvGetId(context, id, f)
}

let [%EnvModify] = func(context, id, op, val_thunk, strict) {
  let (f = func(context) {
    let (val = op(%EnvGetValue(context, id, strict), val_thunk())) {
      %EnvPutValue(context, id, val, strict); val
    }
  })
  %EnvGetId(context, id, f)
}

let [%EnvGet] = func(context, id, strict) {
  let (f = func(context) {
    %EnvGetValue(context, id, strict)
  }) 
  %EnvGetId(context, id, f)
}

rec [%EnvTypeof] = func(context, id, strict) {
  let (f = func(context) {
    if (context == null) {
      "undefined"
    } else {
      %Typeof(%EnvGetBindingValue(context, id, strict))
    }
  })
  %EnvGetId(context, id, f)
}

rec [%EnvDelete] = func(context, id, strict) {
  let (f = func(context) {
    if (strict) { %SyntaxError("unqualified name delete in strict mode") };
    if (context == null) {
      true
    } else if (context[<#class>] == "DeclEnvRec") {
      if (context[id<#configurable>]) { context[delete id]; true }
      else { false } 
    } else if (context[<#class>] == "ObjEnvRec") {
      %Delete(context[<bindings>], id, false) 
    } else { throw "[env] Context not well formed! In %EnvDelete" }
  })
  %EnvGetId(context, id, f)
}

let [%EnvPrepostOp] = func(context, id, op, is_pre, strict) {
  let (f = func(context) {
    let (oldValue = %ToNumber(%EnvGetValue(context, id, strict)))
    let (newValue = op(oldValue, 1)) {
      %EnvPutValue(context, id, newValue, strict);
      if (is_pre) { newValue } else { oldValue }
    }
  })
  %EnvGetId(context, id, f)
}

let [%EnvImplicitThis] = func(context) {
  if (context[<#class>] == "DeclEnvRec") {
    undefined
  } else if (context[<#class>] == "ObjEnvRec") {
    if (context[<provideThis>]) { context[<bindings>] } else { undefined }
  } else { throw "[env] Context not well formed! In %EnvImplicitThis" }
}

// 10.2.2.3
let [%newObjEnvRec] = func(parent, obj, pt) {
  {[parent: parent, #class: "ObjEnvRec", #extensible: true,
    bindings: obj,
    provideThis: pt]}
}

let [%newDeclEnvRec] = func(parent) {
  {[parent: parent, #class: "DeclEnvRec", #extensible: true]}
}

// The global environment (10.2.3)
let [%globalContext] = %newObjEnvRec(null, %global, false)

// 10.5 step 4
let [%EnvDefineArg] = func(context, id, val, strict) {
  if (!%EnvHasBinding(context, id)) {
    %EnvCreateMutableBinding(context, id, false)
  };
  %EnvSetMutableBinding(context, id, val, strict);
  empty
}

// 10,5 step 8
let [%EnvDefineVar] = func(context, id, configurableBindings, strict) {
  if (!%EnvHasBinding(context, id)) {
    %EnvCreateSetMutableBinding(context, id, undefined, configurableBindings, strict)
  };
  empty
}

// 10.5 step 5
let [%EnvDefineFunc] = func(context, id, fo, configurableBindings, strict) {
  if (!%EnvHasBinding(context, id)) {
    %EnvCreateMutableBinding(context, id, configurableBindings)
  } else if (context == %globalContext) {
    if (%global[id<#configurable>]) {
      %defineOwnProperty(%global, id, %makeDataDescriptor(undefined, true, true, configurableBindings), true)
    } else if (prim("isAccessor", %global, id) || !%global[id<#writable>] || !%global[id<#enumerable>]) {
      %TypeError("cannot redefine function")
    }
  };
  %EnvSetMutableBinding(context, id, fo, strict)
}

let [%mkArgsObj] = func(context, ids, args, obj, strict) {
  let (argsObj = {[#proto: %ObjectProto,
                   #class: "Arguments",
                   #extensible: true]}) {
    if (strict) {
      %AddAccessorField(argsObj, "callee", %ThrowTypeError, %ThrowTypeError, false, false);
      %AddAccessorField(argsObj, "caller", %ThrowTypeError, %ThrowTypeError, false, false)
    } else {
      %AddDataField(argsObj, "callee", obj, true, false, true)
    };
// TODO non-strict args obj
    rec (loop = func(iter) { 
      let (strx = prim("prim->str", iter)) 
      if (prim("hasOwnProperty", args, strx)) { 
        argsObj[strx<#value> = args[strx<#value>]];
        loop(iter + 1)
      }
      else { 
        argsObj["length"<#value> = iter];
        argsObj["length"<#enumerable> = false]
      }
    }) {
      loop(0);
      argsObj
    }
  }
}

// 10.5 step 7
let [%EnvDefineArgsObjOk] = func(context, ids, args, obj, strict) {
  let (aobj = %mkArgsObj(context, ids, args, obj, strict))
  if (strict) {
    %EnvCreateImmutableBinding(context, "arguments");
    %EnvInitializeImmutableBinding(context, "arguments", aobj)
  } else {
    %EnvCreateSetMutableBinding(context, "arguments", aobj, false, false)
  }
}

// 10.5 step 6-7
let [%EnvDefineArgsObj] = func(context, ids, args, obj, strict) {
  if (context[<#class>] != "DeclEnvRec") { fail("[env] %EnvDefineArgsObj needs a declarative env record") };
  if (!%EnvHasBinding(context, "arguments")) {
    %EnvDefineArgsObjOk(context, ids, args, obj, strict)
  }
}

// 11.4.6
let [%UnaryPlus] = func(expr) {
  %ToNumber(expr)
}

// 11.4.7
let [%UnaryNeg] = func(expr) {
  -%ToNumber(expr)
}

let [%BitwiseNot] = func(expr) {
  prim("~", %ToInt32(expr))
}

let [%UnaryNot] = func(expr) {
  !%ToBoolean(expr)
}

let [%logCall] = func(obj, this, args) {
  rec (loop = func(i) {
    if (%HasProperty(args, prim("prim->str", i))) {
      prim("pretty", args[prim("prim->str", i)<#value>]);
      loop(prim("+", i, 1))
    } else {
      undefined
    }
  })  
  loop(0)
}

let [%log] = { [#code : %logCall, #proto: %FunctionProto, #class: "Function"] }

let [%console] = {
  [#proto: null,]
  "log": {#value %log, #writable false},
  "info": {#value %log, #writable false},
  "warn": {#value %log, #writable false},
  "error": {#value %log, #writable false}
}

let [%configurableEval] = func(this, context, vcontext, useStrict, args) {
  let (evalStr = args["0"<#value>])
  let (evalStr = if (useStrict) {
    prim("string+", "'use strict';", evalStr)
  } else {
    evalStr
  })
  let (globalEnv = %makeGlobalEnv['make'<#value>]()) {
    globalEnv["$this"<#value> = this];
    globalEnv["$context"<#value> = context];
    globalEnv["$vcontext"<#value> = vcontext];
    globalEnv["evalCode"<#value> = true];
    if (typeof evalStr == 'string') {
      let (ret = @eval(evalStr, globalEnv))
      if (ret == empty) { undefined } else { ret }
    } else {
      evalStr
    }
  }
}

let [%evalCall] = func(obj, this, args) {
  %configurableEval(%global, %globalContext, %globalContext, false, args)
}

let [%eval] = { [#code : %evalCall, #proto: %FunctionProto, #class: "Function"] }

let [%EnvAppExpr] = func(pcontext, vcontext, id, this, args_thunk, strict) {
  let (f = func(context) {
    let (fun = %EnvGetValue(context, id, strict))
    let (args = args_thunk())
    if (id == "eval" && fun == %eval) {
      %configurableEval(this, pcontext, vcontext, strict, args)
    } else if(%IsCallable(fun)) {
      %AppExpr(fun, %EnvImplicitThis(context), args)
    } else {
      %TypeError("Not a function")
    }
  })
  %EnvGetId(pcontext, id, f)
}

let [%FunctionConstructor] = func(this, args) {
  let (argCount = %ComputeLength(args))
  rec (formArgString = func(n, result) {
    if (n == prim("-", argCount, 1)) {
      result
    } else {
      let (currentArg = %ToString(args[prim("prim->str", n)<#value>]))
      let (next = 
        if (n == prim("-", argCount, 2)) { 
          prim("string+", result, currentArg)
        } else {
          prim("string+", prim("string+", result, currentArg), ",")
        })
      formArgString(prim("+", n, 1), next)
    }
  })
  let (body = 
    if (argCount == 0) { "" } else {
      args[prim("prim->str", prim("-", argCount, 1))<#value>]
    })
  let (P = if (argCount == 0 || argCount == 1) { "" }
    else { formArgString(0, "") })
  let (prefix = 
    prim("string+", "((function(){ return function (", 
                    prim("string+", P, "){")))
  let (final = prim("string+", prefix, prim("string+", body, "}; })());")))
  %evalCall(undefined, {[] "0": {#value final, #writable false}})
}

let [%FunctionGlobalFuncObj] = 
  { [#code : %RunSelfConstructorCall, #proto : %FunctionProto, #class: "Function", construct: %FunctionConstructor] 
    "prototype" : {#value %FunctionProto, #writable false},
    "length" : {#value 0, #writable false}
  } {
          %FunctionProto["constructor"<#value> = %FunctionGlobalFuncObj];
          %FunctionProto["constructor"<#enumerable> = false] 
  }


let [%isFiniteCall] = func(obj, this, args) {
  %IsFinite(%ToNumber(args["0"<#value>]))
}

let [%isFinite] = {[#code : %isFiniteCall, #proto : %FunctionProto, #class: "Function"]}

let [%parseFloatCall] = func(obj, this, args) {
  "parseFloat NYI"
}

let [%parseFloat] = {[#code : %parseFloatCall, #proto : %FunctionProto, #class: "Function"]}

{
  %define15Property(%global, "window", %global);
  %define15Property(%global, "print", %print);
  %define15Property(%global, "console", %console);
  %define15Property(%global, "Array", %ArrayGlobalFuncObj);
  %define15Property(%global, "String", %StringGlobalFuncObj);
  %define15Property(%global, "Object", %ObjectGlobalFuncObj);
  %define15Property(%global, "Number", %NumberGlobalFuncObj);
  %define15Property(%global, "Boolean", %BooleanGlobalFuncObj);
  %define15Property(%global, "Date", %DateGlobalFuncObj);
  %define15Property(%global, "Function", %FunctionGlobalFuncObj);
  %define15Property(%global, "isNaN", %isNaN);
  %define15Property(%global, "isFinite", %isFinite);
  %define15Property(%global, "Math", %Math);
  %define15Property(%global, "parseInt", %parseInt);
  %define15Property(%global, "parseFloat", %parseFloat);
  %define15Property(%global, "decodeURI", %decodeURI);
  %define15Property(%global, "decodeURIComponent", %decodeURIComponent);
  %define15Property(%global, "encodeURI", %encodeURI);
  %define15Property(%global, "encodeURIComponent", %encodeURIComponent);
  %define15Property(%global, "TypeError", %TypeErrorGlobalFuncObj);
  %define15Property(%global, "ReferenceError", %ReferenceErrorGlobalFuncObj);
  %define15Property(%global, "SyntaxError", %SyntaxErrorGlobalFuncObj);
  %define15Property(%global, "RangeError", %RangeErrorGlobalFuncObj);
  %define15Property(%global, "EvalError", %EvalErrorGlobalFuncObj);
  %define15Property(%global, "URIError", %URIErrorGlobalFuncObj);
  %define15Property(%global, "Error", %ErrorGlobalFuncObj);
  %define15Property(%global, "RegExp", %RegExpGlobalFuncObj);

  %ObjectProto["propertyIsEnumerable"<#value> = %propEnum];
  %ObjectProto["propertyIsEnumerable"<#enumerable> = false]
}

{%define15Property(%global, "eval", %eval)}

{%AddDataField(%global, "NaN", NaN, false, false, false)}
{%AddDataField(%global, "Infinity", +inf, false, false, false)}
{%AddDataField(%global, "undefined", undefined, false, false, false)}

let [%escapeCall] = func(obj, this, args) {
  "escape NYI"
}

let [%escape] = {[#code : %escapeCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%global, "escape", %escape)}

let [%unescapeCall] = func(obj, this, args) {
  "unescape NYI"
}

let [%unescape] = {[#code : %unescapeCall, #proto : %FunctionProto, #class: "Function"]
  "length" : {#value 1, #writable false, #enumerable false, #configurable false}}

{%define15Property(%global, "unescape", %unescape)}

{(/*:START SYM EVAL*/0)}


