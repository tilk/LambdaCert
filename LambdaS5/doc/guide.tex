\documentclass[draft, 10pt]{article}

\usepackage[a4paper, margin=1in]{geometry}

\usepackage{amsmath}
\usepackage{amsopn}
\usepackage{mathtools}
\usepackage{nccmath}
\usepackage{wasysym}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{multicol}
\usepackage{textcomp}
\usepackage{mathpartir}

\title{LambdaJS quick reference}
\author{Marek Materzok}

\newcommand{\expr}[0]{e}
\newcommand{\var}[0]{x}
\newcommand{\lit}[0]{l}
\newcommand{\bool}[0]{b}
\newcommand{\num}[0]{n}
\newcommand{\str}[0]{s}
\newcommand{\id}[0]{i}
\newcommand{\eprop}[0]{pe}
\newcommand{\undef}[0]{\textbf{undef}}
\newcommand{\nul}[0]{\textbf{null}}
\newcommand{\empt}[0]{\textbf{empty}}
\newcommand{\true}[0]{\textbf{true}}
\newcommand{\false}[0]{\textbf{false}}
\newcommand{\unop}[0]{\textit{un}}
\newcommand{\binop}[0]{\textit{bin}}
\newcommand{\pattr}[0]{\textit{pa}}
\newcommand{\oattr}[0]{\textit{oa}}
\newcommand{\pavalue}[0]{\textbf{value}}
\newcommand{\pawritable}[0]{\textbf{writable}}
\newcommand{\paget}[0]{\textbf{getter}}
\newcommand{\paset}[0]{\textbf{setter}}
\newcommand{\paenum}[0]{\textbf{enumerable}}
\newcommand{\paconfig}[0]{\textbf{configurable}}
\newcommand{\oaproto}[0]{\textbf{proto}}
\newcommand{\oaclass}[0]{\textbf{class}}
\newcommand{\oaextens}[0]{\textbf{extensible}}
\newcommand{\oacode}[0]{\textbf{code}}
\newcommand{\unap}[1]{\unop \thinspace #1}
\newcommand{\binap}[2]{#1 \thinspace \binop \thinspace #2}
\newcommand{\ap}[2]{#1\thinspace(#2)}
\newcommand{\func}[2]{\textbf{func}\thinspace(#1)\thinspace #2}
\newcommand{\seq}[2]{#1 \thinspace ; \thinspace #2}
\newcommand{\jseq}[2]{#1 \thinspace ;; \thinspace #2}
\newcommand{\letdef}[3]{\textbf{let} \thinspace (#1 = #2) \thinspace #3}
\newcommand{\recdef}[3]{\textbf{rec} \thinspace (#1 = #2) \thinspace #3}
\newcommand{\ife}[3]{\textbf{if} \thinspace (#1) \thinspace #2 \thinspace \textbf{else} \thinspace #3}
\newcommand{\lbl}[2]{\textbf{label} \thickspace #1: #2}
\newcommand{\brk}[2]{\textbf{break} \thickspace #1 \thickspace #2}
\newcommand{\throw}[1]{\textbf{throw} \thickspace #1}
\newcommand{\trycatch}[3]{\textbf{try} \thickspace #1 \thickspace \textbf{catch}\thinspace(#2) \thinspace #3}
\newcommand{\tryfin}[2]{\textbf{try} \thickspace #1 \thickspace \textbf{finally} \thickspace #2}
\newcommand{\getattr}[3]{#2 \thinspace [ #3 \langle #1 \rangle ] }
\newcommand{\setattr}[4]{#2 \thinspace [ #3 \langle #1 \rangle = #4 ] }
\newcommand{\delattr}[2]{#1 \thinspace [ \textbf{delete} \thickspace #2 ]}
\newcommand{\getoattr}[2]{#2 \thinspace [ \langle #1 \rangle ]}
\newcommand{\setoattr}[3]{#2 \thinspace [ \langle #1 \rangle = #3 ]}
\newcommand{\bnfsep}[0]{\thinspace | \thinspace}
\newcommand{\optypeof}[0]{\textbf{typeof}}
\newcommand{\opstrlen}[0]{\textbf{strlen}}
\newcommand{\opisprim}[0]{\textbf{is-primitive}}
\newcommand{\opisclosure}[0]{\textbf{is-closure}}
\newcommand{\ophasprop}[0]{\textbf{has-own-property}}
\newcommand{\opstrplus}[0]{+_{\str}}
\newcommand{\opstrlt}[0]{<_{\str}}

\newcommand{\bigstep}[5]{#1;#2;#3 \Downarrow #4;#5}
\newcommand{\varenv}[0]{\Delta}
\newcommand{\heap}[0]{\Phi}
\newcommand{\subst}[3]{#1[#3/#2]}
\newcommand{\mapget}[2]{#1(#2)}
\newcommand{\mapadd}[3]{#1(#2 = #3)}
\newcommand{\mapfresh}[2]{#1 \not\in #2}
\newcommand{\closure}[3]{(#1; #2; #3)}
\newcommand{\bigret}[0]{r}
\newcommand{\bigval}[0]{v}
\newcommand{\oprop}[0]{p}
\newcommand{\obj}[0]{o}
\newcommand{\objlit}[2]{\{[#1]\thinspace#2\}}
\newcommand{\bigthrow}[1]{\throw{#1}}
\newcommand{\bigbrk}[2]{\brk{#1}{#2}}
\newcommand{\heapptr}{ptr}
\newcommand{\oavalid}[2]{#2 \textrm{ is valid } #1}
\newcommand{\pavalid}[2]{#2 \textrm{ is valid } #1}
\newcommand{\objextens}[1]{#1 \textrm{ extensible}}
\newcommand{\oawrit}[2]{#1 \textrm{ writable in } #2}
\newcommand{\pawrit}[2]{#1 \textrm{ writable in } #2}
\newcommand{\papropset}[3]{#1(#2 = #3)}
\newcommand{\defaultprop}[0]{\textrm{defaultprop}}
\newcommand{\papropnew}[2]{\papropset{\defaultprop}{#1}{#2}}

\newcommand{\rununop}[3]{#1(#2,#3)}
\newcommand{\runbinop}[4]{#1(#2,#3,#4)}

\newcommand{\ovempty}[2]{#1 + #2}
\newcommand{\bigretabort}[1]{\textrm{abort}(#1)}

\begin{document}

\maketitle

\section{Syntax}

\[
\begin{array}{rcl}
\expr & ::= & \var \bnfsep \lit \bnfsep \ap{\expr}{\expr, \dots} \bnfsep
              \func{\var, \dots}{\expr} \bnfsep
              \unap{\expr} \bnfsep \binap{\expr}{\expr} \bnfsep
              \seq{\expr}{\expr} \bnfsep \jseq{\expr}{\expr} \bnfsep \\
          & & \letdef{\var}{\expr}{\expr} \bnfsep \recdef{\var}{\expr}{\expr} \bnfsep
              \ife{\expr}{\expr}{\expr} \bnfsep \\
          & & \lbl{\id}{\expr} \bnfsep \brk{\id}{\expr} \bnfsep
              \throw{\expr} \bnfsep \trycatch{\expr}{\var}{\expr} \bnfsep \tryfin{\expr}{\expr} \bnfsep \\
          & & \getattr{\pattr}{\expr}{\expr} \bnfsep \setattr{\pattr}{\expr}{\expr}{\expr} \bnfsep
              \delattr{\expr}{\expr} \bnfsep \getoattr{\oattr}{\expr} \bnfsep 
              \setoattr{\oattr}{\expr}{\expr} \bnfsep \\
          & & \{[\oattr: \expr, \dots] \thinspace \str : \eprop, \dots \} \\
\eprop & ::= & \{\pavalue : \expr, \pawritable : \expr, \paenum : \expr, \paconfig : \expr \} \bnfsep \\
           & & \{\paget : \expr, \paset : \expr, \paenum : \expr, \paconfig : \expr \} \\
\lit & ::= & \bool \bnfsep \num \bnfsep \str \bnfsep \undef \bnfsep \nul \bnfsep \empt \\
\bool & ::= & \true \bnfsep \false \\
\num & ::= & \textit{IEEE floating-point numbers} \\
\str & ::= & \textit{UTF-16 encoded strings} \\
\unop & ::= & \optypeof \bnfsep \opstrlen \bnfsep \opisprim \bnfsep \opisclosure \bnfsep \dots \\
\binop & ::= & + \bnfsep - \bnfsep * \bnfsep / \bnfsep \% \bnfsep < \bnfsep == \bnfsep === \bnfsep 
               \ophasprop \bnfsep \\
           & & \opstrplus \bnfsep \opstrlt \bnfsep \dots \\
\pattr & ::= & \pavalue \bnfsep \pawritable \bnfsep \paget \bnfsep \paset \bnfsep
               \paenum \bnfsep \paconfig \\
\oattr & ::= & \oaproto \bnfsep \oaclass \bnfsep \oaextens \bnfsep \oacode \bnfsep \dots
\end{array}
\]

\section{Semantics}

Presented in big-step style; the formalized pretty-big-step semantics in Coq can be obtained
from it. Abort-handling rules (for throws and breaks) are not presented.

\[
\begin{array}{rcl}
\bigval & ::= & \lit \bnfsep \closure{\varenv}{\var, \dots, \var}{\expr} \bnfsep \heapptr \\
\bigret & ::= & \bigval \bnfsep \bigthrow{\bigval} \bnfsep \bigbrk{\id}{\bigval} \\
\heapptr & ::= & \textit{heap pointers} \\
\obj & ::= & \objlit{\oaproto : \bigval, \oaclass : \str, \oaextens : \bool, \oacode : \bigval, \dots}{\str : \oprop, \dots} \\
\oprop & ::= & \{\pavalue : \bigval, \pawritable : \bigval, \paenum : \bool, \paconfig : \bool \} \bnfsep \\
           & & \{\paget : \bigval, \paset : \bigval, \paenum : \bool, \paconfig : \bool \} \\
\end{array}
\]

\[
\begin{array}{rcll}
\ovempty{\bigval}{\empt} &=& \bigval & \\
\ovempty{\bigval}{\bigval'} &=& \bigval' & \bigval' \not= \empt \\
\ovempty{\bigval}{\bigthrow{\bigval'}} &=& \bigthrow{\bigval} \\
\ovempty{\bigval}{\bigbrk{\id}{\bigval'}} &=& \bigbrk{\id}{(\ovempty{\bigval}{\bigval'})}
\end{array}
\]

\begin{mathpar}
\inferrule{ }{\bigretabort{\bigthrow{\bigval}}} \and 
\inferrule{ }{\bigretabort{\bigbrk{\id}{\bigval}}}
\end{mathpar}

\begin{mathpar}
\inferrule{ }{\bigstep{\varenv}{\heap}{\lit}{\heap}{\lit}} \and
\inferrule{ }{\bigstep{\varenv}{\heap}{\var}{\heap}{\mapget{\varenv}{\var}}} \and
\inferrule{ }{\bigstep{\varenv}{\heap}{\func{\var_1, \dots, \var_n}{\expr}}{\heap}{\closure{\varenv}{\var_1, \dots, \var_n}{\expr}}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr}{\heap_0}{\closure{\varenv'}{\var_1,\dots,\var_n}{\expr'}} \\ \forall i, \bigstep{\varenv}{\heap_{i-1}}{\expr_i}{\heap_i}{\bigval_i} \\ \bigstep{\mapadd{\varenv'}{\var_1,\dots,\var_n}{\bigval_1,\dots,\bigval_n}}{\heap_n}{\expr'}{\heap'}{\bigret}}{\bigstep{\varenv}{\heap}{\ap{\expr}{\expr_1,\dots,\expr_n}}{\heap'}{\bigret}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr}{\heap'}{\bigval} \\ \rununop{\unop}{\heap'}{\bigval}=\bigval'}{\bigstep{\varenv}{\heap}{\unap{\expr}}{\heap'}{\bigval'}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap'}{\bigval_1} \\ \bigstep{\varenv}{\heap'}{\expr_1}{\heap''}{\bigval_2} \\ \runbinop{\binop}{\heap''}{\bigval_1}{\bigval_2}=\bigval}{\bigstep{\varenv}{\heap}{\binap{\expr_1}{\expr_2}}{\heap''}{\bigval}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap'}{\bigval} \\ \bigstep{\varenv}{\heap'}{\expr_2}{\heap''}{\bigret}}{\bigstep{\varenv}{\heap}{\seq{\expr_1}{\expr_2}}{\heap''}{\bigret}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap'}{\bigval} \\ \bigstep{\varenv}{\heap'}{\expr_2}{\heap''}{\bigret} \\ \bigret' = \ovempty{\bigval}{\bigret}}{\bigstep{\varenv}{\heap}{\jseq{\expr_1}{\expr_2}}{\heap''}{\bigret'}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap'}{\bigval} \\ \bigstep{\mapadd{\varenv}{\var}{\bigval}}{\heap'}{\expr_2}{\heap''}{\bigret}}{\bigstep{\varenv}{\heap}{\letdef{\var}{\expr_1}{\expr_2}}{\heap''}{\bigret}} \and
\inferrule{\varenv' = \mapadd{\varenv}{\var}{\closure{\varenv'}{\var_1,\dots,\var_n}{\expr}} \\ \bigstep{\varenv'}{\heap}{\expr'}{\heap'}{\bigret}}{\bigstep{\varenv}{\heap}{\recdef{\var}{\func{\var_1,\dots,\var_n}{\expr}}{\expr'}}{\heap'}{\bigret}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr}{\heap'}{\true} \\ \bigstep{\varenv}{\heap'}{\expr_1}{\heap''}{\bigret}}{\bigstep{\varenv}{\heap}{\ife{\expr}{\expr_1}{\expr_2}}{\heap''}{\bigret}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr}{\heap'}{\false} \\ \bigstep{\varenv}{\heap'}{\expr_2}{\heap''}{\bigret}}{\bigstep{\varenv}{\heap}{\ife{\expr}{\expr_1}{\expr_2}}{\heap''}{\bigret}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr}{\heap'}{\bigbrk{\id}{\bigval}}}{\bigstep{\varenv}{\heap}{\lbl{\id}{\expr}}{\heap'}{\bigval}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr}{\heap'}{\bigret} \\ \forall \bigval, \bigret \not= \bigbrk{\id}{\bigval}}{\bigstep{\varenv}{\heap}{\lbl{\id}{\expr}}{\heap'}{\bigret}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr}{\heap'}{\bigval}}{\bigstep{\varenv}{\heap}{\brk{\id}{\expr}}{\heap'}{\bigbrk{\id}{\bigval}}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr}{\heap'}{\bigval}}{\bigstep{\varenv}{\heap}{\throw{\expr}}{\heap'}{\bigthrow{\bigval}}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap'}{\bigret} \\ \forall \bigval, \bigret \not= \bigthrow{\bigval}}{\bigstep{\varenv}{\heap}{\trycatch{\expr_1}{\var}{\expr_2}}{\heap'}{\bigret}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap'}{\bigret} \\ \bigstep{\varenv}{\heap'}{\expr_2}{\heap''}{\bigval}}{\bigstep{\varenv}{\heap}{\tryfin{\expr_1}{\expr_2}}{\heap''}{\bigret}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap'}{\bigret} \\ \bigstep{\varenv}{\heap'}{\expr_2}{\heap''}{\bigret'} \\ \bigretabort{\bigret'}}{\bigstep{\varenv}{\heap}{\tryfin{\expr_1}{\expr_2}}{\heap''}{\bigret'}} 

\end{mathpar}

\begin{mathpar}
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap'}{\heapptr} \\ \bigstep{\varenv}{\heap'}{\expr_2}{\heap''}{\str} \\ \mapget{\heap''}{\heapptr} = \objlit{\dots}{\str : \{\pattr : \bigval\}, \dots}}{\bigstep{\varenv}{\heap}{\getattr{\pattr}{\expr_1}{\expr_2}}{\bigval}{\heap''}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap_1}{\heapptr} \\ \bigstep{\varenv}{\heap_1}{\expr_2}{\heap_2}{\str} \\ \bigstep{\varenv}{\heap_2}{\expr_3}{\heap_3}{\bigval} \\ \mapget{\heap_3}{\heapptr} = \obj \\ \obj = \objlit{\dots}{\dots} \\ \str \textrm{ not a property in } \obj \\ \objextens{\obj} \\ \pavalid{\pattr}{\bigval} \\ \heap' = \mapadd{\heap_3}{\heapptr}{\objlit{\dots}{\str : \papropnew{\pattr}{\bigval}, \dots}}}{\bigstep{\varenv}{\heap}{\setattr{\pattr}{\expr_1}{\expr_2}{\expr_3}}{\heap'}{\bigval}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap_1}{\heapptr} \\ \bigstep{\varenv}{\heap_1}{\expr_2}{\heap_2}{\str} \\ \bigstep{\varenv}{\heap_2}{\expr_3}{\heap_3}{\bigval} \\ \mapget{\heap_3}{\heapptr} = \obj \\ \obj = \objlit{\dots}{\str : \oprop, \dots} \\ \pavalid{\pattr}{\bigval} \\ \pawrit{\pattr}{\obj} \\ \heap' = \mapadd{\heap_3}{\heapptr}{\objlit{\dots}{\str : \papropset{\oprop}{\pattr}{\bigval}, \dots}}}{\bigstep{\varenv}{\heap}{\setattr{\pattr}{\expr_1}{\expr_2}{\expr_3}}{\heap'}{\bigval}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap_1}{\heapptr} \\ \bigstep{\varenv}{\heap_1}{\expr_2}{\heap_2}{\str} \\ \mapget{\heap_2}{\heapptr} = \objlit{\dots}{\str : \{\paconfig: \true, \dots\}, \dots} \\ \heap' = \mapadd{\heap_2}{\heapptr}{\objlit{\dots}{\dots}}}{\bigstep{\varenv}{\heap}{\delattr{\expr_1}{\expr_2}}{\bigval}{\heap'}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr}{\heapptr}{\heap'} \\ \mapget{\heap'}{\heapptr} = \objlit{\oattr : \bigval, \dots}{\dots}}{\bigstep{\varenv}{\heap}{\getoattr{\oattr}{\expr}}{\bigval}{\heap'}} \and
\inferrule{\bigstep{\varenv}{\heap}{\expr_1}{\heap_1}{\heapptr} \\ \bigstep{\varenv}{\heap_1}{\expr_2}{\heap_2}{\bigval} \\ \mapget{\heap_2}{\heapptr} = \obj \\ \obj = \objlit{\oattr : \bigval', \dots}{\dots} \\ \oavalid{\oattr}{\bigval} \\ \oawrit{\oattr}{\obj} \\ \heap' = \mapadd{\heap_2}{\heapptr}{\objlit{\oattr : \bigval, \dots}{\dots}}}{\bigstep{\varenv}{\heap}{\setoattr{\oattr}{\expr_1}{\expr_2}}{\heap'}{\bigval}} \and
\inferrule{\forall i, \bigstep{\varenv}{\heap_{i-1}}{\expr_i}{\heap_i}{\bigval_i} \\ \textrm{$\bigval_3$ and $\bigval_4$ are bools}}{\bigstep{\varenv}{\heap_0}{\{\paget : \expr_1, \paset : \expr_2, \paenum : \expr_3, \paconfig : \expr_4\}}{\\\\\heap_4}{\{\paget : \bigval_1, \paset : \bigval_2, \paenum : \bigval_3, \paconfig : \bigval_4\}}} \and
\inferrule{\forall i, \bigstep{\varenv}{\heap_{i-1}}{\expr_i}{\heap_i}{\bigval_i} \\ \textrm{$\bigval_2$, $\bigval_3$ and $\bigval_4$ are bools}}{\bigstep{\varenv}{\heap_0}{\{\pavalue : \expr_1, \pawritable : \expr_2, \paenum : \expr_3, \paconfig : \expr_4\}}{\\\\\heap_4}{\{\pavalue : \bigval_1, \pawritable : \bigval_2, \paenum : \bigval_3, \paconfig : \bigval_4\}}} \and
\inferrule{\forall i, \bigstep{\varenv}{\heap_{i-1}}{\expr_i}{\heap_i}{\bigval_1} \\ \forall i, \bigstep{\varenv}{\heap_{n+i-1}}{\eprop_i}{\heap_{n+i}}{\oprop_i}  \\ \textrm{$\oattr_1, \dots, \oattr_n$ distinct}  \\ \textrm{$\str1, \dots, \str_m$ distinct} \\ \{\oaproto, \oaclass, \oaextens, \oacode\} \subseteq \{\oattr_i : i \in \{1,\dots,n\}\} \\ \forall i, \oavalid{\oattr_i}{\bigval_i} \\ \mapfresh{\heapptr}{\heap_{n+m}}}{\bigstep{\varenv}{\heap}{\objlit{\oattr_1: \expr_1, \dots, \oattr_n: \expr_n}{\str_1 : \eprop_1, \dots, \str_m : \eprop_m}}{\\\\\mapadd{\heap_{n+m}}{\heapptr}{\objlit{\oattr_1 : \bigval_1, \dots, \oattr_n : \bigval_n}{\str_1 : \oprop_1, \dots, \str_m : \oprop_m}}}{\heapptr}}
\end{mathpar}

\end{document}
